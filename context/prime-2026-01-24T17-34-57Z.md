# Codebase Export: 2026-01-24T17:34:57Z

## Project Tree

```
AI Overload/
  .claude/ (18 files)
    / (18 files)
      commands/ (15 files)
        / (15 files)
          check.md
          development.md
          discovery.md
          execution.md
          learn.md
          learn-health.md
          planning.md
          prime.md
          review.md
          task-planning.md
          template.md
          test.md
          update-index.md
          update-status.md
          workflow.md
      templates/ (1 files)
        / (1 files)
          STATUS.md
      settings.json
      settings.local.json
  context/ (4 files)
    / (4 files)
      INDEX.md
      prime-2026-01-24T09-32-50Z.md
      prime-2026-01-24T18-21-11Z.md
      prime-2026-01-24T20-31-03Z.md
  discovery/ (2 files)
    / (2 files)
      discovery-2026-01-24T18-33-22Z.md
      INDEX.md
  execution/ (29 files)
    / (29 files)
      01-create-directory-structure.md
      02-create-index-generator.md
      03-create-status-format.md
      04-create-command-template.md
      05-implement-prime-command.md
      06-implement-discovery-command.md
      07-implement-planning-command.md
      08-implement-development-command.md
      09-create-prp-base-template.md
      10-create-prp-specialized-templates.md
      11-implement-pattern-extraction.md
      12-implement-task-planning-command.md
      13-implement-execution-command.md
      14-implement-review-command.md
      15-implement-test-command.md
      16-implement-workflow-command.md
      17-implement-error-handling.md
      18-integrate-archon-mcp.md
      19-integrate-web-mcp-servers.md
      20-end-to-end-testing.md
      21-create-main-index.md
      22-create-readme.md
      23-performance-optimization.md
      24-system-validation-final-testing.md
      25-documentation-review-updates.md
      26-security-audit-hardening.md
      27-user-acceptance-testing-preparation.md
      28-system-deployment-handoff.md
      INDEX.md
  features/ (5 files)
    / (5 files)
      smart-reference-library/ (4 files)
        / (4 files)
          execution/ (1 files)
            / (1 files)
              INDEX.md
          prp.md
          STATUS.md
          task-plan.md
      INDEX.md
  reviews/ (1 files)
    / (1 files)
      INDEX.md
  templates/ (6 files)
    / (6 files)
      prp/ (5 files)
        / (5 files)
          prp-ai-agent.md
          prp-api-endpoint.md
          prp-base.md
          prp-frontend-component.md
          prp-mcp-integration.md
      INDEX.md
  testing/ (1 files)
    / (1 files)
      INDEX.md
  .gitignore
  CLAUDE.md
  INDEX.md
  LICENSE
  MVP.md
  PRD.md
  README.md
  TECH-SPEC.md
```

## Files

### .claude\\commands\\check.md
`$(@{Path=.claude\\commands\\check.md; Language=markdown; Lines=System.Object[]}.Language)
---
name: Check
description: "Comprehensive codebase health check, cleanup, and documentation updates"
phase: independent
dependencies: []
outputs:
  - description: "Health report with issues found and fixes applied"
inputs: []
---

# Check Command

## Purpose

Perform comprehensive codebase health check, automatically fix issues, update outdated documentation, and clean up artifacts. This ensures the repository remains clean, consistent, and up-to-date.

## Execution Steps

### Step 1: Health Check Scan

Run systematic checks across the codebase:

**1.1 Check for required files:**
- `.gitignore` - Should exist with standard patterns
- `LICENSE` - Should exist (usually MIT)
- `README.md` - Should exist with project documentation
- `CLAUDE.md` - Should exist with developer guidelines
- `INDEX.md` - Should exist in root and subdirectories

**1.2 Check for artifact files:**
- `nul` - Windows artifact (45 bytes typically)
- `.DS_Store` - macOS artifact
- `Thumbs.db` - Windows thumbnail cache
- `*.tmp`, `*.temp` - Temporary files
- Files matching patterns in `.gitignore` that were accidentally committed

**1.3 Check documentation consistency:**
- Root `INDEX.md` - Should list all commands
- `features/INDEX.md` - Should reflect current feature statuses
- `context/INDEX.md` - Should list all prime exports
- `discovery/INDEX.md` - Should list all discovery documents
- `execution/INDEX.md` - Should list all execution tasks

**1.4 Check for outdated status references:**
- Feature STATUS.md files - Should match actual completion state
- Compare features/INDEX.md status with feature/STATUS.md
- Check for "Ready for X" phases that are actually complete

**1.5 Check command file integrity:**
- All commands in `.claude/commands/` should have proper YAML frontmatter
- All commands listed in INDEX.md should exist
- No orphaned or missing command files

**1.6 Check template files:**
- PRP templates should exist in `templates/prp/`
- STATUS.md template should exist in `.claude/templates/`

### Step 2: Automated Fixes

Apply fixes for common issues:

**2.1 Create missing .gitignore:**
```bash
# Create with standard patterns for Node, Python, IDE, OS, Claude
```

**2.2 Create missing LICENSE:**
```bash
# Create MIT License file (default, or ask user for preference)
```

**2.3 Delete artifact files:**
```bash
# Remove nul, .DS_Store, Thumbs.db, *.tmp, *.temp
```

**2.4 Update outdated INDEX.md entries:**
- Update feature statuses to match actual completion
- Update last updated dates
- Add missing commands to command tables
- Add completed features to status sections

**2.5 update .claude/settings.local.json permissions:**
- Add permissions for commonly used git commands
- Add permissions for Archon MCP tools used in project

### Step 3: Generate Health Report

Create comprehensive report showing:

```markdown
# Codebase Health Report

**Date**: {timestamp}
**Branch**: {current-branch}
**Commit**: {latest-commit-hash}

## Summary

- **Issues Found**: {count}
- **Issues Fixed**: {count}
- **Issues Requiring Manual Action**: {count}

## Issues Fixed

### Missing Files Created
- {file} - {reason}

### Artifacts Removed
- {file} - {size} - {reason}

### Documentation Updated
- {file} - {changes made}

## Issues Requiring Manual Action

### {issue-description}
- **File**: {file}
- **Problem**: {description}
- **Suggested Fix**: {recommendation}

## Health Score

- **Required Files**: {X}/{Y} present
- **Documentation**: {X}/{Y} up-to-date
- **Artifacts**: {X} found and cleaned
- **Overall**: {percentage}%

## Recommendations

1. {actionable recommendation}
2. {actionable recommendation}
```

### Step 4: Confirm Changes

Before committing, present summary to user:

```
Found {count} issues:
- {count} missing files (created)
- {count} artifact files (deleted)
- {count} outdated documentation (updated)
- {count} issues requiring manual review

Changes staged. Review above or run 'git diff' to see details.
```

**Ask user**: "Commit these changes? (y/n)"

### Step 5: Commit (If Approved)

If user approves, create commit with descriptive message:

```bash
git add .
git commit -m "Codebase health check and cleanup

- {summary of changes}

Health Score: {percentage}%
Co-Authored-By: Claude <noreply@anthropic.com>"
```

## Check Items Reference

### Required Files

| File | Purpose | Template |
|------|---------|----------|
| `.gitignore` | Git ignore patterns | Standard template |
| `LICENSE` | License file | MIT (default) |
| `README.md` | Project documentation | Should exist |
| `CLAUDE.md` | Developer guidelines | Should exist |
| `INDEX.md` | Root navigation | Should exist |

### Artifact Patterns

| Pattern | Description | Action |
|---------|-------------|--------|
| `nul` | Windows artifact (45 bytes) | Delete |
| `.DS_Store` | macOS artifact | Delete |
| `Thumbs.db` | Windows thumbnail cache | Delete |
| `*.tmp` | Temporary files | Delete |
| `*.temp` | Temporary files | Delete |

### Documentation Sync Points

| File | Syncs With | Check Method |
|------|------------|--------------|
| `INDEX.md` | Command files | Commands in table exist in .claude/commands/ |
| `features/INDEX.md` | Feature STATUS.md | Statuses match actual phase |
| `context/INDEX.md` | Context exports | All prime-*.md files listed |
| `discovery/INDEX.md` | Discovery docs | All discovery-*.md files listed |

### Status Values (by phase)

| Phase | Status Value |
|-------|--------------|
| Discovery | "Discovery - Completed" |
| MVP | "MVP - Completed" |
| Planning | "Planning (PRD) - Completed" |
| Development | "Development (TECH-SPEC) - Completed" |
| Task Planning | "Task Planning - Completed" |
| Execution | "Execution - Completed" |
| Review | "Review - Completed" or "Review - In Progress" |
| Test | "Test - Completed" or "Test - In Progress" |

## Error Handling

**If .gitignore has issues:**
- Preserve existing entries
- Add missing standard patterns
- Don't remove user-specific entries

**If LICENSE exists but different:**
- Don't overwrite (user may have chosen different license)
- Note in report that license exists

**If manual review needed:**
- Clearly flag in report
- Provide specific recommendations
- Don't auto-fix, ask user

**If git has uncommitted changes:**
- Warn user before making changes
- Ask if they want to proceed or stash changes

## Notes

- Always ask before committing changes
- Preserve user preferences and configurations
- Don't modify code files, only documentation and meta-files
- Run checks before committing to ensure clean state
- Report issues clearly even if auto-fixed
```

### .claude\\commands\\development.md
`$(@{Path=.claude\\commands\\development.md; Language=markdown; Lines=System.Object[]}.Language)
---
name: Development
description: "Analyze PRD requirements and generate comprehensive Tech Spec with technology stack recommendations"
phase: development
dependencies: [planning]
outputs:
  - path: "TECH-SPEC.md"
    description: "Technical Specification at root with system architecture, technology stack, implementation details, and recommendations"
inputs:
  - path: "PRD.md"
    description: "Product Requirements Document at root"
    required: true
  - path: "MVP.md"
    description: "MVP definition at root"
    required: true
---

# Development Command

## Purpose

Analyze PRD requirements and generate a comprehensive Tech Spec (Technical Specification). This command loads the PRD, uses RAG knowledge base and web MCP servers to research architecture patterns and tech stacks, recommends technology stack (backend, frontend, MCP servers, AI frameworks, models, agent architecture), and generates detailed tech spec with system architecture, technology stack, command structure, file system structure, data models, MCP integration, command implementation, error handling, performance, and security.

**When to use**: Use this command after Planning phase, when you have a PRD and need technical specifications to guide implementation.

**What it solves**: This command addresses the need to translate requirements into technical blueprints with architecture and technology recommendations.

## Prerequisites

- Planning command must have been run (PRD must exist at `features/{feature-name}/prd.md`)
- Archon MCP server should be available (for RAG knowledge base)
- Web MCP servers should be available (for web research)

## Execution Steps

### Step 1: Load PRD

**Objective**: Load the PRD document for analysis.

**Actions**:
1. Load `features/{feature-name}/prd.md`
2. Parse: Overview, User Personas, User Stories, Features, Technical Requirements, Dependencies, Risks
3. Extract: Technical needs, integration needs, data needs

**Expected Result**: PRD loaded and technical requirements extracted.

### Step 2: Research Architecture Patterns (RAG)

**Objective**: Find relevant architecture patterns.

**Actions**:
1. Search RAG: `rag_search_knowledge_base(query="architecture patterns", match_count=5)`
2. Search code examples: `rag_search_code_examples(query="tech stack", match_count=3)`
3. Read full pages: `rag_read_full_page(page_id="{page_id}")`
4. Extract: Architecture patterns, design patterns, best practices

**Expected Result**: Architecture patterns gathered.

### Step 3: Research Technology Stacks (Web)

**Objective**: Research tech stack options.

**Actions**:
1. Search web: `web_search_prime_search(query="tech stack recommendations AI agents")`
2. Read docs: `web_reader_read(url="{url}")` or `zread_read(url="{url}")`
3. Extract: Tech stack recommendations, framework comparisons

**Expected Result**: Tech stack research completed.

### Step 4: Recommend Technology Stack

**Objective**: Analyze requirements and recommend stack.

**Actions**:
1. Analyze backend needs (if any), recommend framework/database/API
2. Analyze frontend needs (if any), recommend framework/UI library
3. Analyze MCP server needs, recommend required/optional MCP servers
4. Analyze AI needs, recommend frameworks/models/architecture
5. Query AI for structured recommendations based on PRD + research

**Expected Result**: Technology stack recommendations generated.

### Step 5: Generate Tech Spec Content

**Objective**: Generate comprehensive tech spec.

**Actions**:
1. Structure sections: System Architecture, Technology Stack, Command Structure, File System Structure, Data Models, MCP Integration, Command Implementation, Error Handling, Performance, Security
2. Generate content for each section based on PRD + research + recommendations
3. Format as markdown with proper structure

**Expected Result**: Complete tech spec generated.

### Step 6: Save Tech Spec and Update Status

**Objective**: Save tech spec and update tracking.

**Actions**:
1. Save to `features/{feature-name}/tech-spec.md`
2. Update STATUS.md: add tech-spec.md artifact, mark Development complete, set current to Task Planning

**Expected Result**: Tech spec saved, status updated.

## Output Format

**File**: `TECH-SPEC.md` (at root)

**Structure**:
```markdown
# Technical Specification: {feature-name}

**Version**: 1.0 | **Last Updated**: {timestamp}

## System Architecture
{Architecture description with principles and diagram}

## Technology Stack
- **Claude Code**: {description}
- **Markdown**: {description}
- **YAML Frontmatter**: {description}
- **MCP**: {description}

### MCP Servers
**Required**: {list}
**Optional**: {list}

## Command Structure
{YAML frontmatter and markdown sections documentation}

## File System Structure
{Directory layout and naming conventions}

## Data Models
{STATUS.md, INDEX.md, PRP format documentation}

## MCP Integration
{Archon MCP and Web MCP tools documentation}

## Command Implementation
{Detailed steps for each command}

## Error Handling
{Error types, strategy, recovery}

## Performance
{Optimization and targets}

## Security
{Security measures}
```

## Error Handling

### PRD Not Found
- Error: "PRD not found. Run /planning command first."

### Invalid PRD Format
- Attempt to parse available sections
- Generate tech spec with available information
- Log warnings for missing sections

### Tech Spec Generation Fails
- Retry with shorter context
- Use template with PRD content
- Generate partial tech spec

## MCP Tool Reference

| Tool | Purpose | Query |
|------|---------|-------|
| `rag_search_knowledge_base()` | Architecture patterns | "architecture patterns" |
| `rag_search_code_examples()` | Tech stack examples | "tech stack" |
| `web_search_prime_search()` | Stack recommendations | "tech stack recommendations AI agents" |
| `web_reader_read()` | Read documentation | URL from search |
| `zread_read()` | Advanced reading | URL from search |

## Examples

**Command**: `/development ai-coding-workflow-system`

**Output**:
- Loads PRD
- Researches architecture patterns and tech stacks
- Generates tech spec with system architecture, technology stack, MCP integration
- Saves to `features/ai-coding-workflow-system/tech-spec.md`

## Notes

- Tech spec translates requirements into technical blueprints
- Architecture patterns should align with PRD requirements
- Technology recommendations should be justified based on needs
- MCP integration should be documented clearly
- Error handling and performance considered from start
- Security measures documented

## Validation

After Development command:
- [ ] Tech spec file created
- [ ] All sections present
- [ ] Architecture documented
- [ ] Technology stack recommended with justification
- [ ] MCP integration documented
- [ ] Error handling documented
- [ ] STATUS.md updated with Development completed
```

### .claude\\commands\\discovery.md
`$(@{Path=.claude\\commands\\discovery.md; Language=markdown; Lines=System.Object[]}.Language)
---
name: Discovery
description: "Explore ideas, inspiration, and needs for AI agents and AI/ATR applications"
phase: discovery
dependencies: [prime]
outputs:
  - path: "discovery/discovery-{timestamp}.md"
    description: "Discovery document with ideas, inspiration sources, needs analysis, and opportunities"
  - path: "discovery/INDEX.md"
    description: "Updated index of all discovery documents"
inputs:
  - path: "context/prime-{timestamp}.md"
    description: "Most recent codebase export from Prime command"
    required: true
---

# Discovery Command

## Purpose

Explore ideas, inspiration, and needs for AI agents and AI/ATR applications. This command loads the prime context, queries AI via MCP (using RAG knowledge base and web MCP servers), performs needs analysis, and generates a discovery document.

## Execution Steps

### Step 1: Load Prime Context

Find most recent codebase export for analysis:

1. **Find most recent prime export**:
   - List files in `context/` directory matching pattern `prime-*.md`
   - Sort by filename (which includes timestamp)
   - Select most recent (last in sorted list)
   - If no prime exports exist, error: "No prime export found. Run /prime command first."

2. **Load prime export file**:
   - Read file contents
   - Parse markdown structure
   - Extract: Project tree, file contents, index statistics
   - Store in memory for AI queries

3. **Extract key information**:
   - Project structure and organization
   - Technology stack (from dependencies in index)
   - File patterns and conventions
   - Codebase scale (file count, line count)

**Expected Result**: Prime context loaded and ready for analysis.

### Step 2: Query AI for Ideas

Use RAG knowledge base to find relevant patterns and examples:

1. **Get available knowledge sources**:
   - Call `rag_get_available_sources()`
   - Parse response: List of sources with id, title, url
   - Store source IDs for filtering

2. **Search knowledge base for patterns**:
   - Call `rag_search_knowledge_base(query="ai agent patterns", match_count=5, return_mode="pages")`
     - Keep query SHORT (2-5 keywords) per CLAUDE.md rules
     - Use `return_mode="pages"` for better context
   - Parse results: Pages with content and metadata
   - Extract relevant patterns and best practices

3. **Search for code examples**:
   - Call `rag_search_code_examples(query="ai agent", match_count=3)`
     - Keep query SHORT and FOCUSED
   - Parse results: Code examples with content and summaries
   - Extract implementation patterns

4. **Query AI with combined context**:
   - Combine: Prime context + RAG search results
   - Prompt AI: "Based on this codebase context and knowledge base patterns, identify opportunities for AI agents and AI/ATR applications. Consider: [specific aspects]"
   - Extract structured ideas from AI response

**Expected Result**: List of ideas for AI agents and features based on codebase and knowledge base.

### Step 3: Explore Inspiration Sources

Use web MCP servers to find external inspiration and best practices:

1. **Search for inspiration sources**:
   - Call `web_search_prime_search(query="AI agent patterns best practices", max_results=5)`
     - Search for: AI agent architectures, implementation patterns, best practices
   - Parse results: URLs and snippets
   - Select most relevant URLs

2. **Read relevant pages**:
   - For each relevant URL:
     - Call `web_reader_read(url="{url}")` or `zread_read(url="{url}")`
     - Parse extracted content
     - Extract key insights and patterns
   - Store inspiration sources with URLs and summaries

3. **Read full pages from knowledge base**:
   - For relevant pages from RAG search:
     - Call `rag_read_full_page(page_id="{page_id}")` or `rag_read_full_page(url="{url}")`
     - Get complete page content
     - Extract detailed patterns and examples

4. **Combine inspiration sources**:
   - Merge: Web search results + Knowledge base pages
   - Organize by: Source type (documentation, examples, best practices)
   - Extract: URLs, key insights, relevant patterns

**Expected Result**: List of inspiration sources with URLs, summaries, and key insights.

### Step 4: Needs Analysis

Analyze codebase needs and identify gaps and opportunities:

1. **Prepare combined context**:
   - Prime context (codebase structure and contents)
   - RAG knowledge base results (patterns and examples)
   - Web research results (inspiration sources)
   - Knowledge base code examples

2. **Query AI for needs analysis**:
   - Prompt: "Analyze this codebase and identify needs and opportunities for AI agents and AI/ATR applications. Consider: current patterns, gaps, improvement opportunities"
   - Extract structured needs analysis

3. **Prioritize opportunities**:
   - Sort by: Impact, feasibility, alignment with goals
   - Categorize: High, Medium, Low priority
   - Identify: Quick wins vs. strategic initiatives

**Expected Result**: Prioritized list of opportunities with analysis.

### Step 5: Generate Discovery Document

Compile all findings into discovery document:

1. **Create document structure**:
   ```markdown
   # Discovery: {timestamp}

   ## Codebase Overview
   {Summary of codebase structure, technology stack, patterns}

   ## Ideas for AI Agents
   {List of ideas from AI queries, prioritized}

   ## Inspiration Sources
   {List of external sources with URLs and summaries}

   ## Needs Analysis
   {Analysis of codebase needs and gaps}

   ## Opportunities
   {Prioritized list of opportunities with impact and feasibility}

   ## Next Steps
   {Recommended next steps for development}
   ```

2. **Populate content**:
   - Fill in: Codebase overview from Step 1
   - Fill in: Ideas from Step 2
   - Fill in: Inspiration sources from Step 3
   - Fill in: Needs analysis from Step 4
   - Fill in: Opportunities prioritized list

3. **Generate timestamp**:
   - Use ISO 8601 format: YYYY-MM-DDTHH:mm:ssZ
   - Include in filename and document

4. **Save document**:
   - Save to `discovery/discovery-{timestamp}.md`
   - Update `discovery/INDEX.md` with new entry:
     - Link to discovery document
     - Timestamp
     - Summary of ideas and opportunities

## Output Format

```markdown
# Discovery: {timestamp}

## Codebase Overview

### Project Structure
{Brief description of project structure and organization}

### Technology Stack
{List of technologies detected from prime export}

### Patterns and Conventions
{Key patterns and naming conventions observed}

## Ideas for AI Agents

### High Priority
{List of high-priority ideas}

### Medium Priority
{List of medium-priority ideas}

### Low Priority
{List of low-priority ideas}

## Inspiration Sources

### Documentation
{Links to documentation sources with summaries}

### Examples
{Links to example implementations with summaries}

### Best Practices
{Links to best practice resources with summaries}

## Needs Analysis

### Current Gaps
{Analysis of missing features or capabilities}

### Improvement Opportunities
{Areas for improvement in existing codebase}

### Emerging Opportunities
{New opportunities based on trends and patterns}

## Opportunities

| Opportunity | Impact | Feasibility | Priority | Effort Estimate |
|------------|---------|-------------|----------|------------------|
| {Name} | {High/Med/Low} | {High/Med/Low} | {High/Med/Low} | {Time} |

## Next Steps
{Recommended next steps for development}

## Timestamp
{ISO 8601 timestamp}
```

## Error Handling

- **No Prime Export Found**: Check `context/` directory, list available exports, suggest running `/prime`
- **MCP Server Unavailable**: Use Claude's built-in web search, inform user of limitations
- **Knowledge Base Empty**: Proceed with web search only, document limitation
- **Web Search Fails**: Log error, continue with available context
- **Document Generation Fails**: Log error, suggest manual creation

## Notes

- Discovery documents help explore ideas before committing to specific features
- Use RAG knowledge base first for patterns, web search for external sources
- Combine multiple sources for comprehensive analysis
- Prioritize opportunities by impact and feasibility
- Discovery document feeds into Planning command
```

### .claude\\commands\\execution.md
`$(@{Path=.claude\\commands\\execution.md; Language=markdown; Lines=System.Object[]}.Language)
---
name: Execution
description: "Execute tasks step-by-step following task plan and PRP guidance"
phase: execution
dependencies: [task-planning]
outputs:
  - path: "features/{feature-name}/execution.md"
    description: "Execution log showing progress through tasks"
  - path: "features/{feature-name}/STATUS.md"
    description: "Updated status showing execution progress"
inputs:
  - path: "features/{feature-name}/task-plan.md"
    description: "Task plan with ordered tasks and dependencies"
    required: true
  - path: "features/{feature-name}/prp.md"
    description: "PRP document with implementation guidance"
    required: true
  - path: "features/{feature-name}/execution/"
    description: "Execution folder with individual task files"
    required: true
---

# Execution Command

## Purpose

Execute tasks step-by-step following the task plan and PRP guidance. This command loads the task plan and PRP, executes tasks sequentially using Archon MCP for tracking, handles errors with checkpoint/resume, and updates STATUS.md with progress.

## Execution Steps

### Step 1: Load Task Plan and PRP

Load execution artifacts:

1. **Load task plan**:
   - Read `features/{feature-name}/task-plan.md`
   - Parse task list with dependencies
   - Extract task order and priorities

2. **Load PRP document**:
   - Read `features/{feature-name}/prp.md`
   - Parse implementation blueprint
   - Extract codebase patterns and validation commands

3. **Verify Archon MCP availability**:
   - Call `health_check()` to verify server is available
   - If unavailable, stop and inform user

**Expected Result**: Task plan and PRP loaded, Archon MCP verified.

### Step 2: Initialize Execution

Set up execution environment:

1. **Create execution log file**:
   - Create `features/{feature-name}/execution.md`
   - Add header with timestamp
   - Initialize task progress tracking

2. **Update STATUS.md**:
   - Mark current phase as "Execution - In Progress"
   - List all tasks as "Pending"

3. **Create checkpoint directory** (if needed):
   - Create `features/{feature-name}/checkpoints/` directory
   - For saving state between tasks

**Expected Result**: Execution environment initialized, STATUS.md updated.

### Step 3: Execute Tasks Sequentially

Execute each task following dependencies:

1. **For each task in task plan**:
   - Check task dependencies are complete
   - Read task file from `execution/{order}-{task-slug}.md`
   - Mark task as "Doing" in Archon: `manage_task("update", task_id="...", status="doing")`
   - Load task context from PRP
   - Execute task following PRP Implementation Blueprint and task file steps

2. **Task Execution**:
   - Read PRP section for current task
   - Follow step-by-step instructions from task file
   - Create/modify files as specified
   - Run validation commands if specified

3. **Update Progress**:
   - Log task completion in `execution.md`
   - Mark task as "Done" in Archon: `manage_task("update", task_id="...", status="done")`
   - **Delete the task file** from `execution/` folder
   - Update STATUS.md with progress
   - Update `execution/INDEX.md` to reflect completion

4. **Checkpoint State**:
   - Save checkpoint after each task completes
   - Store current state for resume capability

**Task File Cleanup**:
- When task completes successfully, delete `execution/{order}-{task-slug}.md`
- When all task files are deleted (only INDEX.md remains), feature is complete

**Expected Result**: Tasks executed sequentially, progress tracked in Archon and STATUS.md.

### Step 4: Handle Errors

Implement comprehensive error handling:

1. **Task Execution Errors**:
   - Log error details in `execution.md`
   - Stop execution on critical errors
   - Allow manual recovery on non-critical errors
   - Provide error context and suggested fixes

2. **Checkpoint on Error**:
   - Save checkpoint before failing
   - Record error state
   - Enable resume from before failing task

3. **Error Recovery**:
   - Analyze error type (syntax, runtime, logic)
   - Suggest recovery action (fix, skip, retry)
   - Ask user for decision on blocking errors

**Expected Result**: Errors handled gracefully, checkpoints saved, recovery enabled.

### Step 5: Complete Execution

Finalize execution:

1. **Verify All Tasks Complete**:
   - Check all tasks marked as "Done" or "Review"
   - Run final validation if specified in PRP
   - Review execution log

2. **Update STATUS.md**:
   - Mark phase as "Execution - Completed"
   - Update artifact list
   - Add timestamp

3. **Generate Summary**:
   - Count completed tasks
   - Count failed tasks
   - Calculate execution time
   - Note any skipped tasks

**Expected Result**: Execution complete, STATUS.md updated, summary generated.

## Output Format

```markdown
# Execution Log: {feature-name}

**Started**: {timestamp}
**Completed**: {timestamp}
**Duration**: {duration}

## Task Progress

### Task 1: {task-name}
- **Status**: {Pending/Doing/Review/Done}
- **Started**: {timestamp}
- **Completed**: {timestamp}
- **Result**: {Success/Failure}
- **Notes**: {Any notes or issues}

### Task 2: {task-name}
... (repeat for all tasks)

## Summary
- **Total Tasks**: {count}
- **Completed**: {count}
- **Failed**: {count}
- **Skipped**: {count}
- **Duration**: {duration}

## Checkpoints
- Last checkpoint: {timestamp}
- Resume capability: {Available/Not available}
```

## Error Handling

- **Task Plan Not Found**: Check `features/{feature-name}/` directory, suggest running Task Planning first
- **PRP Not Found**: Check `features/{feature-name}/` directory, suggest running Task Planning first
- **Archon MCP Unavailable**: Stop execution, inform user, wait for availability (per ARCHON-FIRST RULE)
- **Task Execution Fails**: Log error, checkpoint state, suggest recovery
- **Validation Fails**: Log validation errors, suggest fixes, ask user

## Checkpoint & Resume

### Checkpoint Format
Save state after each task:
```json
{
  "last_completed_task": "task-id",
  "current_phase": "execution",
  "timestamp": "ISO8601-timestamp",
  "files_created": ["file1", "file2"],
  "files_modified": ["file3"]
}
```

### Resume Process
1. Load checkpoint file
2. Verify state is valid
3. Resume from next pending task
4. Continue execution

## Validation

Run validation as specified in PRP:
- Syntax validation: Run lint/format commands
- Unit tests: Run test suite if specified
- Integration tests: Run integration tests if specified
- Manual review: Prompt user for review if validation succeeds

## Notes

- Always use Archon MCP for task tracking (ARCHON-FIRST RULE)
- Never use TodoWrite fallback
- Update STATUS.md after each phase
- Checkpointing enables resume after interruptions
- Follow PRP Implementation Blueprint for each task
- Run PRP Validation Loop after task completion
- **Delete task files** from `execution/` folder after completion
- When all task files deleted, feature is complete
- Tasks exist in both Archon (source of truth) AND execution folder (local visibility)
```

### .claude\\commands\\learn.md
`$(@{Path=.claude\\commands\\learn.md; Language=markdown; Lines=System.Object[]}.Language)
---
name: Learn
description: "Search, digest, and save coding insights to reference library"
phase: independent
dependencies: []
outputs:
  - description: "Digested insight stored in archon_references table"
inputs:
  - name: topic
    description: "Topic to learn (e.g., 'python async', 'react hooks', 'mcp server patterns')"
    required: true
---

# Learn Command

## Purpose

Search Archon RAG and web for a coding topic, digest findings into concise actionable insights, and store approved insights to the `archon_references` table in Supabase.

This command builds a token-efficient reference library by storing digested knowledge (not raw dumps) organized by category for selective context loading during future tasks.

**When to use**: Use this command when you want to save useful coding patterns, best practices, or technical insights for future reference.

**What it solves**: This command addresses the problem of loading irrelevant context. By storing digested insights and enabling selective loading by category, only relevant references load during future tasks.

## Prerequisites

- Archon MCP server available (for RAG search)
- Supabase `archon_references` table exists (Migration 012)
- Archon RAG knowledge base configured

## Execution Steps

### Step 1: Parse Topic and Infer Category

**Objective**: Extract keywords and determine the reference category.

**Actions**:
1. Parse the `topic` input parameter
2. Extract key technology keywords (python, react, mcp, typescript, etc.)
3. Infer category from keywords using mapping:
   - "python", "asyncio", "fastapi", "django" â†’ `python`
   - "react", "next", "hooks", "components" â†’ `react`
   - "mcp", "model context" â†’ `mcp`
   - "typescript", "ts" â†’ `typescript`
   - "agent", "ai", "llm", "prompt" â†’ `ai-agents`
   - "test", "jest", "pytest", "vitest" â†’ `testing`
   - "supabase", "postgres", "sql" â†’ `supabase`
   - "api", "rest", "graphql" â†’ `api`
   - If no match â†’ `patterns` (general design patterns)
4. Generate additional tags from topic keywords

**Expected Result**: Category determined and tags extracted.

### Step 2: Search Archon RAG Knowledge Base

**Objective**: Find relevant insights in the knowledge base.

**Actions**:
1. Call `rag_search_knowledge_base()`
   - **Query**: 2-5 keywords from topic (keep SHORT!)
   - **match_count**: 5
   - **return_mode**: "pages"
2. Parse results for relevant pages
3. Extract full content using `rag_read_full_page()` for promising results

**Expected Result**: List of relevant knowledge base pages with content.

### Step 3: Search Web (Optional Fallback)

**Objective**: Find external resources if RAG results insufficient.

**Actions**:
1. If RAG returns < 3 results or low relevance:
   - Call WebSearch or `web_search_prime_search()`
   - Use same 2-5 keyword query
2. Parse search results for relevant URLs
3. Use `web_reader_read()` to extract content from promising URLs

**Expected Result**: Additional insights from web resources (if needed).

### Step 4: Digest Findings into Insights

**Objective**: Process raw content into concise, actionable insights.

**Actions**:
1. Combine all sources (RAG + web)
2. Prompt LLM to digest into structured format:
   ```json
   {
     "summary": "1-2 sentence overview",
     "insights": [
       "Actionable insight 1",
       "Actionable insight 2",
       "Actionable insight 3"
     ],
     "code_examples": [
       {
         "title": "Example name",
         "language": "python|javascript|typescript|sql",
         "code": "concise code snippet"
       }
     ],
     "sources": ["url1", "url2"],
     "learned_at": "ISO-8601-timestamp"
   }
   ```
3. Keep insights concise (3-5 bullet points max)
4. Include only relevant code examples (2-3 max)

**Expected Result**: Structured digest ready for review.

### Step 5: Present for Approval

**Objective**: Get user confirmation before storing.

**Actions**:
1. Present digest in readable format:
   ```
   ## Found insights for: {topic}

   **Category**: {category}
   **Tags**: {tags}

   ### Summary
   {summary}

   ### Key Insights
   - {insight 1}
   - {insight 2}
   - {insight 3}

   ### Code Examples
   {code examples}

   ### Sources
   - {source 1}
   - {source 2}

   ---
   Save to reference library? (y/n)
   ```
2. Wait for user confirmation

**Expected Result**: User approves or rejects the digest.

### Step 6: Store to Supabase

**Objective**: Insert approved insight into `archon_references` table.

**Actions**:
1. Generate INSERT query (direct SQL via Supabase):
   ```sql
   INSERT INTO archon_references (title, category, tags, content, source_url)
   VALUES (
     '{title}',
     '{category}',
     ARRAY[{tags}],
     '{content_jsonb}'::jsonb,
     '{primary_source_url}'
   );
   ```
2. Execute via Supabase client (not Archon MCP)
3. Confirm successful insert

**Expected Result**: Reference stored in database.

## Output Format

The command stores a reference record in the `archon_references` table:

**Table**: `archon_references`

**Record Structure**:
```sql
{
  id: UUID (auto-generated),
  title: TEXT (topic + descriptive suffix),
  category: TEXT (python|mcp|react|typescript|ai-agents|testing|patterns|supabase|api),
  tags: TEXT[] (additional keyword tags),
  content: JSONB {
    summary: string,
    insights: string[],
    code_examples: object[],
    sources: string[],
    learned_at: timestamp
  },
  source_url: TEXT (primary source),
  author: TEXT ('AI Coding System'),
  created_at: TIMESTAMPTZ,
  updated_at: TIMESTAMPTZ
}
```

**Example Content**:
```json
{
  "summary": "Python async/await patterns for concurrent I/O operations",
  "insights": [
    "Use asyncio.gather() to run multiple coroutines concurrently",
    "Always use async/await consistently - don't mix sync and async code",
    "Use asyncio.create_task() for fire-and-forget operations"
  ],
  "code_examples": [
    {
      "title": "Concurrent HTTP requests",
      "language": "python",
      "code": "async def fetch_all(urls):\n    async with aiohttp.ClientSession() as session:\n        tasks = [fetch_url(session, url) for url in urls]\n        return await asyncio.gather(*tasks)"
    }
  ],
  "sources": ["https://docs.python.org/3/library/asyncio.html"],
  "learned_at": "2026-01-24T20:00:00Z"
}
```

## Error Handling

### RAG Search Fails

- **Cause**: Archon MCP unavailable or knowledge base empty
- **Detection**: `rag_search_knowledge_base()` returns error
- **Recovery**: Fall back to web search only, inform user of limitation

### Web Search Fails

- **Cause**: No internet or web MCP unavailable
- **Detection**: WebSearch returns error
- **Recovery**: Proceed with RAG results only, warn if insufficient

### Supabase Insert Fails

- **Cause**: Table doesn't exist or permission denied
- **Detection**: SQL insert fails
- **Recovery**: Inform user to run migration SQL, offer retry

### No Results Found

- **Cause**: Topic too obscure or not in knowledge base
- **Detection**: Zero results from RAG + web search
- **Recovery**: Suggest different topic keywords, offer to search again

## Examples

### Example 1: Learn Python Async Patterns

**Command**: `/learn python async patterns`

**Execution**:
1. Parse: topic="python async patterns" â†’ category="python", tags=["python", "async"]
2. RAG search: `rag_search_knowledge_base(query="python async", match_count=5)`
3. Digest findings into insights
4. Present for approval
5. Store on approval

**Output**:
```
## Found insights for: python async patterns

**Category**: python
**Tags**: python, async, patterns

### Summary
Python async/await patterns for concurrent I/O operations.

### Key Insights
- Use asyncio.gather() to run multiple coroutines concurrently
- Always use async/await consistently - don't mix sync and async code
- Use asyncio.create_task() for fire-and-forget operations

### Code Examples
```python
async def fetch_all(urls):
    async with aiohttp.ClientSession() as session:
        tasks = [fetch_url(session, url) for url in urls]
        return await asyncio.gather(*tasks)
```

### Sources
- https://docs.python.org/3/library/asyncio.html

---
âœ… Saved to reference library! (ID: abc-123)
```

### Example 2: Learn React Hooks

**Command**: `/learn react hooks`

**Execution**:
1. Parse: topic="react hooks" â†’ category="react", tags=["react", "hooks"]
2. RAG search: `rag_search_knowledge_base(query="react hooks", match_count=5)`
3. Digest and present
4. Store on approval

**Output**: Similar format with React-specific insights and examples.

## Notes

- **Keep queries SHORT**: 2-5 keywords max for RAG searches
- **Quality over quantity**: Store only valuable, actionable insights
- **User approval required**: Always present before storing
- **Token efficiency**: Store digested insights, not full articles
- **Source attribution**: Always track original source URLs

## Validation

After executing this command:
- [ ] Topic parsed and category inferred correctly
- [ ] RAG search executed successfully
- [ ] Findings digested into structured JSONB
- [ ] Digest presented for approval
- [ ] User confirmed approval
- [ ] Insert into `archon_references` successful
- [ ] Record can be queried back

## Integration with Other Commands

- **`/learn-health`**: Shows stats including references created by `/learn`
- **PRP templates**: Can specify required categories (e.g., "Load references with tags: ['python', 'mcp']")
- **CLAUDE.md**: Documents reference library usage
```

### .claude\\commands\\learn-health.md
`$(@{Path=.claude\\commands\\learn-health.md; Language=markdown; Lines=System.Object[]}.Language)
---
name: Learn Health
description: "Check reference library health and display statistics"
phase: independent
dependencies: []
outputs:
  - description: "Health report displayed to user"
inputs: []
---

# Learn Health Command

## Purpose

Query the `archon_references` table for statistics, calculate library health percentage, identify empty categories, and generate suggestions for what to learn next.

This command provides a quick overview of the reference library's growth and coverage without running a full `/learn` command.

**When to use**: Use this command to check which categories need attention, track library growth, or get suggestions for what to learn next.

**What it solves**: This command addresses the need to quickly assess library health and identify gaps without loading full reference content.

## Prerequisites

- Supabase `archon_references` table exists (Migration 012)
- Direct SQL access to Supabase

## Execution Steps

### Step 1: Query Statistics

**Objective**: Get reference counts per category from database.

**Actions**:
1. Execute SQL query (direct Supabase access):
   ```sql
   SELECT
     category,
     COUNT(*) as count,
     MAX(updated_at) as last_updated
   FROM archon_references
   GROUP BY category
   ORDER BY category;
   ```
2. Parse results into category stats object

**Expected Result**: List of categories with reference counts and last updated timestamps.

### Step 2: Get Total Count

**Objective**: Get total reference count across all categories.

**Actions**:
1. Execute SQL query:
   ```sql
   SELECT COUNT(*) as total FROM archon_references;
   ```

**Expected Result**: Total reference count.

### Step 3: Calculate Health

**Objective**: Determine overall library health percentage.

**Actions**:
1. Define standard categories:
   - `python`
   - `mcp`
   - `react`
   - `typescript`
   - `ai-agents`
   - `testing`
   - `patterns`
   - `supabase`
   - `api`
2. Count non-empty categories from stats
3. Calculate health percentage:
   - `health = (non_empty_categories / total_categories) * 100`
4. Determine health status:
   - 80-100%: "Excellent"
   - 60-79%: "Good"
   - 40-59%: "Fair"
   - 20-39%: "Poor"
   - 0-19%: "Critical"

**Expected Result**: Health percentage and status label.

### Step 4: Identify Empty Categories

**Objective**: Find categories with no references.

**Actions**:
1. Compare standard categories against stats
2. List categories with count = 0 or not present in stats

**Expected Result**: List of empty categories.

### Step 5: Generate Suggestions

**Objective**: Suggest topics to learn based on gaps.

**Actions**:
1. For each empty category, generate suggested learning topics:
   - `python` â†’ "Learn Python async patterns", "Learn FastAPI basics"
   - `mcp` â†’ "Learn MCP server patterns", "Learn MCP tool development"
   - `react` â†’ "Learn React hooks", "Learn Next.js routing"
   - `typescript` â†’ "Learn TypeScript types", "Learn TS generics"
   - `ai-agents` â†’ "Learn AI agent patterns", "Learn prompt engineering"
   - `testing` â†’ "Learn pytest patterns", "Learn testing best practices"
   - `patterns` â†’ "Learn design patterns", "Learn SOLID principles"
   - `supabase` â†’ "Learn Supabase RLS", "Learn Supabase realtime"
   - `api` â†’ "Learn REST design", "Learn GraphQL schemas"
2. Select top 3-5 suggestions based on empty categories

**Expected Result**: List of actionable learning suggestions.

### Step 6: Display Report

**Objective**: Present formatted health report to user.

**Actions**:
1. Format output as markdown:
   ```
   ## Brain Health: {health_percentage}% ({status})

   | Category | References | Last Updated |
   |----------|------------|--------------|
   | {category1} | {count} | {date or '-'} |
   | {category2} | {count} | {date or '-'} |
   | ...

   **Total References**: {total_count}

   ### Empty Categories
   {empty_categories_list}

   ### Suggestions
   - {suggestion_1}
   - {suggestion_2}
   - {suggestion_3}

   ---
   Use `/learn {topic}` to add new references.
   ```

**Expected Result**: Health report displayed to user.

## Output Format

The command displays a formatted health report:

```
## Brain Health: 67% (Good)

| Category | References | Last Updated |
|----------|------------|--------------|
| ai-agents | 3 | 2026-01-24 |
| mcp | 5 | 2026-01-24 |
| patterns | 2 | 2026-01-23 |
| python | 4 | 2026-01-22 |
| react | 0 | - |
| supabase | 1 | 2026-01-21 |
| testing | 2 | 2026-01-20 |
| typescript | 0 | - |

**Total References**: 17

### Empty Categories
- react
- typescript
- api

### Suggestions
- Learn React hooks patterns
- Learn TypeScript generics
- Learn REST API design best practices

---
Use `/learn {topic}` to add new references.
```

## Error Handling

### Table Not Found

- **Cause**: Migration 012 hasn't been run
- **Detection**: SQL query fails with "relation does not exist"
- **Recovery**: Inform user to run migration SQL, suggest command

### Query Fails

- **Cause**: Supabase connection error or permission denied
- **Detection**: SQL query throws exception
- **Recovery**: Display error message, suggest checking Supabase credentials

### Empty Result Set

- **Cause**: No references in library yet
- **Detection**: Total count = 0
- **Recovery**: Display "Library is empty" message, suggest running `/learn`

## Examples

### Example 1: Healthy Library

**Command**: `/learn-health`

**Output**:
```
## Brain Health: 89% (Excellent)

| Category | References | Last Updated |
|----------|------------|--------------|
| ai-agents | 5 | 2026-01-24 |
| mcp | 8 | 2026-01-24 |
| patterns | 6 | 2026-01-23 |
| python | 7 | 2026-01-24 |
| react | 4 | 2026-01-22 |
| supabase | 3 | 2026-01-21 |
| testing | 4 | 2026-01-20 |
| typescript | 3 | 2026-01-19 |

**Total References**: 40

### Empty Categories
- api

### Suggestions
- Learn REST API design patterns
```

### Example 2: Empty Library

**Command**: `/learn-health`

**Output**:
```
## Brain Health: 0% (Critical)

| Category | References | Last Updated |
|----------|------------|--------------|
| (no data yet) | - | - |

**Total References**: 0

### All Categories Empty
Your reference library is empty! Start learning:

### Suggestions
- Learn Python async patterns
- Learn MCP server development
- Learn React hooks basics

---
Use `/learn {topic}` to add your first reference.
```

## Notes

- **Quick check**: This command is faster than running `/learn` for just checking stats
- **Token efficient**: Only queries stats, doesn't load full reference content
- **Actionable suggestions**: Based on actual gaps in your library
- **Growth tracking**: Watch health percentage improve over time

## Standard Categories

The health check tracks these 9 standard categories:

| Category | Description | Example Topics |
|----------|-------------|----------------|
| `python` | Python patterns, libraries | async, FastAPI, Django |
| `mcp` | MCP server development | tool creation, server patterns |
| `react` | React, Next.js, hooks | hooks, routing, state |
| `typescript` | TypeScript/JavaScript | types, generics, patterns |
| `ai-agents` | AI agent patterns | prompting, agents, tools |
| `testing` | Testing frameworks | pytest, Jest, testing patterns |
| `patterns` | Design patterns | SOLID, GoF patterns |
| `supabase` | Supabase/database | RLS, realtime, storage |
| `api` | API design | REST, GraphQL, OpenAPI |

## Validation

After executing this command:
- [ ] SQL queries executed successfully
- [ ] Stats calculated correctly
- [ ] Health percentage accurate
- [ ] Empty categories identified
- [ ] Suggestions generated
- [ ] Report formatted and displayed

## Integration with Other Commands

- **`/learn`**: Adds references that increase health percentage
- **PRP templates**: Reference `/learn-health` output to understand available categories
- **`CLAUDE.md`**: Documents both commands as part of reference library system
```

### .claude\\commands\\planning.md
`$(@{Path=.claude\\commands\\planning.md; Language=markdown; Lines=System.Object[]}.Language)
---
name: Planning
description: "Transform discovery insights into comprehensive PRD (Product Requirements Document)"
phase: planning
dependencies: [discovery]
outputs:
  - path: "PRD.md"
    description: "Product Requirements Document at root with features, user stories, acceptance criteria, and technical requirements"
inputs:
  - path: "discovery/discovery-{timestamp}.md"
    description: "Most recent discovery document with ideas, opportunities, and needs analysis"
    required: true
  - path: "MVP.md"
    description: "MVP definition at root"
    required: true
---

# Planning Command

## Purpose

Transform discovery insights into a comprehensive PRD (Product Requirements Document). This command loads the discovery document, extracts the feature name, creates the feature directory structure, researches PRD templates using RAG knowledge base and web MCP servers, generates PRD with features, user stories, acceptance criteria, and technical requirements, and updates indexes and STATUS.md.

**When to use**: Use this command after Discovery phase, when you have identified opportunities and want to create formal requirements for a feature.

**What it solves**: This command addresses the need to transform exploratory findings into actionable, structured requirements that guide implementation.

## Prerequisites

- Discovery command must have been run (at least one `discovery/discovery-*.md` file must exist)
- Archon MCP server should be available (for RAG knowledge base)
- Web MCP servers should be available (for web research)
- `features/` directory must exist (created in Task 01)

## Execution Steps

### Step 1: Load Discovery Document

**Objective**: Load the most recent discovery document for PRD generation.

**Actions**:
1. Find most recent discovery document in `discovery/` matching `discovery-*.md`
2. Load and parse: Ideas, Inspiration Sources, Needs Analysis, Opportunities, Prioritization
3. Extract key information: Opportunities, Ideas, Needs, Inspiration sources

**Expected Result**: Discovery document loaded and parsed.

### Step 2: Extract Feature Name

**Objective**: Extract and validate feature name.

**Actions**:
1. Extract feature name from discovery or generate from primary opportunity
2. Convert to kebab-case (lowercase, hyphens for spaces)
3. Validate no conflicts (check if `features/{feature-name}/` exists)

**Expected Result**: Valid feature name in kebab-case format.

### Step 3: Create Feature Directory Structure

**Objective**: Create feature directory and initialize STATUS.md.

**Actions**:
1. Create `features/{feature-name}/` directory
2. Initialize STATUS.md using STATUS.md generator (Task 03)
3. Set initial phase: "Planning", mark Prime/Discovery completed

**Expected Result**: Feature directory created, STATUS.md initialized.

### Step 4: Research PRD Templates (RAG + Web)

**Objective**: Find PRD templates and best practices.

**Actions**:
1. Search RAG: `rag_search_knowledge_base(query="PRD template", match_count=5, return_mode="pages")`
2. Search web: `web_search_prime_search(query="PRD template best practices")`
3. Read relevant pages: `rag_read_full_page()` and `web_reader_read()`
4. Extract: PRD structure, sections, format guidelines

**Expected Result**: PRD templates and best practices gathered.

### Step 5: Generate PRD Content

**Objective**: Generate comprehensive PRD using AI analysis.

**Actions**:
1. Combine: Discovery + PRD templates + Best practices
2. Prompt AI: "Generate PRD with Overview, User Personas, User Stories with acceptance criteria, Features with priorities, Technical Requirements, Dependencies, Risks & Assumptions"
3. Format PRD as markdown with proper structure

**Expected Result**: Complete PRD content generated.

### Step 6: Save PRD and Update Status

**Objective**: Save PRD and update tracking files.

**Actions**:
1. Save PRD to `features/{feature-name}/prd.md`
2. Update `features/INDEX.md` with feature entry
3. Update STATUS.md: add prd.md artifact, mark Planning complete, set current to Development

**Expected Result**: PRD saved, indexes updated, status tracking updated.

## Output Format

**File**: `PRD.md` (at root)

**Structure**:
```markdown
# PRD: {feature-name}

**Version**: 1.0 | **Last Updated**: {timestamp}

## Overview
{Feature overview}

**Goals**: {list}
**Success Metrics**: {metrics}

## User Personas
**Engineer**: {description}
**Marketer**: {description}
**PM**: {description}

## User Stories
### US-1: {Title}
**As** {persona}, **I want** {goal} **so that** {benefit}.
**Acceptance**: {criteria}

## Features
### Feature 1: {Name}
{Description}. **Priority**: High/Medium/Low

## Technical Requirements
**Data Models**: {description}
**Integrations**: {description}
**Performance**: {description}
**Security**: {description}

## Dependencies
**Required**: {list}
**Optional**: {list}

## Risks & Assumptions
**Risks**: {list}
**Assumptions**: {list}
```

## Error Handling

### No Discovery Document
- Error: "No discovery document found. Run /discovery command first."

### Feature Name Conflict
- Error: "Feature '{name}' already exists. Choose different name."

### PRD Generation Fails
- Retry with shorter context
- Use template structure with discovery content
- Generate partial PRD

## MCP Tool Reference

| Tool | Purpose | Query |
|------|---------|-------|
| `rag_search_knowledge_base()` | Find PRD templates | "PRD template" |
| `web_search_prime_search()` | Find best practices | "PRD template best practices" |
| `rag_read_full_page()` | Get full content | Use page_id from search |
| `web_reader_read()` | Read web content | Use URL from search |

## Examples

**Command**: `/planning ai-coding-workflow-system`

**Output**:
- Loads discovery document
- Creates `features/ai-coding-workflow-system/`
- Generates PRD with 11 user stories, 11 features, technical requirements
- Updates INDEX.md and STATUS.md

## Notes

- Feature name must be kebab-case
- PRD follows standard format: Overview, Personas, User Stories, Features, Technical Requirements, Dependencies, Risks
- User stories format: "As {persona}, I want {goal} so that {benefit}"
- Each user story has acceptance criteria
- Features prioritized: High/Medium/Low
- PRD serves as foundation for Development and Task Planning phases

## Validation

After Planning command:
- [ ] Feature directory created
- [ ] PRD file created with all sections
- [ ] User stories have acceptance criteria
- [ ] Features have priorities
- [ ] INDEX.md updated
- [ ] STATUS.md updated with Planning completed
```

### .claude\\commands\\prime.md
`$(@{Path=.claude\\commands\\prime.md; Language=markdown; Lines=System.Object[]}.Language)
---
name: Prime
description: "Export entire codebase for context gathering with structured markdown output"
phase: prime
dependencies: []
outputs:
  - path: "context/prime-{timestamp}.md"
    description: "Structured markdown export of codebase"
  - path: "context/INDEX.md"
    description: "Index of all prime exports"
inputs: []
---

# Prime Command

## Purpose

Export the entire codebase for context gathering. This command traverses the project directory, respects ignore patterns, and generates a structured markdown export with tree structure and file contents. This provides comprehensive context for AI assistants to understand the codebase structure, patterns, and conventions.

## Execution Steps

### Step 1: Traverse Codebase
- Use Git to get list of tracked files: `git ls-files`
- Respect `.gitignore` and `.cursorignore` patterns
- Skip binary files (detect by extension: .png, .jpg, .gif, .pdf, .zip, etc.)
- Skip files larger than 10MB (log skipped files)
- Skip node_modules, .git, .venv, and other common ignore patterns

### Step 2: Generate Tree Structure
- Use `tree` command or custom traversal to generate directory structure
- Format as markdown code block with proper indentation
- Include file counts per directory

### Step 3: Export File Contents
- Read each file sequentially
- Wrap file contents in markdown code blocks with language tags (detect from extension)
- Include file path as heading (e.g., `### src/api/users.ts`)
- For very large files (>1000 lines), include first 500 and last 500 lines with note

### Step 4: Create Index
- Count files by language/type
- Calculate total lines of code
- List dependencies (from package.json, requirements.txt, etc. if detectable)
- Create summary statistics

### Step 5: Save Output
- Generate timestamp in ISO 8601 format: `YYYY-MM-DDTHH:mm:ssZ`
- Save to `context/prime-{timestamp}.md`
- Update `context/INDEX.md` with new entry:
  - Link to new prime export
  - Timestamp
  - File count and line count summary

## Output Format

```markdown
# Codebase Export: {timestamp}

## Project Tree
```
{tree structure}
```

## Files

### {file-path}
```{language}
{file contents}
```

## Index
- Total Files: {count}
- Total Lines: {count}
- Languages: {list}
- Dependencies: {list if detectable}
```

## Error Handling

- **File Read Errors**: Skip files that cannot be read, log error but continue processing
- **Large Files**: Skip files > 10MB, log warning
- **Binary Files**: Skip binary files, log info
- **Partial Export**: If some files fail, generate partial export with error summary at end
- **Git Errors**: If git is unavailable, fall back to directory traversal

## Notes

- This command should complete in < 5 minutes for codebases with ~10K files
- Large codebases may take longer; consider excluding test files or vendor directories
- The prime export is used as input for Discovery, Task Planning, and other phases
```

### .claude\\commands\\review.md
`$(@{Path=.claude\\commands\\review.md; Language=markdown; Lines=System.Object[]}.Language)
---
name: Review
description: "AI-powered code review with quality, security, and performance analysis"
phase: review
dependencies: [execution]
outputs:
  - path: "features/{feature-name}/review.md"
    description: "Code review report for feature"
  - path: "reviews/review-{timestamp}.md"
    description: "Timestamped review report in reviews directory"
  - path: "reviews/INDEX.md"
    description: "Updated index of all reviews"
  - path: "features/{feature-name}/STATUS.md"
    description: "Updated feature status tracking file"
inputs:
  - path: "context/prime-{timestamp}.md"
    description: "Baseline codebase export from Prime command"
    required: true
  - path: "features/{feature-name}/prd.md"
    description: "Product Requirements Document for compliance verification"
    required: true
  - path: "features/{feature-name}/tech-spec.md"
    description: "Technical Specification for compliance verification"
    required: true
  - path: "features/{feature-name}/execution.md"
    description: "Execution log with completed tasks"
    required: true
---

# Review Command

## Purpose

Perform AI-powered code review by identifying code changes, analyzing quality (best practices, security, performance), verifying compliance with PRD and tech spec, and generating a comprehensive review report with severity levels, fix recommendations, and code examples.

## Execution Steps

### Step 1: Load Baseline and Current Codebase

Load Prime baseline and current codebase for comparison:

1. **Load Prime baseline**:
   - Find most recent `context/prime-*.md` (or use baseline from feature start)
   - Read and parse Prime export
   - Extract: Project tree, file contents, index statistics
   - Store as baseline

2. **Export current codebase**:
   - Run Prime command to export current codebase
   - Or load most recent Prime export if available
   - Parse current codebase structure
   - Extract: Project tree, file contents, index statistics
   - Store as current

3. **Compare codebases**:
   - Compare project trees (baseline vs current)
   - Identify new files
   - Identify modified files
   - Identify deleted files (if any)
   - Extract file differences

**Expected Result**: Code changes identified and extracted.

### Step 2: Analyze Code Quality

Use AI/MCP to analyze code quality (best practices, security, performance):

1. **Prepare code context**:
   - Combine: Changed files + PRD + Tech Spec + PRP
   - Extract code snippets for analysis
   - Organize by file and change type

2. **Query AI for quality analysis**:
   - For each changed file:
     - Prompt AI: "Review this code for quality, security, and performance. Check: Best practices, code smells, security vulnerabilities, performance issues, maintainability, readability. Provide specific recommendations."
     - Include: File content, PRD requirements, Tech Spec guidelines, PRP anti-patterns
     - Request structured analysis

3. **Extract quality issues**:
   - Parse AI response for:
     - Best practice violations
     - Code smells
     - Security vulnerabilities
     - Performance issues
     - Maintainability concerns
     - Readability issues
   - Categorize by severity (Critical, High, Medium, Low)

4. **Use RAG knowledge base** (optional):
   - Search knowledge base for code review patterns: `rag_search_knowledge_base(query="code review best practices", match_count=3)`
   - Search for security patterns: `rag_search_knowledge_base(query="security vulnerabilities", match_count=3)`
   - Search for performance patterns: `rag_search_knowledge_base(query="performance optimization", match_count=3)`
   - Use results to enhance review

**Expected Result**: Code quality issues identified and categorized.

### Step 3: Verify Compliance

Verify code compliance with PRD, tech spec, and acceptance criteria:

1. **Load PRD and Tech Spec**:
   - Read `features/{feature-name}/prd.md`
   - Read `features/{feature-name}/tech-spec.md`
   - Extract: Features, user stories, acceptance criteria, technical requirements

2. **Check PRD compliance**:
   - For each PRD feature:
     - Verify feature is implemented
     - Check user story acceptance criteria are met
     - Verify feature matches PRD description
     - Identify missing features or incomplete implementations

3. **Check Tech Spec compliance**:
   - Verify architecture matches Tech Spec
   - Verify technology stack matches Tech Spec
   - Verify file structure matches Tech Spec
   - Verify data models match Tech Spec
   - Verify MCP integration matches Tech Spec
   - Verify error handling matches Tech Spec

4. **Check acceptance criteria**:
   - Verify all acceptance criteria are met
   - Check test coverage (if required)
   - Verify feature functionality matches PRD

5. **Document compliance issues**:
   - List PRD violations
   - List Tech Spec violations
   - List missing features
   - List incomplete implementations

**Expected Result**: Compliance issues identified and documented.

### Step 4: Generate Review Report

Compile findings into comprehensive review report:

1. **Create document structure**:
   ```markdown
   # Code Review: {feature-name}

   ## Review Summary
   {Overall assessment}

   ## Code Changes
   {List of new, modified, deleted files}

   ## Quality Issues
   {Issues categorized by severity}

   ## Security Findings
   {Security vulnerabilities and recommendations}

   ## Performance Findings
   {Performance issues and recommendations}

   ## Compliance Verification
   {PRD and Tech Spec compliance status}

   ## Recommendations
   {Prioritized fix recommendations}

   ## Approval Status
   {Approved, Approved with Changes, Blocked}
   ```

2. **Populate content**:
   - Fill in: Code changes from Step 1
   - Fill in: Quality issues from Step 2
   - Fill in: Security findings from Step 2
   - Fill in: Performance findings from Step 2
   - Fill in: Compliance verification from Step 3
   - Fill in: Prioritized recommendations

3. **Generate timestamp**:
   - Use ISO 8601 format: YYYY-MM-DDTHH:mm:ssZ
   - Include in filename and document

4. **Save documents**:
   - Save feature review: `features/{feature-name}/review.md`
   - Save timestamped review: `reviews/review-{timestamp}.md`
   - Update `reviews/INDEX.md` with new entry

5. **Update STATUS.md**:
   - Mark Review phase with status
   - Add approval status
   - Update next steps based on review

## Output Format

```markdown
# Code Review: {feature-name}

**Reviewed By**: AI Assistant
**Review Date**: {timestamp}
**Feature**: {feature-name}
**Baseline**: {prime-timestamp}
**Current**: {current-timestamp}

## Review Summary

### Overall Assessment
{Overall quality assessment and approval status}

### Statistics
- **Files Changed**: {count}
- **Issues Found**: {count}
  - Critical: {count}
  - High: {count}
  - Medium: {count}
  - Low: {count}
- **Security Issues**: {count}
- **Performance Issues**: {count}
- **Compliance Issues**: {count}

## Code Changes

### New Files
| File | Lines | Purpose |
|------|-------|---------|
| {path} | {count} | {description} |

### Modified Files
| File | Changes | Lines Added | Lines Removed |
|------|---------|-------------|----------------|
| {path} | {description} | {count} | {count} |

### Deleted Files
| File | Reason |
|------|--------|
| {path} | {reason} |

## Quality Issues

### Critical Issues
{Critical issues requiring immediate fix}

### High Priority Issues
{High priority issues with significant impact}

### Medium Priority Issues
{Medium priority issues for improvement}

### Low Priority Issues
{Low priority issues for consideration}

### Code Smells
| File | Type | Description | Recommendation |
|------|------|-------------|----------------|
| {path} | {type} | {description} | {fix} |

## Security Findings

### Vulnerabilities
| Severity | File | Issue | Recommendation |
|----------|------|-------|----------------|
| {level} | {path} | {description} | {fix} |

### Security Best Practices
{Recommendations for improving security}

## Performance Findings

### Performance Issues
| Severity | File | Issue | Recommendation |
|----------|------|-------|----------------|
| {level} | {path} | {description} | {fix} |

### Performance Recommendations
{Recommendations for improving performance}

## Compliance Verification

### PRD Compliance
| Feature | Status | Notes |
|---------|--------|-------|
| {feature} | {Met/Not Met/Partial} | {notes} |

### Tech Spec Compliance
| Requirement | Status | Notes |
|-------------|--------|-------|
| {req} | {Met/Not Met/Partial} | {notes} |

### Acceptance Criteria
| Criteria | Status | Notes |
|----------|--------|-------|
| {criteria} | {Met/Not Met/Partial} | {notes} |

## Recommendations

### Immediate Actions
{Actions that must be taken before approval}

### Short-Term Improvements
{Improvements to implement soon}

### Long-Term Enhancements
{Enhancements for future consideration}

## Approval Status

**Status**: {Approved / Approved with Changes / Blocked}

**Reason**: {Justification for approval status}

**Conditions for Approval**:
- All critical issues resolved
- All high priority issues addressed
- PRD and Tech Spec compliance met
- Acceptance criteria satisfied

**Next Steps**:
{Recommended next steps based on review}
```

## Error Handling

- **Baseline Not Found**: Check `context/` directory, list available exports, use oldest or request manual specification
- **PRD Not Found**: Check `features/{feature-name}/` directory, error and stop
- **Tech Spec Not Found**: Check `features/{feature-name}/` directory, error and stop
- **Execution Log Not Found**: Check `features/{feature-name}/` directory, warn about missing execution log
- **AI Analysis Fails**: Log error, proceed with manual review option
- **Compliance Check Fails**: Log which document failed, continue with available documents

## Notes

- Review provides quality assurance before testing and deployment
- Severity levels help prioritize fixes
- Approval status gates progression to next phase
- Reviews are stored both with feature and globally
- Use RAG knowledge base to enhance review quality
- Recommendations should be actionable and specific
```

### .claude\\commands\\task-planning.md
`$(@{Path=.claude\\commands\\task-planning.md; Language=markdown; Lines=System.Object[]}.Language)
---
name: Task Planning
description: "Combine all contexts into actionable tasks with PRP guidance"
phase: task-planning
dependencies: [development]
outputs:
  - path: "features/{feature-name}/prp.md"
    description: "Plan Reference Protocol document with codebase-aware implementation guidance"
  - path: "features/{feature-name}/task-plan.md"
    description: "Task plan with task IDs, dependencies, and execution order"
  - path: "features/{feature-name}/STATUS.md"
    description: "Updated feature status tracking file"
  - path: "features/{feature-name}/execution/"
    description: "Execution folder with individual task files (deleted as tasks complete)"
inputs:
  - path: "context/prime-{timestamp}.md"
    description: "Most recent codebase export from Prime command"
    required: true
  - path: "discovery/discovery-{timestamp}.md"
    description: "Most recent discovery document"
    required: false
  - path: "MVP.md"
    description: "MVP definition at root"
    required: true
  - path: "PRD.md"
    description: "Product Requirements Document at root"
    required: true
  - path: "TECH-SPEC.md"
    description: "Technical Specification at root"
    required: true
---

# Task Planning Command

## Purpose

Combine all contexts (Prime, Discovery, PRD, Tech Spec) into actionable tasks with PRP guidance. This command loads all contexts, extracts codebase patterns, selects appropriate PRP template, generates PRP with codebase-aware context, breaks down tasks with dependencies, creates tasks in Archon MCP, and generates task plan document.

## Execution Steps

### Step 1: Load All Contexts

Load Prime, Discovery, PRD, and Tech Spec for comprehensive context:

1. **Load Prime export**:
   - Find most recent `context/prime-*.md`
   - Read and parse Prime export
   - Extract: Project tree, file contents, index statistics
   - Store in memory

2. **Load Discovery document** (if available):
   - Find most recent `discovery/discovery-*.md`
   - Read and parse Discovery document
   - Extract: Ideas, Inspiration Sources, Needs Analysis, Opportunities
   - Store in memory

3. **Load PRD**:
   - Read `features/{feature-name}/prd.md`
   - Parse PRD structure
   - Extract: Overview, User Stories, Features, Technical Requirements, Acceptance Criteria
   - Store in memory

4. **Load Tech Spec**:
   - Read `features/{feature-name}/tech-spec.md`
   - Parse Tech Spec structure
   - Extract: System Architecture, Technology Stack, Command Structure, File System Structure, Data Models, MCP Integration
   - Store in memory

5. **Combine contexts**:
   - Merge all contexts into single context object
   - Organize by source (Prime, Discovery, PRD, Tech Spec)
   - Prepare for pattern extraction and PRP generation

**Expected Result**: All contexts loaded and combined.

### Step 2: Extract Codebase Patterns

Use pattern extraction utility to extract codebase patterns from Prime export:

1. **Call pattern extraction utility**:
   - Use utility from Task 11: `extract_codebase_patterns(prime_export_path)`
   - Pass path to most recent Prime export
   - Receive extracted patterns

2. **Extract patterns**:
   - File structure patterns
   - Naming conventions (files, functions, classes, variables, constants)
   - Architecture patterns (service structure, API patterns, component structure, data flow)
   - Similar implementations (reference files)
   - Testing patterns (test framework, test organization, test structure)
   - Validation commands (linting, formatting, type checking)

3. **Store patterns**:
   - Store patterns in memory
   - Prepare for PRP template population

**Expected Result**: Codebase patterns extracted and ready for PRP generation.

### Step 3: Select PRP Template

Select appropriate PRP template based on feature type:

1. **Analyze feature characteristics**:
   - Review PRD features and requirements
   - Review Tech Spec system architecture and technology stack
   - Identify feature type:
     - AI agent (uses AI models, prompts, tools)
     - MCP integration (integrates with MCP server)
     - API endpoint (handles HTTP requests/responses)
     - Frontend component (renders UI, handles user interactions)
     - Generic/custom (doesn't fit specialized templates)

2. **Select template**:
   - If AI agent â†’ `templates/prp/prp-ai-agent.md`
   - If MCP integration â†’ `templates/prp/prp-mcp-integration.md`
   - If API endpoint â†’ `templates/prp/prp-api-endpoint.md`
   - If frontend component â†’ `templates/prp/prp-frontend-component.md`
   - Otherwise â†’ `templates/prp/prp-base.md`

3. **Load selected template**:
   - Read template file contents
   - Parse template structure
   - Identify sections to populate

**Expected Result**: PRP template selected and loaded.

### Step 4: Generate PRP

Populate PRP template with codebase patterns and context:

1. **Populate base sections**:
   - Goal: Fill from PRD Overview and success criteria
   - Deliverable: Fill from PRD features and requirements
   - Success Criteria: Fill from PRD acceptance criteria
   - Documentation URLs: Add relevant links from Discovery and web research
   - File References: Add from codebase patterns extraction
   - Naming Conventions: Fill from codebase patterns extraction
   - Architecture Patterns: Fill from codebase patterns extraction

2. **Populate template-specific sections** (based on selected template):
   - AI Agent sections: Agent Architecture, Agent Tools, Agent Memory, Agent Workflow
   - MCP Integration sections: MCP Server Configuration, MCP Tools, MCP Resources, MCP Prompts
   - API Endpoint sections: API Design, API Authentication, API Validation, API Documentation
   - Frontend Component sections: Component Architecture, Component Styling, Component Integration, Component Performance

3. **Populate Implementation Blueprint**:
   - Data Models: Extract from Tech Spec
   - Implementation Tasks: Break down from PRD features and Tech Spec implementation phases
   - Dependencies: Extract from Tech Spec and analyze task relationships
   - File Structure: Extract from Tech Spec and combine with codebase patterns
   - Integration Points: Extract from Tech Spec MCP Integration section

4. **Populate Validation Loop**:
   - Syntax Validation: Use validation commands from codebase patterns
   - Unit Tests: Use test patterns from codebase
   - Integration Tests: Follow integration test patterns from codebase
   - End-to-End Tests: Define based on PRD user stories

5. **Populate Anti-Patterns**:
   - General anti-patterns: From PRP base template
   - Template-specific anti-patterns: From selected specialized template

6. **Generate PRP document**:
   - Combine all populated sections
   - Add metadata (version, timestamp, related documents)
   - Format as markdown

**Expected Result**: Codebase-aware PRP generated with all needed context.

### Step 5: Create Tasks in Archon MCP

Break down implementation tasks and create in Archon MCP:

1. **Verify Archon MCP availability**:
   - Call `health_check()` to verify server is available
   - If unavailable, stop and inform user (per ARCHON-FIRST RULE)

2. **Create or find project**:
   - Call `find_projects(query="{feature-name}")` to check if project exists
   - If not found, create project: `manage_project("create", title="{feature-name}", description="...")`
   - Store project_id

3. **Break down implementation tasks**:
   - Extract implementation tasks from PRP Implementation Blueprint
   - Add dependencies between tasks
   - Estimate effort for each task (30 min - 4 hours)
   - Assign task_order (higher = higher priority, 0-100)

4. **Create tasks in Archon**:
   - For each task in implementation plan:
     - Create task: `manage_task("create", project_id="{project_id}", title="{task-title}", description="{task-description}", task_order={priority})`
     - Store returned task_id

5. **Generate task plan document**:
   - Create markdown table with tasks:
     - Task ID
     - Task title
     - Dependencies
     - Estimated effort
     - Status

**Expected Result**: Tasks created in Archon MCP and task plan document generated.

### Step 6: Create Execution Folder with Task Files

Create local execution folder with individual task files for visibility and tracking:

1. **Create execution folder**:
   - Create `features/{feature-name}/execution/` directory

2. **Create INDEX.md**:
   - List all tasks with links to individual files
   - Include project ID and workflow instructions

3. **Create individual task files**:
   - For each task, create `{order}-{task-slug}.md`
   - Include: Task ID, Priority, Status, Dependencies
   - Include: Description, Steps, Deliverables
   - Include: "On Completion" section with:
     - Command to mark done in Archon
     - Instruction to delete the file
     - Next task reference

4. **Task file naming convention**:
   - Format: `{order:02d}-{task-slug}.md`
   - Example: `01-run-sql-migration.md`, `02-create-learn-command.md`

**Expected Result**: Execution folder created with task files for local tracking.

**Workflow**: 
- Tasks exist in both Archon (source of truth) AND execution folder (local visibility)
- When task completes: Mark done in Archon â†’ Delete the file
- When all task files deleted: Feature is complete

### Step 7: Save Documents and Update Status

Save PRP and task plan, update feature STATUS:

1. **Save PRP document**:
   - Save to `features/{feature-name}/prp.md`
   - Verify file created successfully

2. **Save task plan document**:
   - Save to `features/{feature-name}/task-plan.md`
   - Verify file created successfully

3. **Update STATUS.md**:
   - Read existing `features/{feature-name}/STATUS.md` or create new
   - Add Task Planning phase:
     - Mark as "Task Planning - Completed"
     - List tasks created with IDs
     - Link to PRP and task plan documents
   - Update artifacts list
   - Add timestamp

**Expected Result**: Documents saved, STATUS.md updated.

## Output Format

### PRP Document

```markdown
# PRP: {feature-name}

**Version**: 1.0 | **Last Updated**: {timestamp} | **Related**: PRD.md, TECH-SPEC.md

## Goal
{Goal section populated from context}

## All Needed Context
{Context section populated with codebase patterns}

## Implementation Blueprint
{Implementation Blueprint section populated from Tech Spec and PRD}

## Validation Loop
{Validation Loop section populated from codebase patterns}

## Anti-Patterns
{Anti-patterns section populated from template}
```

### Task Plan Document

```markdown
# Task Plan: {feature-name}

**Generated**: {timestamp}
**PRP Version**: 1.0
**Total Tasks**: {count}
**Archon Project ID**: {project-id}

## Task List

| Task ID | Task Title | Dependencies | Priority | Estimate | Status |
|----------|------------|--------------|----------|-----------|--------|
| {id} | {title} | {deps} | {priority} | {estimate} | {status} |

## Execution Order

1. Task {id}: {title}
2. Task {id}: {title}
3. Task {id}: {title}
... (repeat for all tasks in dependency order)

## Next Steps
- Execute Task 1 (no dependencies)
- Proceed through tasks in dependency order
- Track progress in Archon MCP
```

## Error Handling

- **Prime Export Not Found**: Check `context/` directory, list available exports, suggest running `/prime`
- **PRD Not Found**: Check `features/{feature-name}/` directory, error and stop
- **Tech Spec Not Found**: Check `features/{feature-name}/` directory, error and stop
- **Pattern Extraction Fails**: Log warning, continue with limited codebase awareness
- **PRP Template Not Found**: Check `templates/prp/` directory, error and stop
- **Archon MCP Unavailable**: Stop execution, inform user, wait for availability (per ARCHON-FIRST RULE)
- **Task Creation Fails**: Log error, continue with task plan only

## Notes

- CRITICAL: Always use Archon MCP for task management (ARCHON-FIRST RULE)
- Never use TodoWrite fallback
- PRP provides codebase-aware implementation guidance
- Tasks are created with dependencies for proper execution order
- Task IDs from Archon MCP are used during Execution command
- STATUS.md tracks phase progress
- Task plan document provides offline reference
- Each task should represent 30 minutes to 4 hours of work
- Higher task_order = higher priority
- Only ONE task in 'doing' status at a time
```

### .claude\\commands\\template.md
`$(@{Path=.claude\\commands\\template.md; Language=markdown; Lines=System.Object[]}.Language)
---
name: Command Name
description: "Brief description of what this command does"
phase: prime|discovery|planning|development|task-planning|execution|review|test
dependencies: []
outputs:
  - path: "relative/path/to/output.md"
    description: "Description of output"
inputs:
  - path: "relative/path/to/input.md"
    description: "Description of input"
    required: true|false
---

# Command Name

## Purpose

[Detailed description of command purpose]

This command [what it does]. It is used during the [phase] phase to [specific purpose].

**When to use**: Use this command when [conditions].

**What it solves**: This command addresses [problem/need].

## Prerequisites

- [Prerequisite 1]
- [Prerequisite 2]

## Execution Steps

### Step 1: [Step Name]

[Detailed instructions for step 1]

**Actions**:
1. Action 1
2. Action 2
3. Action 3

**Expected Result**: [What should happen]

### Step 2: [Step Name]

[Detailed instructions for step 2]

**Actions**:
1. Action 1
2. Action 2

**Expected Result**: [What should happen]

### Step 3: [Step Name]

[Detailed instructions for step 3]

**Actions**:
1. Action 1
2. Action 2

**Expected Result**: [What should happen]

## Output Format

The command generates the following output:

**File**: `{output-path}`

**Structure**:
```markdown
# {Output Title}

## Section 1
{Content}

## Section 2
{Content}
```

**Required Sections**:
- Section 1 (required)
- Section 2 (required)
- Section 3 (optional)

**Format Requirements**:
- Markdown format
- ISO 8601 timestamps (YYYY-MM-DDTHH:mm:ssZ)
- UTF-8 encoding

## Error Handling

### Error Types

1. **Error Type 1**: [Description]
   - **Cause**: [What causes it]
   - **Detection**: [How to detect]
   - **Recovery**: [How to recover]

2. **Error Type 2**: [Description]
   - **Cause**: [What causes it]
   - **Detection**: [How to detect]
   - **Recovery**: [How to recover]

### Error Recovery

**On Error**:
1. Log error to execution.md
2. Update task status in Archon MCP
3. Provide clear error message to user
4. Suggest recovery steps
5. Allow resume from checkpoint

**Checkpoint/Resume**:
- Save state to STATUS.md
- Allow resume with `--from-{phase}` option
- Preserve partial work

## Examples

### Example 1: [Scenario]

**Input**: [Input description]

**Output**: [Output description]

**Steps**:
1. [Step]
2. [Step]
3. [Step]

## Notes

- [Note 1]
- [Note 2]
- [Gotcha 1]
- [Best practice 1]

## Validation

After executing this command:
- [ ] Output file(s) created successfully
- [ ] Output format matches specification
- [ ] All required sections present
- [ ] INDEX.md updated (if applicable)
- [ ] STATUS.md updated (if applicable)
- [ ] Archon MCP tasks updated (if applicable)
```

### .claude\\commands\\test.md
`$(@{Path=.claude\\commands\\test.md; Language=markdown; Lines=System.Object[]}.Language)
---
name: Test
description: "Automated testing with error detection and AI-suggested fixes"
phase: test
dependencies: [execution]
outputs:
  - path: "features/{feature-name}/test-results.md"
    description: "Test results report for feature"
  - path: "testing/test-results-{timestamp}.md"
    description: "Timestamped test results in testing directory"
  - path: "testing/INDEX.md"
    description: "Updated index of all test results"
  - path: "features/{feature-name}/STATUS.md"
    description: "Updated feature status tracking file"
inputs:
  - path: "features/{feature-name}/prd.md"
    description: "Product Requirements Document for acceptance criteria verification"
    required: true
  - path: "features/{feature-name}/prp.md"
    description: "Plan Reference Protocol for test patterns and validation commands"
    required: true
  - path: "features/{feature-name}/execution.md"
    description: "Execution log with completed tasks"
    required: true
---

# Test Command

## Purpose

Automate testing with error detection and AI-suggested fixes. This command runs test suites (unit, integration, E2E), detects errors, uses AI to suggest fixes, generates coverage reports, verifies acceptance criteria, and stores test results.

## Execution Steps

### Step 1: Load Test Configuration

Load test configuration from PRP and codebase patterns:

1. **Load PRP**:
   - Read `features/{feature-name}/prp.md`
   - Extract Validation Loop section
   - Extract: Test patterns, test framework, coverage requirements

2. **Load PRD**:
   - Read `features/{feature-name}/prd.md`
   - Extract acceptance criteria
   - Extract success metrics

3. **Identify test framework**:
   - From PRP or codebase patterns
   - Common frameworks: Jest, Vitest, Mocha, pytest, etc.
   - Identify test commands

**Expected Result**: Test configuration loaded and ready.

### Step 2: Run Test Suites

Execute test suites and capture output:

1. **Run unit tests**:
   - Execute unit test command (e.g., `npm run test:unit` or `pytest tests/`)
   - Capture stdout and stderr
   - Capture exit code
   - Record duration

2. **Run integration tests** (if configured):
   - Execute integration test command (e.g., `npm run test:integration`)
   - Capture stdout and stderr
   - Capture exit code
   - Record duration

3. **Run E2E tests** (if configured):
   - Execute E2E test command (e.g., `npm run test:e2e` or `playwright tests/`)
   - Capture stdout and stderr
   - Capture exit code
   - Record duration

4. **Run coverage analysis** (if configured):
   - Execute coverage command (e.g., `npm run test:coverage` or `pytest --cov`)
   - Capture coverage report
   - Extract coverage percentages

5. **Handle test execution errors**:
   - If test command fails to execute:
     - Log error: "Test command failed to execute: {error}"
     - Continue with available test results
     - Mark as partial test run

**Expected Result**: Test suites executed, output captured.

### Step 3: Detect Errors

Parse test output to identify failures and errors:

1. **Parse test output**:
   - Parse test framework output format
   - Extract: Test results, failures, errors, skips
   - Organize by test suite

2. **Identify test failures**:
   - Extract failed test names
   - Extract error messages
   - Extract stack traces
   - Extract assertion failures

3. **Identify runtime errors**:
   - Extract runtime error messages
   - Extract stack traces
   - Extract timeout errors
   - Extract setup/teardown errors

4. **Organize errors**:
   - Group by test file
   - Group by error type
   - Prioritize by severity

**Expected Result**: Errors detected and categorized.

### Step 4: AI-Suggested Fixes

Use AI/MCP to analyze errors and generate fix suggestions:

1. **Prepare error context**:
   - Combine: Error messages + Stack traces + Test code + Implementation code
   - Include PRP anti-patterns and validation commands
   - Extract relevant code snippets

2. **Query AI for fix suggestions**:
   - For each error:
     - Prompt AI: "Analyze this test failure and suggest a fix. Error: {error_message}. Stack trace: {stack_trace}. Test code: {test_code}. Implementation code: {implementation_code}. Provide specific fix with code examples."
     - Request structured response:
       - Root cause analysis
       - Fix recommendation
       - Code example showing fix
       - Prevention suggestions

3. **Use RAG knowledge base** (optional):
   - Search for similar errors: `rag_search_knowledge_base(query="test failure {error_type}", match_count=3)`
   - Search for fix patterns: `rag_search_code_examples(query="test fix {error_type}", match_count=3)`
   - Use results to enhance fix suggestions

4. **Extract fix suggestions**:
   - Parse AI response for:
     - Root cause
     - Fix recommendation
     - Code example
     - Prevention tips

**Expected Result**: Fix suggestions generated for each error.

### Step 5: Generate Test Results Report

Compile findings into comprehensive test report:

1. **Create document structure**:
   ```markdown
   # Test Results: {feature-name}

   ## Test Summary
   {Overall test results}

   ## Test Suites
   {Results from each test suite}

   ## Errors Detected
   {List of errors with details}

   ## Fix Suggestions
   {AI-suggested fixes for each error}

   ## Coverage Report
   {Coverage analysis if available}

   ## Acceptance Criteria Verification
   {Verification of PRD acceptance criteria}

   ## Recommendation
   {Overall recommendation for next steps}
   ```

2. **Populate content**:
   - Fill in: Test summary from Step 2
   - Fill in: Errors detected from Step 3
   - Fill in: Fix suggestions from Step 4
   - Fill in: Coverage report from Step 2
   - Fill in: Acceptance criteria verification
   - Fill in: Overall recommendation

3. **Generate timestamp**:
   - Use ISO 8601 format: YYYY-MM-DDTHH:mm:ssZ
   - Include in filename and document

4. **Save documents**:
   - Save feature test results: `features/{feature-name}/test-results.md`
   - Save timestamped test results: `testing/test-results-{timestamp}.md`
   - Update `testing/INDEX.md` with new entry

5. **Update STATUS.md**:
   - Mark Test phase with status
   - Add test results summary
   - Update artifacts list
   - Add timestamp

**Expected Result**: Test report generated, STATUS.md updated.

## Output Format

```markdown
# Test Results: {feature-name}

**Tested By**: Test Command
**Test Date**: {timestamp}
**Feature**: {feature-name}
**Duration**: {duration}

## Test Summary

### Overall Results
- **Total Tests Run**: {count}
- **Passed**: {count}
- **Failed**: {count}
- **Skipped**: {count}
- **Pass Rate**: {percentage}
- **Duration**: {duration}

### Test Suites

#### Unit Tests
- **Total**: {count}
- **Passed**: {count}
- **Failed**: {count}
- **Duration**: {duration}
- **Command**: {test_command}

#### Integration Tests
- **Total**: {count}
- **Passed**: {count}
- **Failed**: {count}
- **Duration**: {duration}
- **Command**: {test_command}

#### E2E Tests (if applicable)
- **Total**: {count}
- **Passed**: {count}
- **Failed**: {count}
- **Duration**: {duration}
- **Command**: {test_command}

## Errors Detected

| Test | Type | Error Message | Stack Trace | Severity |
|-------|------|--------------|-------------|----------|
| {test} | {type} | {error} | {trace} | {severity} |

### Error Summary
- **Total Errors**: {count}
  - Critical: {count}
  - High: {count}
  - Medium: {count}
  - Low: {count}

## Fix Suggestions

| Error | Root Cause | Fix Recommendation | Code Example |
|-------|------------|-------------------|--------------|
| {error} | {cause} | {fix} | {example} |

### Additional Recommendations
{Additional suggestions from AI analysis}

## Coverage Report

### Overall Coverage
- **Lines Covered**: {count}
- **Total Lines**: {count}
- **Coverage**: {percentage}

### Coverage by File
| File | Lines Covered | Total Lines | Coverage |
|------|--------------|-------------|----------|
| {file} | {count} | {count} | {percentage} |

## Acceptance Criteria Verification

| Criteria | Status | Notes |
|----------|--------|-------|
| {criteria} | {Pass/Fail} | {notes} |

### Overall Verification
- **All Criteria Met**: {Yes/No}
- **Gaps Identified**: {count}
- **Blocking Issues**: {count}

## Recommendation

### Status
{Overall test result status: Pass/Fail/Partial}

### Next Steps
{Recommended actions based on test results}

- If all tests pass: Proceed to deployment or review
- If tests fail: Fix errors, re-run tests
- If coverage low: Add tests, re-run coverage
```

## Error Handling

- **PRP Not Found**: Check `features/{feature-name}/` directory, error and stop
- **PRD Not Found**: Check `features/{feature-name}/` directory, error and stop
- **Test Framework Not Found**: Use default test commands (npm run test, pytest)
- **Test Command Fails**: Log error, mark as partial test run, continue with available results
- **Coverage Analysis Fails**: Log error, continue without coverage report
- **AI Analysis Fails**: Log error, generate test report without fix suggestions
- **Acceptance Criteria Verification Fails**: Log which criterion failed, continue with other checks

## Notes

- Test command automates test execution and error detection
- AI-suggested fixes provide actionable guidance for fixing errors
- Coverage reports help identify untested code
- Acceptance criteria verification ensures PRD requirements are met
- Test results are stored both with feature and globally
- Test results feed into review and deployment phases
- If all tests pass, proceed to review or deployment
- If tests fail, fix errors and re-run tests before proceeding
```

### .claude\\commands\\update-index.md
`$(@{Path=.claude\\commands\\update-index.md; Language=markdown; Lines=System.Object[]}.Language)
---
name: update-index
description: Update INDEX.md file with new file entry or regenerate from directory contents
phase: utility
inputs:
  - directory: Directory path containing INDEX.md (e.g., "context", "discovery", "features")
  - filename: Name of file to add (optional if regenerating)
  - description: Description of file (optional, auto-extracted if not provided)
  - timestamp: ISO 8601 timestamp (optional, defaults to current time)
  - is_directory: True if adding a subdirectory (for features/)
  - regenerate: If true, regenerate entire INDEX.md from directory contents
outputs:
  - Updated INDEX.md file with new entry
dependencies:
  - Directory must exist
  - INDEX.md may or may not exist (will create if missing)
---

# Update INDEX Command

## Purpose

Update or create INDEX.md files with file entries to provide navigation and tracking across the AI Coding Workflow System.

## When to Use

Use this command after creating any new file in the workflow system:
- After Prime command creates `context/prime-{timestamp}.md`
- After Discovery command creates `discovery/discovery-{timestamp}.md`
- After Planning command creates `features/{feature-name}/` directory
- After Review command creates `reviews/review-{timestamp}.md`
- After Test command creates `testing/test-results-{timestamp}.md`

## Execution Steps

### Step 1: Determine Parameters

Extract parameters from command context:
- `directory`: The directory being updated
- `filename`: The file or subdirectory being added
- `description`: Optional description (extract from file if not provided)
- `timestamp`: Optional timestamp (extract from filename or use current time)
- `is_directory`: True if adding a feature subdirectory
- `regenerate`: True if regenerating entire INDEX.md

### Step 2: Read Existing INDEX.md

If `regenerate` is false:
1. Check if `{directory}/INDEX.md` exists
2. If exists, read current content
3. Parse existing file entries
4. Check if filename already exists in index

### Step 3: Generate File Entry

Create new file entry in format:

```markdown
### {filename}
- **Created**: {timestamp}
- **Description**: {description}
- **Link**: [{filename}](./{filename})
```

For feature directories (features/):
```markdown
### {feature-name}
- **Created**: {timestamp}
- **Description**: {description}
- **Link**: [{feature-name}/](./{feature-name}/)
- **Status**: {current_phase}
- **Artifacts**: {list_of_artifacts}
```

### Step 4: Update INDEX.md

If `regenerate` is false:
1. Read existing INDEX.md
2. Insert new entry in chronological order (newest first)
3. Preserve overview and navigation sections
4. Write back to file

If `regenerate` is true:
1. Scan directory for all files/subdirectories
2. Extract metadata from each (timestamp from filename or filesystem)
3. Generate complete INDEX.md with all entries
4. Sort by timestamp (newest first, or alphabetical for templates/)

### Step 5: Handle Edge Cases

- **INDEX.md doesn't exist**: Create with template structure
- **File already in index**: Update entry or skip if unchanged
- **Directory is empty**: Create INDEX.md with "No files yet" message
- **Corrupted INDEX.md**: Backup and regenerate

## Output Format

### context/INDEX.md Template

```markdown
# Context Index

## Overview
This directory contains codebase context exports from the Prime command. Each export is a complete snapshot of the codebase at a specific point in time.

## Files

### prime-2026-01-23T14:30:00Z.md
- **Created**: 2026-01-23T14:30:00Z
- **Description**: Codebase export from Prime command
- **Link**: [prime-2026-01-23T14:30:00Z.md](./prime-2026-01-23T14:30:00Z.md)

## Navigation
- [Back to Root](../)
- [Features](../features/)
- [Discovery](../discovery/)
```

### discovery/INDEX.md Template

```markdown
# Discovery Index

## Overview
This directory contains discovery phase outputs. Discovery documents explore ideas, inspiration, and needs for AI agents and AI/ATR applications.

## Files

### discovery-2026-01-23T15:00:00Z.md
- **Created**: 2026-01-23T15:00:00Z
- **Description**: Discovery document with ideas, inspiration, needs, opportunities
- **Link**: [discovery-2026-01-23T15:00:00Z.md](./discovery-2026-01-23T15:00:00Z.md)

## Navigation
- [Back to Root](../)
- [Context](../context/)
- [Features](../features/)
```

### features/INDEX.md Template

```markdown
# Features Index

## Overview
This directory contains all feature-specific artifacts organized by feature name. Each feature has its own subdirectory with PRD, tech spec, PRP, task plans, execution logs, reviews, and test results.

## Features

### ai-coding-workflow-system
- **Created**: 2026-01-23T16:00:00Z
- **Description**: AI Coding Workflow System feature
- **Link**: [ai-coding-workflow-system/](./ai-coding-workflow-system/)
- **Status**: Planning phase
- **Artifacts**: prd.md, tech-spec.md

## Navigation
- [Back to Root](../)
- [Context](../context/)
- [Discovery](../discovery/)
```

### reviews/INDEX.md Template

```markdown
# Reviews Index

## Overview
This directory contains code review reports generated by the Review command. Reviews analyze code quality, security, performance, and compliance with PRD and tech spec.

## Files

### review-2026-01-23T20:00:00Z.md
- **Created**: 2026-01-23T20:00:00Z
- **Description**: Code review for feature ai-coding-workflow-system
- **Link**: [review-2026-01-23T20:00:00Z.md](./review-2026-01-23T20:00:00Z.md)

## Navigation
- [Back to Root](../)
- [Features](../features/)
- [Testing](../testing/)
```

### testing/INDEX.md Template

```markdown
# Testing Index

## Overview
This directory contains test execution results generated by the Test command. Test results include test outcomes, coverage analysis, and AI-suggested fixes.

## Files

### test-results-2026-01-23T21:00:00Z.md
- **Created**: 2026-01-23T21:00:00Z
- **Description**: Test results for feature ai-coding-workflow-system
- **Link**: [test-results-2026-01-23T21:00:00Z.md](./test-results-2026-01-23T21:00:00Z.md)

## Navigation
- [Back to Root](../)
- [Features](../features/)
- [Reviews](../reviews/)
```

## Error Handling

### If INDEX.md doesn't exist
- Create new INDEX.md with appropriate template
- Include overview and navigation sections
- Add first file entry

### If directory doesn't exist
- Create directory first
- Then create INDEX.md
- Report permission errors if unable to create

### If file already in index
- Compare timestamps
- Update entry if file was modified
- Skip if unchanged

### If INDEX.md is corrupted
- Detect corruption (invalid markdown structure)
- Backup existing file to INDEX.md.backup
- Regenerate from directory contents
- Log the recovery action

## Usage Examples

### Adding a Prime export

```
/update-index directory="context" filename="prime-2026-01-23T14:30:00Z.md" description="Codebase export from Prime command" timestamp="2026-01-23T14:30:00Z"
```

### Adding a feature directory

```
/update-index directory="features" filename="ai-coding-workflow-system" description="AI Coding Workflow System feature" is_directory=true status="Planning phase" artifacts="prd.md, tech-spec.md"
```

### Regenerating entire INDEX.md

```
/update-index directory="context" regenerate=true
```

## Validation

After updating INDEX.md:
- [ ] File was created or updated successfully
- [ ] New entry appears in correct location (chronological order)
- [ ] Markdown formatting is correct
- [ ] Navigation links are valid
- [ ] Description is accurate
- [ ] Timestamp is in ISO 8601 format

## Notes

- Use ISO 8601 format for timestamps: YYYY-MM-DDTHH:mm:ssZ
- Sort entries newest first (except templates/ which is alphabetical)
- Use relative paths for navigation links
- Extract description from file frontmatter when possible
- Call this command after any file creation operation
```

### .claude\\commands\\update-status.md
`$(@{Path=.claude\\commands\\update-status.md; Language=markdown; Lines=System.Object[]}.Language)
---
name: update-status
description: Update STATUS.md file with phase progress, artifacts, and next steps
phase: utility
inputs:
  - feature_path: Path to feature directory (e.g., "features/ai-coding-workflow-system")
  - action: Action to perform - create, update-phase, add-artifact, update-next-steps, update-checkpoint
  - phase: Phase name to update (Prime, Discovery, Planning, Development, Task Planning, Execution, Review, Test)
  - completed: Whether phase is completed (true/false)
  - set_current: Whether to set as current phase (true/false)
  - artifact_name: Name of artifact file to add
  - artifact_description: Description of artifact (optional)
  - next_steps: Description of next steps
  - task_id: ID or description of last completed task (for checkpoint)
outputs:
  - Updated STATUS.md file
dependencies:
  - Feature directory must exist
  - STATUS.md may or may not exist (will create if missing)
---

# Update STATUS Command

## Purpose

Update or create STATUS.md files to track feature development progress through all phases of the workflow.

## When to Use

Use this command during feature development:
- After Planning command creates feature directory (create STATUS.md)
- After any phase completes (mark phase as completed)
- After generating artifacts (add artifact to STATUS.md)
- Before starting next phase (update next steps)
- After completing tasks (update checkpoint)

## Execution Steps

### Step 1: Determine Action

Extract action from command context:
- `create`: Create new STATUS.md from template
- `update-phase`: Mark phase as completed and/or set current phase
- `add-artifact`: Add generated artifact to STATUS.md
- `update-next-steps`: Update next steps description
- `update-checkpoint`: Update checkpoint timestamp and last completed task

### Step 2: Read Existing STATUS.md

If action is not `create`:
1. Check if `{feature_path}/STATUS.md` exists
2. If exists, read current content
3. Parse current phase, completed phases, artifacts

### Step 3: Perform Action

#### Action: create

1. Create STATUS.md from template
2. Replace {feature-name} with actual feature name
3. Replace {timestamp} with current timestamp
4. Set initial phase (default: Planning)
5. All phases marked as incomplete

#### Action: update-phase

1. Update specified phase checkbox: `- [ ]` to `- [x]` if completed=true
2. If set_current=true, update Current Phase to specified phase
3. Update checkpoint timestamp
4. Validate phase order (can't skip phases unless resuming)

Phase order: Prime â†’ Discovery â†’ Planning â†’ Development â†’ Task Planning â†’ Execution â†’ Review â†’ Test

#### Action: add-artifact

1. Add artifact to Generated Artifacts section
2. Remove from Pending Artifacts section
3. Include creation timestamp
4. Format: `- `{artifact_name}` - Created: {timestamp} - {description}`

#### Action: update-next-steps

1. Update Next Steps section
2. Provide clear, actionable next steps
3. Update checkpoint timestamp

#### Action: update-checkpoint

1. Update Checkpoint section
2. Set Last updated timestamp
3. Set Last completed task

## STATUS.md Format

```markdown
# Feature: {feature-name}

## Current Phase
{current-phase}

## Progress

### Completed Phases
- [x] Prime
- [x] Discovery
- [ ] Planning
- [ ] Development
- [ ] Task Planning
- [ ] Execution
- [ ] Review
- [ ] Test

## Artifacts

### Generated Artifacts
- `prd.md` - Created: 2026-01-23T16:00:00Z
- `tech-spec.md` - Created: 2026-01-23T17:00:00Z
- `prp.md` - Created: 2026-01-23T18:00:00Z
- `task-plan.md` - Created: 2026-01-23T18:30:00Z

### Pending Artifacts
- `execution.md` - To be created in Execution phase
- `review.md` - To be created in Review phase
- `test-results.md` - To be created in Test phase

## Next Steps
{description of next steps}

## Checkpoint
Last updated: 2026-01-23T18:30:00Z
Last completed task: Generated task plan with 12 tasks
```

## Usage Examples

### Create STATUS.md for new feature

```
/update-status feature_path="features/ai-coding-workflow-system" action="create" phase="Planning"
```

### Mark Planning phase complete, set Development as current

```
/update-status feature_path="features/ai-coding-workflow-system" action="update-phase" phase="Planning" completed=true set_current=false
/update-status feature_path="features/ai-coding-workflow-system" action="update-phase" phase="Development" completed=false set_current=true
```

### Add PRD artifact

```
/update-status feature_path="features/ai-coding-workflow-system" action="add-artifact" artifact_name="prd.md" artifact_description="Product Requirements Document"
```

### Update next steps

```
/update-status feature_path="features/ai-coding-workflow-system" action="update-next-steps" next_steps="Generate tech spec from PRD"
```

### Update checkpoint after task completion

```
/update-status feature_path="features/ai-coding-workflow-system" action="update-checkpoint" task_id="Created directory structure"
```

## Phase Definitions

| Phase | Description | Artifacts |
|-------|-------------|-----------|
| Prime | Codebase context export | context/prime-*.md |
| Discovery | Ideas and opportunities | discovery/discovery-*.md |
| Planning | PRD generation | prd.md |
| Development | Tech spec generation | tech-spec.md |
| Task Planning | PRP and tasks | prp.md, task-plan.md |
| Execution | Task implementation | execution.md |
| Review | Code review | review.md |
| Test | Test execution | test-results.md |

## Error Handling

### If STATUS.md doesn't exist
- Create new STATUS.md from template
- Initialize with specified phase
- Set all phases as incomplete

### If STATUS.md is corrupted
- Detect corruption (missing sections, invalid format)
- Backup existing file to STATUS.md.backup
- Regenerate STATUS.md from template
- Attempt to recover phase/artifact data from backup

### If phase update fails
- Verify phase name is valid
- Check STATUS.md format
- Validate phase order
- Log error and continue

### If feature directory doesn't exist
- Create directory first
- Then create STATUS.md
- Report permission errors if unable to create

## Validation

After updating STATUS.md:
- [ ] File was created or updated successfully
- [ ] Current phase is correct
- [ ] Completed phases are marked with [x]
- [ ] Artifacts listed correctly
- [ ] Next steps are clear and actionable
- [ ] Checkpoint timestamp is current
- [ ] Phase order is valid

## Integration with Commands

### Planning Command
After creating feature directory and generating PRD:
```
/update-status feature_path="features/{feature-name}" action="create" phase="Planning"
/update-status feature_path="features/{feature-name}" action="add-artifact" artifact_name="prd.md"
/update-status feature_path="features/{feature-name}" action="update-phase" phase="Planning" completed=true set_current=false
/update-status feature_path="features/{feature-name}" action="update-phase" phase="Development" completed=false set_current=true
```

### Development Command
After generating tech-spec:
```
/update-status feature_path="features/{feature-name}" action="add-artifact" artifact_name="tech-spec.md"
/update-status feature_path="features/{feature-name}" action="update-phase" phase="Development" completed=true set_current=false
/update-status feature_path="features/{feature-name}" action="update-phase" phase="Task Planning" completed=false set_current=true
```

### Task Planning Command
After generating PRP and task-plan:
```
/update-status feature_path="features/{feature-name}" action="add-artifact" artifact_name="prp.md"
/update-status feature_path="features/{feature-name}" action="add-artifact" artifact_name="task-plan.md"
/update-status feature_path="features/{feature-name}" action="update-phase" phase="Task Planning" completed=true set_current=false
/update-status feature_path="features/{feature-name}" action="update-phase" phase="Execution" completed=false set_current=true
```

## Notes

- Use ISO 8601 format for timestamps: YYYY-MM-DDTHH:mm:ssZ
- Phase names must match exactly (case-sensitive)
- Checkboxes use markdown format: `- [ ]` for incomplete, `- [x]` for complete
- Next steps should be specific and actionable
- Checkpoint enables error recovery and resume functionality
- STATUS.md serves as single source of truth for feature progress
```

### .claude\\commands\\workflow.md
`$(@{Path=.claude\\commands\\workflow.md; Language=markdown; Lines=System.Object[]}.Language)
---
name: Workflow
description: "Unified workflow command for complete development lifecycle"
phase: workflow
dependencies: [prime, discovery, planning, development, task-planning, execution, review, test]
outputs:
  - path: "features/{feature-name}/STATUS.md"
    description: "Updated feature status tracking file after each phase"
inputs:
  - path: "features/{feature-name}/STATUS.md"
    description: "Feature status tracking file for resume support"
    required: false
---

# Workflow Command

## Purpose

Execute the complete development lifecycle by running all phases sequentially. This command orchestrates Prime, Discovery, Planning, Development, Task Planning, Execution, Review, and Test phases with progress tracking, error handling, and resume support.

**When to use**: Use this command to execute the entire workflow from start to finish, or to resume from a specific phase after an error.

**What it solves**: This command addresses the need for a single unified command that automates the complete development lifecycle with error recovery and progress tracking.

## Prerequisites

- All phase commands must exist (prime, discovery, planning, development, task-planning, execution, review, test)
- Archon MCP server should be available (recommended)
- Web MCP servers should be available (recommended)

## Execution Steps

### Step 1: Parse Arguments

**Objective**: Parse command arguments.

**Actions**:
1. Parse `/workflow <feature-name> [--from-<phase>]`
2. Extract feature name (required)
3. Extract `--from-<phase>` option (optional)
4. Validate feature name (kebab-case)
5. Validate phase name if provided

**Valid phases**: `prime`, `discovery`, `planning`, `development`, `task-planning`, `execution`, `review`, `test`

### Step 2: Determine Starting Phase

**Objective**: Determine which phase to start from.

**Actions**:
1. If `--from-<phase>` provided: Use that as starting phase
2. Else if STATUS.md exists: Resume from next incomplete phase
3. Else: Start from Prime (first phase)
4. Validate dependencies are met for starting phase

**Phase Order**: Prime â†’ Discovery â†’ Planning â†’ Development â†’ Task Planning â†’ Execution â†’ Review â†’ Test

### Step 3: Execute Phases Sequentially

**Objective**: Execute each phase in order.

**Actions**:
For each phase starting from determined phase:
1. Check if phase already completed (skip if done)
2. Execute phase command:
   - Prime: `/prime`
   - Discovery: `/discovery`
   - Planning: `/planning {feature-name}`
   - Development: `/development {feature-name}`
   - Task Planning: `/task-planning {feature-name}`
   - Execution: `/execution {feature-name}`
   - Review: `/review {feature-name}`
   - Test: `/test {feature-name}`
3. Wait for completion
4. Update STATUS.md on success
5. On error: Log, create checkpoint, stop, allow resume

### Step 4: Progress Feedback

**Objective**: Provide progress feedback.

**Actions**:
1. Log phase start: "Starting phase {phase}..."
2. Log phase completion: "Phase {phase} completed ({duration})"
3. Log progress: "{completed}/{total} phases ({percentage}%)"
4. Update STATUS.md checkpoint

### Step 5: Error Recovery

**Objective**: Handle errors gracefully.

**Actions**:
1. Detect phase failure
2. Log error to console and STATUS.md
3. Create checkpoint
4. Provide resume command: `/workflow {feature-name} --from-{phase}`
5. Stop execution

## Output Format

**Console Output**:
```
[Workflow] Starting workflow for feature: {feature-name}
[Workflow] Starting phase: prime
[Workflow] Phase prime completed (2m 30s)
[Workflow] Progress: 1/8 phases (12.5%)
[Workflow] Starting phase: discovery
[Workflow] Phase discovery completed (1m 45s)
[Workflow] Progress: 2/8 phases (25%)
...
[Workflow] Workflow completed successfully!
[Workflow] Total duration: 45m 20s
[Workflow] Artifacts generated:
  - context/prime-{timestamp}.md
  - discovery/discovery-{timestamp}.md
  - features/{feature-name}/prd.md
  - features/{feature-name}/tech-spec.md
  - features/{feature-name}/prp.md
  - features/{feature-name}/task-plan.md
  - features/{feature-name}/execution.md
  - features/{feature-name}/review.md
  - features/{feature-name}/test-results.md
```

**Error Output**:
```
[Workflow] Error in phase {phase}:
{error_message}

[Workflow] To resume, run:
/workflow {feature-name} --from-{phase}

[Workflow] Checkpoint saved to STATUS.md
```

## Usage Examples

### Full Workflow

**Command**: `/workflow my-feature`

**Output**: Executes all 8 phases from Prime to Test

### Resume from Phase

**Command**: `/workflow my-feature --from-development`

**Output**: Starts from Development phase, continues through Test

## Error Handling

### Invalid Arguments
- Error: "Invalid arguments. Usage: /workflow <feature-name> [--from-<phase>]"

### Invalid Phase
- Error: "Invalid phase: {phase}. Valid phases: prime, discovery, planning, development, task-planning, execution, review, test"

### Dependencies Not Met
- Error: "Cannot resume from {phase}. Required phases {dependencies} must be completed first."

### Phase Execution Fails
- Log error
- Create checkpoint
- Provide resume command
- Stop execution

## Notes

- **Skip completed phases**: Workflow automatically skips phases already marked as completed in STATUS.md
- **Checkpoint system**: STATUS.md is updated after each phase for resume support
- **Progress tracking**: Real-time progress feedback provided throughout execution
- **Error recovery**: Resume from any failed phase using `--from-{phase}` option
- **Duration**: Total duration varies by feature complexity (typically 30-60 minutes)
- **Phase dependencies**: Each phase requires previous phases to complete first

## Phase Reference

| Phase | Command | Duration | Dependencies |
|-------|----------|----------|--------------|
| Prime | `/prime` | 2-5 min | None |
| Discovery | `/discovery` | 1-2 min | prime |
| Planning | `/planning {feature}` | 2-3 min | discovery |
| Development | `/development {feature}` | 1-2 min | planning |
| Task Planning | `/task-planning {feature}` | 3-5 min | development |
| Execution | `/execution {feature}` | varies | task-planning |
| Review | `/review {feature}` | 2-3 min | execution |
| Test | `/test {feature}` | varies | execution |
```

### .claude\\settings.json
`$(@{Path=.claude\\settings.json; Language=json; Lines=System.Object[]}.Language)
{
    "env": {
      "ANTHROPIC_AUTH_TOKEN": "40082ad32d534c688c9552af710a28a1.TtTTpL7Er0Y12jtK",
      "ANTHROPIC_BASE_URL": "https://api.z.ai/api/anthropic",
      "API_TIMEOUT_MS": "3000000",
      "ANTHROPIC_DEFAULT_OPUS_MODEL": "GLM-4.7",
      "ANTHROPIC_DEFAULT_SONNET_MODEL": "GLM-4.7",
      "ANTHROPIC_DEFAULT_HAIKU_MODEL": "GLM-4.5-Air"
    }
  }
```

### .claude\\settings.local.json
`$(@{Path=.claude\\settings.local.json; Language=json; Lines=System.Object[]}.Language)
{
  "permissions": {
    "allow": [
      "Bash(git clone:*)",
      "Bash(tree:*)",
      "Bash(claude mcp add:*)",
      "Bash(curl:*)",
      "Bash(ls:*)",
      "Bash(chmod:*)",
      "WebSearch",
      "mcp__archon__health_check",
      "mcp__archon__find_tasks",
      "mcp__archon__find_projects",
      "mcp__archon__manage_project",
      "mcp__archon__manage_task",
      "Bash(dir:*)",
      "Bash(echo:*)",
      "Bash(find:*)",
      "Bash(findstr /v /i \"node_modules .git .venv __pycache__ .pytest_cache\")",
      "Bash(powershell:*)",
      "Bash(del:*)",
      "mcp__archon__rag_search_knowledge_base",
      "Bash(git add:*)",
      "Bash(git commit -m \"$\\(cat <<''EOF''\nImplement Smart Reference Library with /learn and /learn-health commands\n\n- Add /learn command: Search RAG/web, digest insights, store to archon_references\n- Add /learn-health command: Check library health and category statistics\n- Add /workflow command: Unified workflow execution with resume support\n- Add /update-index and /update-status utility commands\n- Create PRP templates \\(base, AI agent, MCP integration, API endpoint, frontend\\)\n- Implement Smart Reference Library feature with token-efficient selective loading\n- Update PRP base template with Reference Library section for selective loading\n- Update CLAUDE.md with Reference Library documentation\n- Add root documentation: INDEX.md, MVP.md, PRD.md, TECH-SPEC.md, README.md\n- Add context exports \\(3 prime snapshots\\) and discovery documents\n- Add execution task breakdown \\(28 tasks\\) and feature tracking\n\nArchon Project ID: acf45b67-51aa-475d-b4cc-7c1055b4a032\nAll 7 tasks completed successfully.\n\nCo-Authored-By: Claude <noreply@anthropic.com>\nEOF\n\\)\")",
      "Bash(git push:*)",
      "Bash(gh:*)",
      "Bash(git commit:*)",
      "mcp__web-reader__webReader",
      "mcp__web-search-prime__webSearchPrime",
      "mcp__archon__rag_get_available_sources",
      "Bash(findstr:*)",
      "mcp__supabase__execute_sql"
    ]
  },
  "enableAllProjectMcpServers": true,
  "enabledMcpjsonServers": [
    "supabase"
  ]
}
```

### .claude\\templates\\STATUS.md
`$(@{Path=.claude\\templates\\STATUS.md; Language=markdown; Lines=System.Object[]}.Language)
# Feature: {feature-name}

## Current Phase
Planning

## Progress

### Completed Phases
- [ ] Prime
- [ ] Discovery
- [ ] Planning
- [ ] Development
- [ ] Task Planning
- [ ] Execution
- [ ] Review
- [ ] Test

## Artifacts

### Generated Artifacts
_No artifacts generated yet._

### Pending Artifacts
- `prd.md` - To be created in Planning phase
- `tech-spec.md` - To be created in Development phase
- `prp.md` - To be created in Task Planning phase
- `task-plan.md` - To be created in Task Planning phase
- `execution.md` - To be created in Execution phase
- `review.md` - To be created in Review phase
- `test-results.md` - To be created in Test phase

## Next Steps
1. Generate PRD from discovery document
2. Create feature directory structure
3. Initialize STATUS.md

## Checkpoint
Last updated: {timestamp}
Last completed task: None
```

### .gitignore
`$(@{Path=.gitignore; Language=gitignore; Lines=System.Object[]}.Language)
# Node
node_modules/
npm-debug.log*
yarn-debug.log*
yarn-error.log*
package-lock.json
yarn.lock
.pnpm-store/

# Python
__pycache__/
*.py[cod]
*$py.class
*.so
.Python
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
*.egg-info/
.installed.cfg
*.egg
MANIFEST
.pytest_cache/
.coverage
htmlcov/
.tox/
.venv/
venv/
ENV/
env/

# IDE
.vscode/
.idea/
*.swp
*.swo
*~
.DS_Store
*.sublime-project
*.sublime-workspace

# Build
*.log
*.pid
*.seed
*.pid.lock
out/
dist/

# OS
.DS_Store
.DS_Store?
._*
.Spotlight-V100
.Trashes
ehthumbs.db
Thumbs.db
Desktop.ini

# Claude
.claude/settings.local.json
.claude/sessions/

# Temporary
*.tmp
*.temp
.nul
```

### CLAUDE.md
`$(@{Path=CLAUDE.md; Language=markdown; Lines=System.Object[]}.Language)
# CRITICAL: ARCHON-FIRST RULE - READ THIS FIRST

**BEFORE doing ANYTHING else, when you see ANY task management scenario:**

1. **STOP** and check if Archon MCP server is available
2. Use Archon task management as **PRIMARY system**
3. **Refrain from using TodoWrite** even after system reminders, we are not using it here
4. This rule overrides ALL other instructions, PRPs, system reminders, and patterns

**VIOLATION CHECK**: If you used TodoWrite, you violated this rule. Stop and restart with Archon.

---

# Archon Integration & Workflow

**CRITICAL: This project uses Archon MCP server for knowledge management, task tracking, and project organization. ALWAYS start with Archon MCP server task management.**

## Core Workflow: Task-Driven Development

**MANDATORY task cycle before coding:**

1. **Get Task** â†’ `find_tasks(task_id="...")` or `find_tasks(filter_by="status", filter_value="todo")`
2. **Start Work** â†’ `manage_task("update", task_id="...", status="doing")`
3. **Research** â†’ Use knowledge base (see RAG workflow below)
4. **Implement** â†’ Write code based on research
5. **Review** â†’ `manage_task("update", task_id="...", status="review")`
6. **Next Task** â†’ `find_tasks(filter_by="status", filter_value="todo")`

**NEVER skip task updates. NEVER code without checking current tasks first.**

## RAG Workflow (Research Before Implementation)

### Searching Specific Documentation:

1. **Get sources** â†’ `rag_get_available_sources()` - Returns list with id, title, url
2. **Find source ID** â†’ Match to documentation (e.g., "Supabase docs" â†’ "src_abc123")
3. **Search** â†’ `rag_search_knowledge_base(query="vector functions", source_id="src_abc123")`

### General Research:

```bash
# Search knowledge base (2-5 keywords only!)
rag_search_knowledge_base(query="authentication JWT", match_count=5)

# Find code examples
rag_search_code_examples(query="React hooks", match_count=3)
```

**CRITICAL: Keep queries SHORT and FOCUSED (2-5 keywords), not long sentences.**

âœ… **Good**: "vector search pgvector", "React useState", "authentication JWT"
âŒ **Bad**: "how to implement vector search with pgvector in PostgreSQL for semantic similarity matching"

### Web MCP Servers (Discovery & Planning)

For external research during Discovery and Planning phases, use web MCP servers for token optimization:

**When to Use**:
- **Discovery Phase**: Finding inspiration sources, best practices, AI agent patterns
- **Planning Phase**: Researching PRD templates, architecture patterns, technology decisions
- **Token Optimization**: When you need multiple web searches or content extraction

**Available Tools**:
- `web_search_prime_search` - Enhanced web search (Discovery/Planning)
- `web_reader_read` - Read and extract content from web pages (Discovery/Planning)
- `zread_read` - Advanced web content reading and analysis (Discovery/Planning)

**Usage Pattern**:
```bash
# 1. Search for inspiration/examples
web_search_prime_search(query="AI agent patterns", ...)

# 2. Read relevant pages
web_reader_read(url="...")  # or zread_read(url="...")

# 3. Combine with RAG knowledge base results
rag_search_knowledge_base(query="similar patterns", ...)
```

**Fallback**: If web MCP servers unavailable, use Claude's built-in web search (may consume more tokens).

## Project Workflows

### New Project:

```bash
# 1. Create project
manage_project("create", title="My Feature", description="...")

# 2. Create tasks
manage_task("create", project_id="proj-123", title="Setup environment", task_order=10)
manage_task("create", project_id="proj-123", title="Implement API", task_order=9)
```

### Existing Project:

```bash
# 1. Find project
find_projects(query="auth")  # or find_projects() to list all

# 2. Get project tasks
find_tasks(filter_by="project", filter_value="proj-123")

# 3. Continue work or create new tasks
```

## Tool Reference

### Projects:

- `find_projects(query="...")` - Search projects
- `find_projects(project_id="...")` - Get specific project
- `manage_project("create"/"update"/"delete", title="...", description="...", github_repo="...")` - Manage projects

### Tasks:

- `find_tasks(query="...")` - Search tasks by keyword
- `find_tasks(task_id="...")` - Get specific task (returns full details)
- `find_tasks(filter_by="status"/"project"/"assignee", filter_value="...")` - Filter tasks
- `manage_task("create"/"update"/"delete", task_id="...", project_id="...", title="...", description="...", status="...", assignee="...", task_order=...)` - Manage tasks

**Task Status Flow**: `todo` â†’ `doing` â†’ `review` â†’ `done`

**Task Granularity**:
- For feature-specific projects: Create detailed implementation tasks (setup, implement, test, document)
- For codebase-wide projects: Create feature-level tasks
- Each task should represent 30 minutes to 4 hours of work
- Higher `task_order` = higher priority (0-100)

### Knowledge Base (RAG):

- `rag_get_available_sources()` - List all available knowledge sources
- `rag_search_knowledge_base(query="...", source_id="...", match_count=5, return_mode="pages")` - Search knowledge base
- `rag_search_code_examples(query="...", source_id="...", match_count=5)` - Find code examples
- `rag_list_pages_for_source(source_id="...", section="...")` - List pages in a source
- `rag_read_full_page(page_id="..." | url="...")` - Read complete page content

### Documents:

- `find_documents(project_id="...", document_id="...", query="...", document_type="...")` - Find documents
- `manage_document("create"/"update"/"delete", project_id="...", document_id="...", title="...", document_type="...", content="...", tags="...")` - Manage documents

### Other Tools:

- `health_check()` - Check MCP server health
- `session_info()` - Get session information

## MCP Server Health & Fallback

### Checking Server Availability

**Before starting work, verify Archon MCP is available:**

```bash
# Check Archon MCP health
health_check()  # Should return healthy status
```

**If Archon MCP is unavailable:**
1. **Inform user** that Archon MCP is unavailable
2. **Ask user** if they want to proceed with limited functionality or wait
3. **Do NOT use TodoWrite** - wait for Archon MCP to be available
4. **Document the issue** in your response

**If Web MCP servers are unavailable:**
- Use Claude's built-in web search as fallback
- Inform user that advanced web features may be limited
- Continue with available functionality

### Fallback Behavior

**Archon MCP Unavailable**:
- **DO NOT** fall back to TodoWrite (per ARCHON-FIRST RULE)
- **STOP** and inform user
- **WAIT** for Archon MCP to be available before proceeding

**Web MCP Servers Unavailable**:
- Use Claude's built-in web search
- May consume more tokens
- Continue with available functionality

## Important Notes

- **Task status flow**: `todo` â†’ `doing` â†’ `review` â†’ `done`
- **Keep queries SHORT** (2-5 keywords) for better search results
- **Higher `task_order`** = higher priority (0-100)
- **Tasks should be 30 min - 4 hours** of work
- **Only ONE task in 'doing' status** at a time
- **Use 'review'** for completed work awaiting validation
- **Mark tasks 'done'** only after verification

## Development Principles

### YAGNI (You Aren't Gonna Need It)

- **Don't implement features that are not needed**
- Focus on current requirements, not future possibilities
- Avoid over-engineering and premature optimization
- Build only what's necessary for current task

### KISS (Keep It Simple, Stupid)

- Prefer simple solutions over complex ones
- Avoid unnecessary abstractions
- Write code that's easy to understand and maintain

### DRY (Don't Repeat Yourself)

- Extract common patterns when appropriate
- Reuse code and components
- But don't over-abstract - balance with YAGNI

## Documentation Standards

**CRITICAL: Apply YAGNI/KISS to all documentation**

- **Line Limits**: MVP, PRD, TECH-SPEC must be 500-600 lines max (fewer is better)
- **YAGNI**: Only document what's needed NOW, remove verbose explanations, examples, and non-essential content
- **KISS**: Use simple, direct language. Remove marketing fluff, redundant sections, and verbose descriptions
- **Focus**: Keep only essential technical details, requirements, and implementation guidance
- **When Creating/Updating Docs**: Always trim unnecessary content, condense verbose sections, remove redundant information

## Error Handling

**When errors occur:**

1. **Stop and assess** - Don't continue with broken state
2. **Inform user clearly** - Explain what went wrong and why
3. **Suggest recovery** - Provide actionable next steps
4. **Preserve work** - Don't lose progress; checkpoint if possible
5. **Learn from errors** - Document patterns to avoid repetition

**Common Error Scenarios**:
- **MCP server unavailable**: Check health, inform user, wait for availability
- **Task not found**: Verify task ID, check project context, ask user
- **File operation failed**: Check permissions, verify path, inform user
- **RAG search returns no results**: Try broader query, check source availability

**Error Recovery Pattern**:
```bash
# 1. Attempt operation
# 2. If error, check health/availability
# 3. Inform user with context
# 4. Suggest alternative or wait
# 5. Retry when conditions met
```

---

## AI Coding Workflow System Commands

This project uses a markdown-based command system for orchestrating AI-assisted development workflows.

### Available Commands:

- `/prime` - Export codebase for context gathering
- `/discovery` - Explore ideas and opportunities
- `/planning {feature-name}` - Generate PRD
- `/development {feature-name}` - Generate Tech Spec
- `/task-planning {feature-name}` - Create PRP and tasks
- `/execution {feature-name}` - Execute tasks
- `/review {feature-name}` - Code review
- `/test {feature-name}` - Run tests
- `/workflow {feature-name}` - Execute full workflow

See `PRD.md` and `TECH-SPEC.md` for detailed command documentation.

## Reference Library

The Smart Reference Library stores digested coding insights in Supabase (`archon_references` table) for token-efficient context loading.

### Available Commands:

- `/learn {topic}` - Search RAG/web, digest findings, and store approved insights
- `/learn-health` - Check library health and category statistics

### How It Works:

1. **Building the Library**: Run `/learn {topic}` to search, digest, and save insights
2. **Health Tracking**: Run `/learn-health` to see which categories need attention
3. **Selective Loading**: PRPs specify required categories, only those load into context

### Standard Categories:

- `python` - Python patterns, libraries, best practices
- `mcp` - MCP server development
- `react` - React, Next.js, hooks
- `typescript` - TypeScript/JavaScript patterns
- `ai-agents` - AI agent patterns, prompting
- `testing` - Testing patterns, frameworks
- `patterns` - General design patterns
- `supabase` - Supabase/database patterns
- `api` - API design, REST, GraphQL

### Selective Loading:

**IMPORTANT**: References are NOT preloaded in this document. Only references specified in PRP's "Reference Library" section load into context.

**PRP Example**:
```markdown
### Reference Library
**Required Categories**: python, mcp
**Optional Tags**: async, testing
```

**Loading Flow**:
1. PRP specifies categories: `["python", "mcp"]`
2. Query: `SELECT * FROM archon_references WHERE category = 'python' OR 'mcp' = ANY(tags)`
3. Only matching references load into context
4. Context stays lean and relevant

### Usage Examples:

```bash
# Learn Python async patterns
/learn python async patterns

# Check library health
/learn-health

# Learn React hooks
/learn react hooks
```

## PRP Template Usage

**During Task Execution, always reference PRP documents:**

1. **Load PRP** â†’ Read `features/{feature-name}/prp.md` before starting implementation
2. **Follow Blueprint** â†’ Use PRP's "Implementation Blueprint" section for step-by-step guidance
3. **Reference Patterns** â†’ Follow codebase patterns documented in PRP
4. **Check Gotchas** â†’ Review "Known Gotchas" section to avoid common pitfalls
5. **Validate** â†’ Use PRP's "Validation Loop" commands for quality checks

**PRP Structure Reference**:
- **Goal**: What you're building and success criteria
- **All Needed Context**: Documentation, codebase patterns, file references
- **Implementation Blueprint**: Ordered tasks with dependencies
- **Validation Loop**: Syntax, unit tests, integration tests

**If PRP doesn't exist**:
- Run `/task-planning {feature-name}` first to generate PRP
- Or ask user if they want to proceed without PRP (not recommended)

## Decision-Making Framework

**When to proceed autonomously:**
- âœ… Task is clear from PRP/context
- âœ… Implementation pattern is established
- âœ… No ambiguity in requirements
- âœ… Standard file operations (create/edit within feature scope)
- âœ… Following existing codebase patterns

**When to ask user:**
- â“ Requirements are ambiguous or conflicting
- â“ Multiple valid approaches exist and choice matters
- â“ Breaking changes or major refactoring needed
- â“ External dependencies or configuration required
- â“ User preferences or business logic decisions needed
- â“ MCP server unavailable (critical blocker)

**Decision Rule**: If unsure, **ask**. Better to clarify than assume incorrectly.

---

## When Working with This Codebase

1. **Always check Archon MCP first** for tasks and projects
2. **Research before implementing** using RAG knowledge base
3. **Load PRP document** before starting implementation (if available)
4. **Update task status** as you work (todo â†’ doing â†’ review â†’ done)
5. **Follow YAGNI** - don't build what isn't needed
6. **Follow KISS** - keep it simple, prefer straightforward solutions over complex ones
7. **Use workflow commands** for structured development
8. **Check MCP server health** if operations fail unexpectedly

### File Modification Guidelines

**Safe to edit autonomously:**
- Files within `features/{feature-name}/` directory (current feature scope)
- New files being created as part of current task
- Documentation files (README, STATUS.md) for current feature
- Test files for current feature

**Ask before editing:**
- Files outside current feature directory
- Core system files (commands, templates, root configs)
- Files shared across multiple features
- Breaking changes or major refactoring
- User's explicitly open/visible files (unless task requires it)

**File Operation Best Practices:**
- Read file first to understand context
- Preserve existing patterns and style
- Make minimal, focused changes
- Document why changes were made (in commit messages or comments)

---

**Remember**: Archon MCP is PRIMARY task management system. Never use TodoWrite. Always start with Archon.
```

### context\\INDEX.md
`$(@{Path=context\\INDEX.md; Language=markdown; Lines=System.Object[]}.Language)
# Context Index

## Overview
This directory contains codebase context exports from the Prime command. Each export is a complete snapshot of the codebase at a specific point in time, including file tree structure and file contents.

## Files

### prime-2026-01-24T17-32-08Z.md
- **Created**: 2026-01-24T17:32:08Z
- **Description**: Complete codebase export from Prime command
- **File Count**: 74 files
- **Total Lines**: ~14239 lines
- **Link**: [View Export](./prime-2026-01-24T17-32-08Z.md)

### prime-2026-01-24T20-31-03Z.md
- **Created**: 2026-01-24T20:31:03Z
- **Description**: Complete codebase export from Prime command
- **File Count**: 97 files
- **Total Lines**: ~15,000 lines
- **Link**: [View Export](./prime-2026-01-24T20-31-03Z.md)

### prime-2026-01-24T18-21-11Z.md
- **Created**: 2026-01-24T18:21:11Z
- **Description**: Complete codebase export from Prime command
- **File Count**: 27 files
- **Total Lines**: ~3,500 lines
- **Link**: [View Export](./prime-2026-01-24T18-21-11Z.md)

### prime-2026-01-24T09-32-50Z.md
- **Created**: 2026-01-24T09:32:50Z
- **Description**: Complete codebase export from Prime command
- **File Count**: 47 files
- **Total Lines**: ~4,200 lines
- **Link**: [View Export](./prime-2026-01-24T09-32-50Z.md)

## Navigation
- [Back to Root](../)
- [Discovery](../discovery/)
- [Features](../features/)
```

### context\\prime-2026-01-24T09-32-50Z.md
`$(@{Path=context\\prime-2026-01-24T09-32-50Z.md; Language=markdown; Lines=System.Object[]}.Language)
# Codebase Export: 2026-01-24T09:32:50Z

**Generated**: 2026-01-24T09:32:50Z
**Export Type**: Full Codebase
**Total Files**: 47 files
**Total Lines**: ~4,200 lines

## Project Tree

```
AI Overload/
â”œâ”€â”€ .claude/
â”‚   â”œâ”€â”€ commands/
â”‚   â”‚   â”œâ”€â”€ prime.md
â”‚   â”‚   â”œâ”€â”€ discovery.md
â”‚   â”‚   â”œâ”€â”€ planning.md
â”‚   â”‚   â”œâ”€â”€ development.md
â”‚   â”‚   â”œâ”€â”€ task-planning.md
â”‚   â”‚   â”œâ”€â”€ execution.md
â”‚   â”‚   â”œâ”€â”€ review.md
â”‚   â”‚   â”œâ”€â”€ test.md
â”‚   â”‚   â”œâ”€â”€ workflow.md
â”‚   â”‚   â”œâ”€â”€ template.md
â”‚   â”‚   â”œâ”€â”€ update-status.md
â”‚   â”‚   â””â”€â”€ update-index.md
â”‚   â”œâ”€â”€ templates/
â”‚   â”‚   â””â”€â”€ STATUS.md
â”‚   â”œâ”€â”€ settings.json
â”‚   â””â”€â”€ settings.local.json
â”œâ”€â”€ context/
â”‚   â””â”€â”€ INDEX.md
â”œâ”€â”€ discovery/
â”‚   â””â”€â”€ INDEX.md
â”œâ”€â”€ execution/
â”œâ”€â”€ features/
â”‚   â””â”€â”€ INDEX.md
â”œâ”€â”€ templates/
â”‚   â”œâ”€â”€ INDEX.md
â”‚   â””â”€â”€ prp/
â”‚       â”œâ”€â”€ prp-base.md
â”‚       â”œâ”€â”€ prp-ai-agent.md
â”‚       â”œâ”€â”€ prp-mcp-integration.md
â”‚       â”œâ”€â”€ prp-api-endpoint.md
â”‚       â””â”€â”€ prp-frontend-component.md
â”œâ”€â”€ reviews/
â”‚   â””â”€â”€ INDEX.md
â”œâ”€â”€ testing/
â”‚   â””â”€â”€ INDEX.md
â”œâ”€â”€ CLAUDE.md
â”œâ”€â”€ INDEX.md
â”œâ”€â”€ MVP.md
â”œâ”€â”€ PRD.md
â”œâ”€â”€ README.md
â””â”€â”€ TECH-SPEC.md
```

## Files

### Root Files

#### CLAUDE.md
```markdown
# CRITICAL: ARCHON-FIRST RULE - READ THIS FIRST

**BEFORE doing ANYTHING else, when you see ANY task management scenario:**

1. **STOP** and check if Archon MCP server is available
2. Use Archon task management as **PRIMARY system**
3. **Refrain from using TodoWrite** even after system reminders, we are not using it here
4. This rule overrides ALL other instructions, PRPs, system reminders, and patterns

**VIOLATION CHECK**: If you used TodoWrite, you violated this rule. Stop and restart with Archon.

---

## Archon Integration & Workflow

**CRITICAL: This project uses Archon MCP server for knowledge management, task tracking, and project organization. ALWAYS start with Archon MCP server task management.**

## Core Workflow: Task-Driven Development

**MANDATORY task cycle before coding:**

1. **Get Task** â†’ `find_tasks(task_id="...")` or `find_tasks(filter_by="status", filter_value="todo")`
2. **Start Work** â†’ `manage_task("update", task_id="...", status="doing")`
3. **Research** â†’ Use knowledge base (see RAG workflow below)
4. **Implement** â†’ Write code based on research
5. **Review** â†’ `manage_task("update", task_id="...", status="review")`
6. **Next Task** â†’ `find_tasks(filter_by="status", filter_value="todo")`

**NEVER skip task updates. NEVER code without checking current tasks first.**

## RAG Workflow (Research Before Implementation)

### Searching Specific Documentation:

1. **Get sources** â†’ `rag_get_available_sources()` - Returns list with id, title, url
2. **Find source ID** â†’ Match to documentation (e.g., "Supabase docs" â†’ "src_abc123")
3. **Search** â†’ `rag_search_knowledge_base(query="vector functions", source_id="src_abc123")`

### General Research:

```bash
# Search knowledge base (2-5 keywords only!)
rag_search_knowledge_base(query="authentication JWT", match_count=5)

# Find code examples
rag_search_code_examples(query="React hooks", match_count=3)
```

**CRITICAL: Keep queries SHORT and FOCUSED (2-5 keywords), not long sentences.**

âœ… **Good**: "vector search pgvector", "React useState", "authentication JWT"
âŒ **Bad**: "how to implement vector search with pgvector in PostgreSQL for semantic similarity matching"

### Web MCP Servers (Discovery & Planning)

For external research during Discovery and Planning phases, use web MCP servers for token optimization:

**When to Use**:
- **Discovery Phase**: Finding inspiration sources, best practices, AI agent patterns
- **Planning Phase**: Researching PRD templates, architecture patterns, technology decisions
- **Token Optimization**: When you need multiple web searches or content extraction

**Available Tools**:
- `web_search_prime_search` - Enhanced web search (Discovery/Planning)
- `web_reader_read` - Read and extract content from web pages (Discovery/Planning)
- `zread_read` - Advanced web content reading and analysis (Discovery/Planning)

**Usage Pattern**:
```bash
# 1. Search for inspiration/examples
web_search_prime_search(query="AI agent patterns", ...)

# 2. Read relevant pages
web_reader_read(url="...")  # or zread_read(url="...")

# 3. Combine with RAG knowledge base results
rag_search_knowledge_base(query="similar patterns", ...)
```

**Fallback**: If web MCP servers unavailable, use Claude's built-in web search (may consume more tokens).

## Project Workflows

### New Project:

```bash
# 1. Create project
manage_project("create", title="My Feature", description="...")

# 2. Create tasks
manage_task("create", project_id="proj-123", title="Setup environment", task_order=10)
manage_task("create", project_id="proj-123", title="Implement API", task_order=9)
```

### Existing Project:

```bash
# 1. Find project
find_projects(query="auth")  # or find_projects() to list all

# 2. Get project tasks
find_tasks(filter_by="project", filter_value="proj-123")

# 3. Continue work or create new tasks
```

## Tool Reference

### Projects:

- `find_projects(query="...")` - Search projects
- `find_projects(project_id="...")` - Get specific project
- `manage_project("create"/"update"/"delete", title="...", description="...", github_repo="...")` - Manage projects

### Tasks:

- `find_tasks(query="...")` - Search tasks by keyword
- `find_tasks(task_id="...")` - Get specific task (returns full details)
- `find_tasks(filter_by="status"/"project"/"assignee", filter_value="...")` - Filter tasks
- `manage_task("create"/"update"/"delete", task_id="...", project_id="...", title="...", description="...", status="...", assignee="...", task_order=...)` - Manage tasks

**Task Status Flow**: `todo` â†’ `doing` â†’ `review` â†’ `done`

**Task Granularity**:
- For feature-specific projects: Create detailed implementation tasks (setup, implement, test, document)
- For codebase-wide projects: Create feature-level tasks
- Each task should represent 30 minutes to 4 hours of work
- Higher `task_order` = higher priority (0-100)

### Knowledge Base (RAG):

- `rag_get_available_sources()` - List all available knowledge sources
- `rag_search_knowledge_base(query="...", source_id="...", match_count=5, return_mode="pages")` - Search knowledge base
- `rag_search_code_examples(query="...", source_id="...", match_count=5)` - Find code examples
- `rag_list_pages_for_source(source_id="...", section="...")` - List pages in a source
- `rag_read_full_page(page_id="..." | url="...")` - Read complete page content

### Documents:

- `find_documents(project_id="...", document_id="...", query="...", document_type="...")` - Find documents
- `manage_document("create"/"update"/"delete", project_id="...", document_id="...", title="...", document_type="...", content="...", tags="...")` - Manage documents

### Other Tools:

- `health_check()` - Check MCP server health
- `session_info()` - Get session information

## MCP Server Health & Fallback

### Checking Server Availability

**Before starting work, verify Archon MCP is available:**

```bash
# Check Archon MCP health
health_check()  # Should return healthy status
```

**If Archon MCP is unavailable:**
1. **Inform user** that Archon MCP is unavailable
2. **Ask user** if they want to proceed with limited functionality or wait
3. **Do NOT use TodoWrite** - wait for Archon MCP to be available
4. **Document the issue** in your response

**If Web MCP servers are unavailable:**
- Use Claude's built-in web search as fallback
- Inform user that advanced web features may be limited
- Continue with available functionality

### Fallback Behavior

**Archon MCP Unavailable**:
- **DO NOT** fall back to TodoWrite (per ARCHON-FIRST RULE)
- **STOP** and inform user
- **WAIT** for Archon MCP to be available before proceeding

**Web MCP Servers Unavailable**:
- Use Claude's built-in web search
- May consume more tokens
- Continue with available functionality

## Important Notes

- **Task status flow**: `todo` â†’ `doing` â†’ `review` â†’ `done`
- **Keep queries SHORT** (2-5 keywords) for better search results
- **Higher `task_order`** = higher priority (0-100)
- **Tasks should be 30 min - 4 hours** of work
- **Only ONE task in 'doing' status** at a time
- **Use 'review'** for completed work awaiting validation
- **Mark tasks 'done'** only after verification

## Development Principles

### YAGNI (You Aren't Gonna Need It)

- **Don't implement features that are not needed**
- Focus on current requirements, not future possibilities
- Avoid over-engineering and premature optimization
- Build only what's necessary for current task

### KISS (Keep It Simple, Stupid)

- Prefer simple solutions over complex ones
- Avoid unnecessary abstractions
- Write code that's easy to understand and maintain

### DRY (Don't Repeat Yourself)

- Extract common patterns when appropriate
- Reuse code and components
- But don't over-abstract - balance with YAGNI

## Documentation Standards

**CRITICAL: Apply YAGNI/KISS to all documentation**

- **Line Limits**: MVP, PRD, TECH-SPEC must be 500-600 lines max (fewer is better)
- **YAGNI**: Only document what's needed NOW, remove verbose explanations, examples, and non-essential content
- **KISS**: Use simple, direct language. Remove marketing fluff, redundant sections, and verbose descriptions
- **Focus**: Keep only essential technical details, requirements, and implementation guidance
- **When Creating/Updating Docs**: Always trim unnecessary content, condense verbose sections, remove redundant information

## Error Handling

**When errors occur:**

1. **Stop and assess** - Don't continue with broken state
2. **Inform user clearly** - Explain what went wrong and why
3. **Suggest recovery** - Provide actionable next steps
4. **Preserve work** - Don't lose progress; checkpoint if possible
5. **Learn from errors** - Document patterns to avoid repetition

**Common Error Scenarios**:
- **MCP server unavailable**: Check health, inform user, wait for availability
- **Task not found**: Verify task ID, check project context, ask user
- **File operation failed**: Check permissions, verify path, inform user
- **RAG search returns no results**: Try broader query, check source availability

**Error Recovery Pattern**:
```bash
# 1. Attempt operation
# 2. If error, check health/availability
# 3. Inform user with context
# 4. Suggest alternative or wait
# 5. Retry when conditions met
```

---

## AI Coding Workflow System Commands

This project uses a markdown-based command system for orchestrating AI-assisted development workflows.

### Available Commands:

- `/prime` - Export codebase for context gathering
- `/discovery` - Explore ideas and opportunities
- `/planning {feature-name}` - Generate PRD
- `/development {feature-name}` - Generate Tech Spec
- `/task-planning {feature-name}` - Create PRP and tasks
- `/execution {feature-name}` - Execute tasks
- `/review {feature-name}` - Code review
- `/test {feature-name}` - Run tests
- `/workflow {feature-name}` - Execute full workflow

See `PRD.md` and `TECH-SPEC.md` for detailed command documentation.

## PRP Template Usage

**During Task Execution, always reference PRP documents:**

1. **Load PRP** â†’ Read `features/{feature-name}/prp.md` before starting implementation
2. **Follow Blueprint** â†’ Use PRP's "Implementation Blueprint" section for step-by-step guidance
3. **Reference Patterns** â†’ Follow codebase patterns documented in PRP
4. **Check Gotchas** â†’ Review "Known Gotchas" section to avoid common pitfalls
5. **Validate** â†’ Use PRP's "Validation Loop" commands for quality checks

**PRP Structure Reference**:
- **Goal**: What you're building and success criteria
- **All Needed Context**: Documentation, codebase patterns, file references
- **Implementation Blueprint**: Ordered tasks with dependencies
- **Validation Loop**: Syntax, unit tests, integration tests

**If PRP doesn't exist**:
- Run `/task-planning {feature-name}` first to generate PRP
- Or ask user if they want to proceed without PRP (not recommended)

## Decision-Making Framework

**When to proceed autonomously:**
- âœ… Task is clear from PRP/context
- âœ… Implementation pattern is established
- âœ… No ambiguity in requirements
- âœ… Standard file operations (create/edit within feature scope)
- âœ… Following existing codebase patterns

**When to ask user:**
- â“ Requirements are ambiguous or conflicting
- â“ Multiple valid approaches exist and choice matters
- â“ Breaking changes or major refactoring needed
- â“ External dependencies or configuration required
- â“ User preferences or business logic decisions needed
- â“ MCP server unavailable (critical blocker)

**Decision Rule**: If unsure, **ask**. Better to clarify than assume incorrectly.

---

## When Working with This Codebase

1. **Always check Archon MCP first** for tasks and projects
2. **Research before implementing** using RAG knowledge base
3. **Load PRP document** before starting implementation (if available)
4. **Update task status** as you work (todo â†’ doing â†’ review â†’ done)
5. **Follow YAGNI** - don't build what isn't needed
6. **Follow KISS** - keep it simple, prefer straightforward solutions over complex ones
7. **Use workflow commands** for structured development
8. **Check MCP server health** if operations fail unexpectedly

### File Modification Guidelines

**Safe to edit autonomously:**
- Files within `features/{feature-name}/` directory (current feature scope)
- New files being created as part of current task
- Documentation files (README, STATUS.md) for current feature
- Test files for current feature

**Ask before editing:**
- Files outside current feature directory
- Core system files (commands, templates, root configs)
- Files shared across multiple features
- Breaking changes or major refactoring
- User's explicitly open/visible files (unless task requires it)

**File Operation Best Practices:**
- Read file first to understand context
- Preserve existing patterns and style
- Make minimal, focused changes
- Document why changes were made (in commit messages or comments)

---

**Remember**: Archon MCP is PRIMARY task management system. Never use TodoWrite. Always start with Archon.
```

#### INDEX.md
```markdown
# AI Coding Workflow System - INDEX

## Overview

This is a markdown-based command system for orchestrating AI-assisted development workflows through MCP integration. It manages complete lifecycle from codebase context to implementation, review, and testing.

## Directory Navigation

- **[context/](./context/)** - Prime exports (codebase context)
- **[discovery/](./discovery/)** - Discovery documents (ideas and opportunities)
- **[features/](./features/)** - Feature artifacts (PRD, tech spec, PRP, task plans)
- **[templates/](./templates/)** - Template files (PRP templates)
- **[reviews/](./reviews/)** - Code review reports
- **[testing/](./testing/)** - Test results
- **[execution/](./execution/)** - Task breakdown files
- **[.claude/commands/](./.claude/commands/)** - Workflow commands

## Core Commands

| Command | Description | Phase |
|---------|-------------|-------|
| `/prime` | Export codebase for context gathering | Prime |
| `/discovery` | Explore ideas and opportunities | Discovery |
| `/planning {feature}` | Generate PRD from discovery | Planning |
| `/development {feature}` | Generate tech spec from PRD | Development |
| `/task-planning {feature}` | Generate PRP and create tasks | Task Planning |
| `/execution {feature}` | Execute tasks sequentially | Execution |
| `/review {feature}` | Run code review | Review |
| `/test {feature}` | Run tests | Test |
| `/workflow {feature}` | Execute full workflow | All phases |

## Documentation

- **[PRD.md](./PRD.md)** - Product Requirements Document
- **[TECH-SPEC.md](./TECH-SPEC.md)** - Technical Specification
- **[CLAUDE.md](./CLAUDE.md)** - Developer guidelines
- **[MVP.md](./MVP.md)** - Minimum Viable Product definition

## Quick Start

1. Run `/prime` to export codebase context
2. Run `/discovery` to explore opportunities
3. Run `/planning {feature-name}` to create PRD
4. Run `/development {feature-name}` to create tech spec
5. Run `/task-planning {feature-name}` to create implementation plan
6. Run `/execution {feature-name}` to implement tasks
7. Run `/review {feature-name}` to review code
8. Run `/test {feature-name}` to run tests

Or run `/workflow {feature-name}` to execute all phases automatically.

## Status

**Version**: 1.0
**Last Updated**: 2026-01-23
**Status**: In Development
```

#### MVP.md
```markdown
---
name: AI Coding Workflow System
overview: "A flexible, markdown-based AI coding workflow orchestration system that manages the complete development lifecycle from idea to implementation."
---

# AI Coding Workflow System - MVP

## Vision

Build a **robust and flexible** markdown-based command system that orchestrates AI-assisted development workflows. The system should seamlessly integrate with various MCP (Model Context Protocol) servers and adapt to different project needs while maintaining simplicity and transparency.

## Core Value Proposition

**Problem**: Manual coordination between development phases (discovery â†’ planning â†’ implementation â†’ review â†’ testing) is time-consuming and error-prone.

**Solution**: An automated workflow system that:
- Orchestrates the complete development lifecycle
- Works flexibly with different MCP servers and AI tools
- Stores all artifacts as markdown for transparency and version control
- Supports both individual command execution and unified automation

## Key Principles

1. **Flexibility First**: System works with any MCP server configuration, not locked to specific tools
2. **Markdown-Based**: All artifacts stored as markdown files for easy review and version control
3. **Modular Commands**: Each phase can run independently or as part of unified workflow
4. **Transparency**: Clear progress tracking and artifact organization
5. **Robustness**: Handles errors gracefully, supports checkpoint/resume

## Workflow Phases

The system orchestrates these sequential phases:

1. **Prime** - Export codebase for context gathering
2. **Discovery** - Explore ideas, inspiration, and needs for AI/ATR applications
3. **Planning** - Transform discovery insights into PRD (Product Requirements Document)
4. **Development** - Analyze PRD and generate Tech Spec (Technical Specification)
5. **Task Planning** - Combine all contexts (Prime + Discovery + PRD + Tech Spec) into digestible, actionable tasks
6. **Execution** - Execute digestible tasks step-by-step with progress tracking
7. **Review** - AI-powered code review
8. **Test** - Automated testing and error detection

## Architecture Approach

- **Command Structure**: Markdown files with frontmatter (following Claude Code pattern)
- **Storage**: File system-based with organized directory structure
- **Integration**: MCP protocol for AI model communication (flexible server configuration)
- **Task Management**: Supports Archon MCP or TodoWrite fallback
- **Progress Tracking**: STATUS.md per feature, INDEX.md for navigation

## Success Criteria

- System successfully orchestrates complete development lifecycle
- Works with different MCP server configurations
- All artifacts clearly documented and navigable
- Supports both individual and unified command execution
- Handles errors gracefully with checkpoint/resume capability

## Out of Scope (MVP)

- Web UI or dashboard
- Real-time collaboration
- Custom command creation interface
- Plugin system for extending commands
```

#### README.md
```markdown
# AI Coding Workflow System

A markdown-based command system for orchestrating AI-assisted development workflows through MCP integration.

## Overview

This system manages complete development lifecycle from codebase context gathering through implementation, review, and testing. It uses markdown files for all artifacts and integrates with MCP (Model Context Protocol) servers for task management, knowledge base queries, and web research.

## Features

- **Prime Export**: Comprehensive codebase context gathering
- **Discovery**: AI-powered exploration of ideas and opportunities
- **Planning**: Automated PRD generation from discovery
- **Development**: Tech spec generation with stack recommendations
- **Task Planning**: PRP (Plan Reference Protocol) generation with task breakdown
- **Execution**: Sequential task execution with progress tracking
- **Review**: AI-powered code review with compliance verification
- **Testing**: Automated testing with AI-suggested fixes
- **Unified Workflow**: Single command for complete lifecycle

## Quick Start

### Prerequisites

- Claude Code CLI
- Archon MCP server (recommended)
- Web MCP servers (recommended)

### Basic Usage

```bash
# Export codebase context
/prime

# Explore opportunities
/discovery

# Create feature requirements
/planning my-feature

# Generate technical specification
/development my-feature

# Create implementation plan
/task-planning my-feature

# Execute implementation
/execution my-feature

# Review code
/review my-feature

# Run tests
/test my-feature
```

### Unified Workflow

Execute all phases with a single command:

```bash
/workflow my-feature
```

### Resume from Phase

Resume from any phase if errors occur:

```bash
/workflow my-feature --from-development
```

## Directory Structure

```
project-root/
â”œâ”€â”€ .claude/
â”‚   â”œâ”€â”€ commands/          # Workflow commands
â”‚   â””â”€â”€ templates/         # STATUS.md template
â”œâ”€â”€ context/               # Prime exports
â”œâ”€â”€ discovery/             # Discovery documents
â”œâ”€â”€ features/              # Feature artifacts
â”‚   â””â”€â”€ {feature-name}/
â”‚       â”œâ”€â”€ prd.md
â”‚       â”œâ”€â”€ tech-spec.md
â”‚       â”œâ”€â”€ prp.md
â”‚       â”œâ”€â”€ task-plan.md
â”‚       â””â”€â”€ STATUS.md
â”œâ”€â”€ templates/
â”‚   â””â”€â”€ prp/               # PRP templates
â”œâ”€â”€ reviews/               # Review reports
â”œâ”€â”€ testing/               # Test results
â”œâ”€â”€ execution/             # Task breakdown files
â”œâ”€â”€ PRD.md                 # Product Requirements Document
â”œâ”€â”€ TECH-SPEC.md           # Technical Specification
â”œâ”€â”€ CLAUDE.md              # Developer guidelines
â””â”€â”€ README.md              # This file
```

## Documentation

- **[PRD.md](./PRD.md)** - Complete product requirements
- **[TECH-SPEC.md](./TECH-SPEC.md)** - Technical specifications
- **[CLAUDE.md](./CLAUDE.md)** - Development guidelines
- **[INDEX.md](./INDEX.md)** - System navigation

## License

MIT License - See LICENSE file for details
```

#### TECH-SPEC.md (continues...)
[File truncated for display - full content continues with file listings and command definitions]

---

**Note**: This prime export contains full file contents. Due to size, some files may be displayed in summary format.
```

### context\\prime-2026-01-24T18-21-11Z.md
`$(@{Path=context\\prime-2026-01-24T18-21-11Z.md; Language=markdown; Lines=System.Object[]}.Language)
# Codebase Export: 2026-01-24T18:21:11Z

## Project Tree

```
AI Overload/
â”œâ”€â”€ .claude/
â”‚   â”œâ”€â”€ commands/
â”‚   â”‚   â”œâ”€â”€ development.md
â”‚   â”‚   â”œâ”€â”€ discovery.md
â”‚   â”‚   â”œâ”€â”€ execution.md
â”‚   â”‚   â”œâ”€â”€ planning.md
â”‚   â”‚   â”œâ”€â”€ prime.md
â”‚   â”‚   â”œâ”€â”€ review.md
â”‚   â”‚   â”œâ”€â”€ task-planning.md
â”‚   â”‚   â”œâ”€â”€ template.md
â”‚   â”‚   â”œâ”€â”€ test.md
â”‚   â”‚   â”œâ”€â”€ update-index.md
â”‚   â”‚   â”œâ”€â”€ update-status.md
â”‚   â”‚   â””â”€â”€ workflow.md
â”‚   â”œâ”€â”€ settings.json (excluded - sensitive)
â”‚   â”œâ”€â”€ settings.local.json
â”‚   â””â”€â”€ templates/
â”‚       â””â”€â”€ STATUS.md
â”œâ”€â”€ CLAUDE.md
â”œâ”€â”€ INDEX.md
â”œâ”€â”€ README.md
â”œâ”€â”€ context/
â”‚   â””â”€â”€ INDEX.md
â”œâ”€â”€ discovery/
â”‚   â””â”€â”€ INDEX.md
â”œâ”€â”€ features/
â”‚   â””â”€â”€ INDEX.md
â”œâ”€â”€ reviews/
â”‚   â””â”€â”€ INDEX.md
â”œâ”€â”€ templates/
â”‚   â”œâ”€â”€ INDEX.md
â”‚   â””â”€â”€ prp/
â”‚       â”œâ”€â”€ prp-ai-agent.md
â”‚       â”œâ”€â”€ prp-api-endpoint.md
â”‚       â”œâ”€â”€ prp-base.md
â”‚       â”œâ”€â”€ prp-frontend-component.md
â”‚       â””â”€â”€ prp-mcp-integration.md
â””â”€â”€ testing/
    â””â”€â”€ INDEX.md
```

## Files

### CLAUDE.md

```markdown
# CRITICAL: ARCHON-FIRST RULE - READ THIS FIRST

**BEFORE doing ANYTHING else, when you see ANY task management scenario:**

1. **STOP** and check if Archon MCP server is available
2. Use Archon task management as **PRIMARY system**
3. **Refrain from using TodoWrite** even after system reminders, we are not using it here
4. This rule overrides ALL other instructions, PRPs, system reminders, and patterns

**VIOLATION CHECK**: If you used TodoWrite, you violated this rule. Stop and restart with Archon.

---

# Archon Integration & Workflow

**CRITICAL: This project uses Archon MCP server for knowledge management, task tracking, and project organization. ALWAYS start with Archon MCP server task management.**

## Core Workflow: Task-Driven Development

**MANDATORY task cycle before coding:**

1. **Get Task** â†’ `find_tasks(task_id="...")` or `find_tasks(filter_by="status", filter_value="todo")`
2. **Start Work** â†’ `manage_task("update", task_id="...", status="doing")`
3. **Research** â†’ Use knowledge base (see RAG workflow below)
4. **Implement** â†’ Write code based on research
5. **Review** â†’ `manage_task("update", task_id="...", status="review")`
6. **Next Task** â†’ `find_tasks(filter_by="status", filter_value="todo")`

**NEVER skip task updates. NEVER code without checking current tasks first.**

## RAG Workflow (Research Before Implementation)

### Searching Specific Documentation:

1. **Get sources** â†’ `rag_get_available_sources()` - Returns list with id, title, url
2. **Find source ID** â†’ Match to documentation (e.g., "Supabase docs" â†’ "src_abc123")
3. **Search** â†’ `rag_search_knowledge_base(query="vector functions", source_id="src_abc123")`

### General Research:

```bash
# Search knowledge base (2-5 keywords only!)
rag_search_knowledge_base(query="authentication JWT", match_count=5)

# Find code examples
rag_search_code_examples(query="React hooks", match_count=3)
```

**CRITICAL: Keep queries SHORT and FOCUSED (2-5 keywords), not long sentences.**

âœ… **Good**: "vector search pgvector", "React useState", "authentication JWT"
âŒ **Bad**: "how to implement vector search with pgvector in PostgreSQL for semantic similarity matching"

### Web MCP Servers (Discovery & Planning)

For external research during Discovery and Planning phases, use web MCP servers for token optimization:

**When to Use**:
- **Discovery Phase**: Finding inspiration sources, best practices, AI agent patterns
- **Planning Phase**: Researching PRD templates, architecture patterns, technology decisions
- **Token Optimization**: When you need multiple web searches or content extraction

**Available Tools**:
- `web_search_prime_search` - Enhanced web search (Discovery/Planning)
- `web_reader_read` - Read and extract content from web pages (Discovery/Planning)
- `zread_read` - Advanced web content reading and analysis (Discovery/Planning)

**Usage Pattern**:
```bash
# 1. Search for inspiration/examples
web_search_prime_search(query="AI agent patterns", ...)

# 2. Read relevant pages
web_reader_read(url="...")  # or zread_read(url="...")

# 3. Combine with RAG knowledge base results
rag_search_knowledge_base(query="similar patterns", ...)
```

**Fallback**: If web MCP servers unavailable, use Claude's built-in web search (may consume more tokens).

## Project Workflows

### New Project:

```bash
# 1. Create project
manage_project("create", title="My Feature", description="...")

# 2. Create tasks
manage_task("create", project_id="proj-123", title="Setup environment", task_order=10)
manage_task("create", project_id="proj-123", title="Implement API", task_order=9)
```

### Existing Project:

```bash
# 1. Find project
find_projects(query="auth")  # or find_projects() to list all

# 2. Get project tasks
find_tasks(filter_by="project", filter_value="proj-123")

# 3. Continue work or create new tasks
```

## Tool Reference

### Projects:

- `find_projects(query="...")` - Search projects
- `find_projects(project_id="...")` - Get specific project
- `manage_project("create"/"update"/"delete", title="...", description="...", github_repo="...")` - Manage projects

### Tasks:

- `find_tasks(query="...")` - Search tasks by keyword
- `find_tasks(task_id="...")` - Get specific task (returns full details)
- `find_tasks(filter_by="status"/"project"/"assignee", filter_value="...")` - Filter tasks
- `manage_task("create"/"update"/"delete", task_id="...", project_id="...", title="...", description="...", status="...", assignee="...", task_order=...)` - Manage tasks

**Task Status Flow**: `todo` â†’ `doing` â†’ `review` â†’ `done`

**Task Granularity**:
- For feature-specific projects: Create detailed implementation tasks (setup, implement, test, document)
- For codebase-wide projects: Create feature-level tasks
- Each task should represent 30 minutes to 4 hours of work
- Higher `task_order` = higher priority (0-100)

### Knowledge Base (RAG):

- `rag_get_available_sources()` - List all available knowledge sources
- `rag_search_knowledge_base(query="...", source_id="...", match_count=5, return_mode="pages")` - Search knowledge base
- `rag_search_code_examples(query="...", source_id="...", match_count=5)` - Find code examples
- `rag_list_pages_for_source(source_id="...", section="...")` - List pages in a source
- `rag_read_full_page(page_id="..." | url="...")` - Read complete page content

### Documents:

- `find_documents(project_id="...", document_id="...", query="...", document_type="...")` - Find documents
- `manage_document("create"/"update"/"delete", project_id="...", document_id="...", title="...", document_type="...", content="...", tags="...")` - Manage documents

### Other Tools:

- `health_check()` - Check MCP server health
- `session_info()` - Get session information

## MCP Server Health & Fallback

### Checking Server Availability

**Before starting work, verify Archon MCP is available:**

```bash
# Check Archon MCP health
health_check()  # Should return healthy status
```

**If Archon MCP is unavailable:**
1. **Inform user** that Archon MCP is unavailable
2. **Ask user** if they want to proceed with limited functionality or wait
3. **Do NOT use TodoWrite** - wait for Archon MCP to be available
4. **Document the issue** in your response

**If Web MCP servers are unavailable:**
- Use Claude's built-in web search as fallback
- Inform user that advanced web features may be limited
- Continue with available functionality

### Fallback Behavior

**Archon MCP Unavailable**:
- **DO NOT** fall back to TodoWrite (per ARCHON-FIRST RULE)
- **STOP** and inform user
- **WAIT** for Archon MCP to be available before proceeding

**Web MCP Servers Unavailable**:
- Use Claude's built-in web search
- May consume more tokens
- Continue with available functionality

## Important Notes

- **Task status flow**: `todo` â†’ `doing` â†’ `review` â†’ `done`
- **Keep queries SHORT** (2-5 keywords) for better search results
- **Higher `task_order`** = higher priority (0-100)
- **Tasks should be 30 min - 4 hours** of work
- **Only ONE task in 'doing' status** at a time
- **Use 'review'** for completed work awaiting validation
- **Mark tasks 'done'** only after verification

## Development Principles

### YAGNI (You Aren't Gonna Need It)

- **Don't implement features that are not needed**
- Focus on current requirements, not future possibilities
- Avoid over-engineering and premature optimization
- Build only what's necessary for current task

### KISS (Keep It Simple, Stupid)

- Prefer simple solutions over complex ones
- Avoid unnecessary abstractions
- Write code that's easy to understand and maintain

### DRY (Don't Repeat Yourself)

- Extract common patterns when appropriate
- Reuse code and components
- But don't over-abstract - balance with YAGNI

## Documentation Standards

**CRITICAL: Apply YAGNI/KISS to all documentation**

- **Line Limits**: MVP, PRD, TECH-SPEC must be 500-600 lines max (fewer is better)
- **YAGNI**: Only document what's needed NOW, remove verbose explanations, examples, and non-essential content
- **KISS**: Use simple, direct language. Remove marketing fluff, redundant sections, and verbose descriptions
- **Focus**: Keep only essential technical details, requirements, and implementation guidance
- **When Creating/Updating Docs**: Always trim unnecessary content, condense verbose sections, remove redundant information

## Error Handling

**When errors occur:**

1. **Stop and assess** - Don't continue with broken state
2. **Inform user clearly** - Explain what went wrong and why
3. **Suggest recovery** - Provide actionable next steps
4. **Preserve work** - Don't lose progress; checkpoint if possible
5. **Learn from errors** - Document patterns to avoid repetition

**Common Error Scenarios**:
- **MCP server unavailable**: Check health, inform user, wait for availability
- **Task not found**: Verify task ID, check project context, ask user
- **File operation failed**: Check permissions, verify path, inform user
- **RAG search returns no results**: Try broader query, check source availability

**Error Recovery Pattern**:
```bash
# 1. Attempt operation
# 2. If error, check health/availability
# 3. Inform user with context
# 4. Suggest alternative or wait
# 5. Retry when conditions met
```

---

## AI Coding Workflow System Commands

This project uses a markdown-based command system for orchestrating AI-assisted development workflows.

### Available Commands:

- `/prime` - Export codebase for context gathering
- `/discovery` - Explore ideas and opportunities
- `/planning {feature-name}` - Generate PRD
- `/development {feature-name}` - Generate Tech Spec
- `/task-planning {feature-name}` - Create PRP and tasks
- `/execution {feature-name}` - Execute tasks
- `/review {feature-name}` - Code review
- `/test {feature-name}` - Run tests
- `/workflow {feature-name}` - Execute full workflow

See `PRD.md` and `TECH-SPEC.md` for detailed command documentation.

## PRP Template Usage

**During Task Execution, always reference PRP documents:**

1. **Load PRP** â†’ Read `features/{feature-name}/prp.md` before starting implementation
2. **Follow Blueprint** â†’ Use PRP's "Implementation Blueprint" section for step-by-step guidance
3. **Reference Patterns** â†’ Follow codebase patterns documented in PRP
4. **Check Gotchas** â†’ Review "Known Gotchas" section to avoid common pitfalls
5. **Validate** â†’ Use PRP's "Validation Loop" commands for quality checks

**PRP Structure Reference**:
- **Goal**: What you're building and success criteria
- **All Needed Context**: Documentation, codebase patterns, file references
- **Implementation Blueprint**: Ordered tasks with dependencies
- **Validation Loop**: Syntax, unit tests, integration tests

**If PRP doesn't exist**:
- Run `/task-planning {feature-name}` first to generate PRP
- Or ask user if they want to proceed without PRP (not recommended)

## Decision-Making Framework

**When to proceed autonomously:**
- âœ… Task is clear from PRP/context
- âœ… Implementation pattern is established
- âœ… No ambiguity in requirements
- âœ… Standard file operations (create/edit within feature scope)
- âœ… Following existing codebase patterns

**When to ask user:**
- â“ Requirements are ambiguous or conflicting
- â“ Multiple valid approaches exist and choice matters
- â“ Breaking changes or major refactoring needed
- â“ External dependencies or configuration required
- â“ User preferences or business logic decisions needed
- â“ MCP server unavailable (critical blocker)

**Decision Rule**: If unsure, **ask**. Better to clarify than assume incorrectly.

---

## When Working with This Codebase

1. **Always check Archon MCP first** for tasks and projects
2. **Research before implementing** using RAG knowledge base
3. **Load PRP document** before starting implementation (if available)
4. **Update task status** as you work (todo â†’ doing â†’ review â†’ done)
5. **Follow YAGNI** - don't build what isn't needed
6. **Follow KISS** - keep it simple, prefer straightforward solutions over complex ones
7. **Use workflow commands** for structured development
8. **Check MCP server health** if operations fail unexpectedly

### File Modification Guidelines

**Safe to edit autonomously:**
- Files within `features/{feature-name}/` directory (current feature scope)
- New files being created as part of current task
- Documentation files (README, STATUS.md) for current feature
- Test files for current feature

**Ask before editing:**
- Files outside current feature directory
- Core system files (commands, templates, root configs)
- Files shared across multiple features
- Breaking changes or major refactoring
- User's explicitly open/visible files (unless task requires it)

**File Operation Best Practices:**
- Read file first to understand context
- Preserve existing patterns and style
- Make minimal, focused changes
- Document why changes were made (in commit messages or comments)

---

**Remember**: Archon MCP is PRIMARY task management system. Never use TodoWrite. Always start with Archon.
```

### INDEX.md

```markdown
# AI Coding Workflow System - INDEX

## Overview

This is a markdown-based command system for orchestrating AI-assisted development workflows through MCP integration. It manages the complete lifecycle from codebase context to implementation, review, and testing.

## Directory Navigation

- **[context/](./context/)** - Prime exports (codebase context)
- **[discovery/](./discovery/)** - Discovery documents (ideas and opportunities)
- **[features/](./features/)** - Feature artifacts (PRD, tech spec, PRP, task plans)
- **[templates/](./templates/)** - Template files (PRP templates)
- **[reviews/](./reviews/)** - Code review reports
- **[testing/](./testing/)** - Test results
- **[execution/](./execution/)** - Task breakdown files
- **[.claude/commands/](./.claude/commands/)** - Workflow commands

## Core Commands

| Command | Description | Phase |
|---------|-------------|-------|
| `/prime` | Export codebase for context gathering | Prime |
| `/discovery` | Explore ideas and opportunities | Discovery |
| `/planning {feature}` | Generate PRD from discovery | Planning |
| `/development {feature}` | Generate tech spec from PRD | Development |
| `/task-planning {feature}` | Generate PRP and create tasks | Task Planning |
| `/execution {feature}` | Execute tasks sequentially | Execution |
| `/review {feature}` | Run code review | Review |
| `/test {feature}` | Run tests | Test |
| `/workflow {feature}` | Execute full workflow | All phases |

## Documentation

- **[PRD.md](./PRD.md)** - Product Requirements Document
- **[TECH-SPEC.md](./TECH-SPEC.md)** - Technical Specification
- **[CLAUDE.md](./CLAUDE.md)** - Developer guidelines
- **[MVP.md](./MVP.md)** - Minimum Viable Product definition

## Quick Start

1. Run `/prime` to export codebase context
2. Run `/discovery` to explore opportunities
3. Run `/planning {feature-name}` to create PRD
4. Run `/development {feature-name}` to create tech spec
5. Run `/task-planning {feature-name}` to create implementation plan
6. Run `/execution {feature-name}` to implement tasks
7. Run `/review {feature-name}` to review code
8. Run `/test {feature-name}` to run tests

Or run `/workflow {feature-name}` to execute all phases automatically.

## Status

**Version**: 1.0
**Last Updated**: 2026-01-23
**Status**: In Development
```

### README.md

```markdown
# AI Coding Workflow System

A markdown-based command system for orchestrating AI-assisted development workflows through MCP integration.

## Overview

This system manages the complete development lifecycle from codebase context gathering through implementation, review, and testing. It uses markdown files for all artifacts and integrates with MCP (Model Context Protocol) servers for task management, knowledge base queries, and web research.

## Features

- **Prime Export**: Comprehensive codebase context gathering
- **Discovery**: AI-powered exploration of ideas and opportunities
- **Planning**: Automated PRD generation from discovery
- **Development**: Tech spec generation with stack recommendations
- **Task Planning**: PRP (Plan Reference Protocol) generation with task breakdown
- **Execution**: Sequential task execution with progress tracking
- **Review**: AI-powered code review with compliance verification
- **Testing**: Automated testing with AI-suggested fixes
- **Unified Workflow**: Single command for complete lifecycle

## Quick Start

### Prerequisites

- Claude Code CLI
- Archon MCP server (recommended)
- Web MCP servers (recommended)

### Basic Usage

```bash
# Export codebase context
/prime

# Explore opportunities
/discovery

# Create feature requirements
/planning my-feature
... [truncated: showing first 500 and last 500 lines] ...

### templates/prp/prp-base.md

```markdown
# PRP: {feature-name}

**Version**: 1.0 | **Last Updated**: {timestamp} | **Related**: PRD.md, TECH-SPEC.md

## Goal

### Feature Goal
{Clear description of what this feature accomplishes. Should be specific and measurable.}

### Deliverable
{What will be delivered - specific artifacts, files, functionality. List exact deliverables.}

### Success Criteria
{How to verify success - acceptance criteria, tests, validation. Must be measurable and testable.}

## All Needed Context

### Documentation URLs
{External documentation references - API docs, framework docs, best practices.}

### Codebase Patterns
{Relevant patterns from codebase - file structure, naming conventions, architecture patterns.}

### File References
{Specific files to reference - similar implementations, utilities, helpers.}

### Naming Conventions
{File naming, function naming, class naming, variable naming conventions.}

### Architecture Patterns
{Service structure, API patterns, data flow, component organization.}

## Implementation Blueprint

### Data Models
{Data structures, schemas, interfaces, types.}

### Implementation Tasks
{Step-by-step tasks with dependencies.}

### Dependencies
{Task dependencies, external dependencies, prerequisites.}

### File Structure
{Directory layout, file organization, where to create files.}

### Integration Points
{How this feature integrates with existing codebase, APIs, services.}

## Validation Loop

### Syntax Validation
{Commands to validate syntax - linters, formatters, type checkers.}

### Unit Tests
{How to write and run unit tests, test structure, test patterns.}

### Integration Tests
{How to write and run integration tests, test setup, test patterns.}

### End-to-End Tests
{How to test complete workflow from user perspective.}

## Anti-Patterns

### General Anti-Patterns
- Skipping tests: Always write tests for new code
- Hardcoding values: Use configuration and environment variables
- Ignoring errors: Handle all error cases gracefully
- Not documenting: Document complex logic and decisions
- Over-engineering: Keep solutions simple (YAGNI)
- Premature optimization: Optimize only when needed (YAGNI)
- Violating conventions: Follow existing codebase patterns

### Feature-Specific Anti-Patterns
{Feature-specific anti-patterns to avoid.}

## Notes

- This PRP contains everything needed to implement successfully without prior knowledge
- Extract codebase patterns from Prime export
- Follow naming conventions from existing codebase
- Test thoroughly before marking as complete
- Update STATUS.md as you progress through tasks
```

### templates/prp/prp-ai-agent.md

```markdown
# PRP: {feature-name} - AI Agent

**Template**: prp-ai-agent.md | **Extends**: prp-base.md

## Goal
{Base template Goal section}

## All Needed Context
{Base template All Needed Context section}

### AI Agent Specific Context
- Agent framework documentation (Claude API, LangChain, etc.)
- Model capabilities and limitations
- Tool integration patterns
- Prompt engineering best practices
- Agent architecture patterns from codebase

## Implementation Blueprint
{Base template Implementation Blueprint section}

### Agent Architecture
- Agent type: {Claude agent, LangChain agent, custom agent}
- Framework: {Claude API, LangChain, custom framework}
- Model: {Claude Sonnet, GPT-4, etc.}
- Prompt engineering: {System prompts, user prompts, tool descriptions}

### Agent Tools
- Available tools: {List of tools agent can use}
- Tool integration: {How tools are integrated}
- Tool calling patterns: {How agent calls tools}
- Tool error handling: {How to handle tool failures}

### Agent Memory
- Memory type: {Conversation history, vector store, etc.}
- Context window: {Token limits, context management}
- Memory persistence: {How memory is stored and retrieved}

### Agent Workflow
- Execution flow: {Step-by-step agent execution}
- Decision making: {How agent makes decisions}
- Error handling: {How agent handles errors}
- State management: {How agent maintains state}

## Validation Loop
{Base template Validation Loop section}

### Agent Testing
- Prompt testing: {How to test prompts}
- Tool testing: {How to test tool integration}
- End-to-end testing: {How to test complete agent workflow}
- Performance testing: {How to test agent performance}

### Output Validation
- Response quality: {How to validate agent responses}
- Tool call validation: {How to validate tool calls}
- Error handling validation: {How to validate error handling}

## Anti-Patterns
{Base template Anti-Patterns section}

### AI Agent Specific Anti-Patterns
- Overly complex prompts: Keep prompts focused and clear
- Ignoring context limits: Manage context window carefully
- Not handling tool errors: Always handle tool failures gracefully
- Hardcoding responses: Use dynamic generation
- Not testing prompts: Test prompts thoroughly before deployment
- No memory management: Always implement memory persistence
- Ignoring token limits: Respect model token limitations
```

### templates/prp/prp-mcp-integration.md

```markdown
# PRP: {feature-name} - MCP Integration

**Template**: prp-mcp-integration.md | **Extends**: prp-base.md

## Goal
{Base template Goal section}

## All Needed Context
{Base template All Needed Context section}

### MCP Specific Context
- MCP server documentation
- MCP protocol specification
- Tool definitions and schemas
- Resource definitions and schemas
- MCP integration patterns from codebase

## Implementation Blueprint
{Base template Implementation Blueprint section}

### MCP Server Configuration
- Server type: {HTTP, stdio, SSE}
- Authentication: {API keys, tokens, etc.}
- Connection: {How to connect to MCP server}
- Configuration file: {Where MCP server is configured}

### MCP Tools
- Available tools: {List of tools from MCP server}
- Tool definitions: {Tool schemas and parameters}
- Tool usage patterns: {How to call tools}
- Tool error handling: {How to handle tool errors}
- Tool result validation: {How to validate tool responses}

### MCP Resources
- Available resources: {List of resources from MCP server}
- Resource access: {How to access resources}
- Resource caching: {How to cache resources}
- Resource error handling: {How to handle resource errors}

### MCP Prompts
- Prompt templates: {Available prompt templates}
- Prompt management: {How to manage prompts}
- Prompt usage: {How to use prompts}
- Prompt variables: {How to pass variables to prompts}

### MCP Integration Patterns
- Client initialization: {How to initialize MCP client}
- Connection lifecycle: {How to manage connection lifecycle}
- Error handling: {How to handle MCP errors}
- Retry logic: {How to handle retries and backoff}

## Validation Loop
{Base template Validation Loop section}

### MCP Testing
- Server connection testing: {How to test MCP server connection}
- Tool testing: {How to test MCP tools}
- Resource testing: {How to test MCP resources}
- Integration testing: {How to test MCP integration}
- Performance testing: {How to test MCP performance}

### Error Handling Validation
- Connection errors: {How to validate connection error handling}
- Tool errors: {How to validate tool error handling}
- Resource errors: {How to validate resource error handling}
- Rate limit handling: {How to validate rate limit handling}

## Anti-Patterns
{Base template Anti-Patterns section}

### MCP Specific Anti-Patterns
- Not handling server unavailability: Always implement fallbacks
- Not validating tool responses: Validate all tool responses
- Ignoring rate limits: Respect MCP server rate limits
- Not caching resources: Cache resources when appropriate
- Hardcoding tool calls: Use dynamic tool discovery
- Ignoring connection lifecycle: Properly manage connection state
- Not handling errors: Always implement comprehensive error handling
- Not testing integration: Test MCP integration thoroughly
```

### templates/prp/prp-api-endpoint.md

```markdown
# PRP: {feature-name} - API Endpoint

**Template**: prp-api-endpoint.md | **Extends**: prp-base.md

## Goal
{Base template Goal section}

## All Needed Context
{Base template All Needed Context section}

### API Specific Context
- API framework documentation (Express, FastAPI, etc.)
- API design patterns from codebase
- Authentication patterns from codebase
- Validation patterns from codebase
- Error handling patterns from codebase

## Implementation Blueprint
{Base template Implementation Blueprint section}

### API Design
- Endpoint: {HTTP method and path}
- Request format: {Request body, query parameters, headers}
- Response format: {Response body, status codes, headers}
- Error format: {Error response format}
- Versioning: {API versioning strategy}

### API Authentication
- Authentication method: {JWT, API key, OAuth, etc.}
- Authorization: {Role-based, permission-based, etc.}
- Security: {HTTPS, CORS, rate limiting, etc.}
- Token validation: {How to validate tokens}
- Token refresh: {How to handle token refresh}

### API Validation
- Request validation: {Input validation, schema validation}
- Response validation: {Output validation, schema validation}
- Error handling: {Error response format, error codes}
- Sanitization: {Input sanitization, XSS prevention}
- Content validation: {Content-Type validation}

### API Documentation
- Documentation format: {OpenAPI, Swagger, Markdown}
- Endpoint documentation: {Request/response examples}
- Error documentation: {Error codes and messages}
- Versioning documentation: {How API versioning is documented}
- Example requests: {Example requests for testing}

### Rate Limiting & Throttling
- Rate limiting strategy: {How rate limiting is implemented}
- Rate limit values: {Rate limit configuration}
- Throttling behavior: {What happens when rate limit exceeded}
- Rate limit headers: {Headers for rate limit information}

### API Monitoring & Logging
- Request logging: {What is logged for each request}
- Error logging: {How errors are logged}
- Performance metrics: {Metrics collected for monitoring}
- Alerting: {Alert conditions and notification}

## Validation Loop
{Base template Validation Loop section}

### API Testing
- Unit testing: {Test controllers, services, models}
- Integration testing: {Test API endpoints end-to-end}
- Performance testing: {Test API performance, load testing}
- Security testing: {Test authentication, authorization, input validation}
- Error testing: {Test error handling and error responses}

### API Contract Testing
- Schema validation: {Test against defined schemas}
- Example validation: {Test with example requests}
- Error scenario testing: {Test all error scenarios}
- Edge case testing: {Test edge cases and boundary conditions}

## Anti-Patterns
{Base template Anti-Patterns section}

### API Specific Anti-Patterns
- Not validating input: Always validate all input
- Exposing sensitive data: Never expose sensitive data in responses
- Not handling errors: Always return proper error responses
- Ignoring security: Always implement authentication and authorization
- Not documenting APIs: Always document API endpoints
- Hardcoding responses: Use dynamic generation based on input
- Ignoring rate limits: Respect rate limiting and implement properly
- Not monitoring performance: Always monitor API performance
- Inconsistent error responses: Use consistent error format across all endpoints
```

### templates/prp/prp-frontend-component.md

```markdown
# PRP: {feature-name} - Frontend Component

**Template**: prp-frontend-component.md | **Extends**: prp-base.md

## Goal
{Base template Goal section}

## All Needed Context
{Base template All Needed Context section}

### Frontend Specific Context
- Frontend framework documentation (React, Vue, Svelte, etc.)
- Component patterns from codebase
- Styling patterns from codebase
- State management patterns from codebase
- Testing patterns from codebase

## Implementation Blueprint
{Base template Implementation Blueprint section}

### Component Architecture
- Component type: {Functional component, class component, etc.}
- Props: {Component props and types}
- State: {Component state, state management}
- Lifecycle: {Component lifecycle hooks}
- Hooks: {Custom hooks, composition patterns}
- Refs: {When and how to use refs}

### Component Styling
- Styling approach: {CSS modules, styled-components, Tailwind, etc.}
- Responsive design: {Breakpoints, mobile-first, etc.}
- Theming: {Theme support, dark mode, etc.}
- CSS architecture: {Global styles, component styles, utility classes}
- Animation: {Component animations and transitions}

### Component Integration
- API integration: {How component fetches data}
- State management: {How component manages state}
- Routing: {How component integrates with routing}
- Event handling: {Event propagation and handling}
- Context integration: {How component consumes context}

### Component Performance
- Optimization: {Memoization, lazy loading, etc.}
- Code splitting: {How component is code split}
- Bundle size: {How to minimize bundle size}
- Rendering optimization: {How to optimize rendering performance}
- Image optimization: {How to optimize images}

### Accessibility
- ARIA attributes: {Required ARIA attributes}
- Keyboard navigation: {Keyboard interaction support}
- Screen reader support: {How to support screen readers}
- Focus management: {How to manage focus}
- Color contrast: {How to ensure accessible colors}

## Validation Loop
{Base template Validation Loop section}

### Component Testing
- Unit testing: {Test component rendering, props, state}
- Integration testing: {Test component integration}
- Visual testing: {Test component appearance}
- Accessibility testing: {Test component accessibility}
- Performance testing: {Test component performance}

### User Testing
- User scenarios: {Key user flows to test}
- Edge cases: {Edge cases to test}
- Error states: {How to test error handling}
- Loading states: {How to test loading states}

## Anti-Patterns
{Base template Anti-Patterns section}

### Frontend Specific Anti-Patterns
- Not handling loading states: Always show loading states
- Not handling errors: Always handle and display errors
- Ignoring accessibility: Always implement accessibility features
- Not optimizing performance: Always optimize component performance
- Not testing components: Always test components thoroughly
- Prop drilling: Use composition instead of prop drilling
- Giant components: Break down large components into smaller ones
- State duplication: Avoid duplicating state across components
- Inline styles: Use appropriate styling approach
- Ignoring responsive design: Always implement responsive layouts
```

### .claude/settings.local.json

```json
{
  "permissions": {
    "allow": [
      "Bash(git clone:*)",
      "Bash(tree:*)",
      "Bash(claude mcp add:*)",
      "Bash(curl:*)",
      "Bash(ls:*)",
      "Bash(chmod:*)",
      "WebSearch",
      "mcp__archon__health_check",
      "mcp__archon__find_tasks",
      "mcp__archon__find_projects",
      "mcp__archon__manage_project",
      "mcp__archon__manage_task",
      "Bash(dir:*)",
      "Bash(echo:*)",
      "Bash(find:*)",
      "Bash(findstr /v /i \"node_modules .git .venv __pycache__ .pytest_cache\")"
    ]
  }
}
```

## Index

- **Total Files**: 27
- **Total Lines**: ~3,500 (estimated)
- **Languages**: Markdown, JSON
- **Technology Stack**: 
  - AI Coding Workflow System (markdown-based commands)
  - MCP Integration (Archon MCP, Web MCP servers)
  - Claude Code CLI
- **Dependencies**: 
  - Archon MCP server (task management, RAG knowledge base)
  - Web MCP servers (web search, page reading)
  - Claude Code CLI

## File Type Breakdown

| Type | Count | Description |
|------|-------|-------------|
| .md | 25 | Markdown files (commands, templates, documentation) |
| .json | 2 | JSON configuration files |

## Key Patterns

### Command Structure
- YAML frontmatter with name, description, phase, dependencies, outputs, inputs
- Markdown body with Purpose, Prerequisites, Execution Steps, Output Format, Error Handling, Notes

### PRP Templates
- Base template with Goal, All Needed Context, Implementation Blueprint, Validation Loop, Anti-Patterns
- Specialized templates extend base for AI Agent, MCP Integration, API Endpoint, Frontend Component

### Status Tracking
- STATUS.md template for feature progress tracking
- Phase checkboxes, artifacts list, next steps, checkpoint

### Index Files
- INDEX.md in each directory for navigation and file tracking
- Overview, file entries, navigation links

## Export Timestamp
2026-01-24T18:21:11Z
```

### context\\prime-2026-01-24T20-31-03Z.md
`$(@{Path=context\\prime-2026-01-24T20-31-03Z.md; Language=markdown; Lines=System.Object[]}.Language)
# Codebase Export: 2026-01-24T20:31:03Z

## Project Tree

```
AI Overload/
â”œâ”€â”€ .claude/
â”‚   â”œâ”€â”€ commands/
â”‚   â”‚   â”œâ”€â”€ prime.md
â”‚   â”‚   â”œâ”€â”€ discovery.md
â”‚   â”‚   â”œâ”€â”€ planning.md
â”‚   â”‚   â”œâ”€â”€ development.md
â”‚   â”‚   â”œâ”€â”€ task-planning.md
â”‚   â”‚   â”œâ”€â”€ execution.md
â”‚   â”‚   â”œâ”€â”€ review.md
â”‚   â”‚   â”œâ”€â”€ test.md
â”‚   â”‚   â”œâ”€â”€ template.md
â”‚   â”‚   â”œâ”€â”€ update-index.md
â”‚   â”‚   â”œâ”€â”€ update-status.md
â”‚   â”‚   â””â”€â”€ workflow.md
â”‚   â”œâ”€â”€ templates/
â”‚   â”‚   â””â”€â”€ STATUS.md
â”‚   â””â”€â”€ settings.json
â”œâ”€â”€ context/
â”‚   â”œâ”€â”€ INDEX.md
â”‚   â”œâ”€â”€ prime-2026-01-24T09-32-50Z.md
â”‚   â””â”€â”€ prime-2026-01-24T18-21-11Z.md
â”œâ”€â”€ discovery/
â”‚   â”œâ”€â”€ INDEX.md
â”‚   â””â”€â”€ discovery-2026-01-24T18-33-22Z.md
â”œâ”€â”€ execution/
â”‚   â”œâ”€â”€ INDEX.md
â”‚   â”œâ”€â”€ 01-create-directory-structure.md
â”‚   â”œâ”€â”€ 02-create-index-generator.md
â”‚   â”œâ”€â”€ (28 task files total)
â”œâ”€â”€ features/
â”‚   â”œâ”€â”€ INDEX.md
â”‚   â””â”€â”€ smart-reference-library/
â”‚       â”œâ”€â”€ prp.md
â”‚       â”œâ”€â”€ task-plan.md
â”‚       â”œâ”€â”€ STATUS.md
â”‚       â””â”€â”€ execution/
â”‚           â”œâ”€â”€ INDEX.md
â”‚           â”œâ”€â”€ 01-run-sql-migration.md
â”‚           â”œâ”€â”€ 02-create-learn-command.md
â”‚           â”œâ”€â”€ 03-create-learn-health-command.md
â”‚           â”œâ”€â”€ 04-update-prp-templates.md
â”‚           â”œâ”€â”€ 05-update-claude-md.md
â”‚           â”œâ”€â”€ 06-test-learn-command.md
â”‚           â””â”€â”€ 07-test-learn-health-command.md
â”œâ”€â”€ templates/
â”‚   â”œâ”€â”€ INDEX.md
â”‚   â””â”€â”€ prp/
â”‚       â”œâ”€â”€ prp-base.md
â”‚       â”œâ”€â”€ prp-ai-agent.md
â”‚       â”œâ”€â”€ prp-mcp-integration.md
â”‚       â”œâ”€â”€ prp-api-endpoint.md
â”‚       â””â”€â”€ prp-frontend-component.md
â”œâ”€â”€ reviews/
â”‚   â””â”€â”€ INDEX.md
â”œâ”€â”€ testing/
â”‚   â””â”€â”€ INDEX.md
â”œâ”€â”€ CLAUDE.md
â”œâ”€â”€ INDEX.md
â”œâ”€â”€ MVP.md
â”œâ”€â”€ PRD.md
â”œâ”€â”€ README.md
â””â”€â”€ TECH-SPEC.md
```

## Files

### .claude/commands/prime.md

```markdown
---
name: Prime
description: "Export entire codebase for context gathering with structured markdown output"
phase: prime
dependencies: []
outputs:
  - path: "context/prime-{timestamp}.md"
    description: "Structured markdown export of codebase"
  - path: "context/INDEX.md"
    description: "Index of all prime exports"
inputs: []
---

# Prime Command

## Purpose

Export the entire codebase for context gathering. This command traverses the project directory, respects ignore patterns, and generates a structured markdown export with tree structure and file contents. This provides comprehensive context for AI assistants to understand the codebase structure, patterns, and conventions.

## Execution Steps

### Step 1: Traverse Codebase
- Use Git to get list of tracked files: `git ls-files`
- Respect `.gitignore` and `.cursorignore` patterns
- Skip binary files (detect by extension: .png, .jpg, .gif, .pdf, .zip, etc.)
- Skip files larger than 10MB (log skipped files)
- Skip node_modules, .git, .venv, and other common ignore patterns

### Step 2: Generate Tree Structure
- Use `tree` command or custom traversal to generate directory structure
- Format as markdown code block with proper indentation
- Include file counts per directory

### Step 3: Export File Contents
- Read each file sequentially
- Wrap file contents in markdown code blocks with language tags (detect from extension)
- Include file path as heading (e.g., `### src/api/users.ts`)
- For very large files (>1000 lines), include first 500 and last 500 lines with note

### Step 4: Create Index
- Count files by language/type
- Calculate total lines of code
- List dependencies (from package.json, requirements.txt, etc. if detectable)
- Create summary statistics

### Step 5: Save Output
- Generate timestamp in ISO 8601 format: `YYYY-MM-DDTHH:mm:ssZ`
- Save to `context/prime-{timestamp}.md`
- Update `context/INDEX.md` with new entry:
  - Link to new prime export
  - Timestamp
  - File count and line count summary
```

### .claude/commands/discovery.md

```markdown
---
name: Discovery
description: "Explore ideas, inspiration, and needs for AI agents and AI/ATR applications"
phase: discovery
dependencies: [prime]
outputs:
  - path: "discovery/discovery-{timestamp}.md"
    description: "Discovery document with ideas, inspiration sources, needs analysis, and opportunities"
  - path: "discovery/INDEX.md"
    description: "Updated index of all discovery documents"
inputs:
  - path: "context/prime-{timestamp}.md"
    description: "Most recent codebase export from Prime command"
    required: true
---

# Discovery Command

## Purpose

Explore ideas, inspiration, and needs for AI agents and AI/ATR applications. This command loads the prime context, queries AI via MCP (using RAG knowledge base and web MCP servers), performs needs analysis, and generates a discovery document.
```

### .claude/commands/planning.md

```markdown
---
name: Planning
description: "Transform discovery insights into comprehensive PRD (Product Requirements Document)"
phase: planning
dependencies: [discovery]
outputs:
  - path: "PRD.md"
    description: "Product Requirements Document at root with features, user stories, acceptance criteria, and technical requirements"
inputs:
  - path: "discovery/discovery-{timestamp}.md"
    description: "Most recent discovery document with ideas, opportunities, and needs analysis"
    required: true
  - path: "MVP.md"
    description: "MVP definition at root"
    required: true
---

# Planning Command

## Purpose

Transform discovery insights into a comprehensive PRD (Product Requirements Document). This command loads the discovery document, extracts the feature name, creates the feature directory structure, researches PRD templates using RAG knowledge base and web MCP servers, generates PRD with features, user stories, acceptance criteria, and technical requirements, and updates indexes and STATUS.md.
```

### .claude/commands/development.md

```markdown
---
name: Development
description: "Analyze PRD requirements and generate comprehensive Tech Spec with technology stack recommendations"
phase: development
dependencies: [planning]
outputs:
  - path: "TECH-SPEC.md"
    description: "Technical Specification at root with system architecture, technology stack, implementation details, and recommendations"
inputs:
  - path: "PRD.md"
    description: "Product Requirements Document at root"
    required: true
  - path: "MVP.md"
    description: "MVP definition at root"
    required: true
---

# Development Command

## Purpose

Analyze PRD requirements and generate a comprehensive Tech Spec (Technical Specification). This command loads the PRD, uses RAG knowledge base and web MCP servers to research architecture patterns and tech stacks, recommends technology stack (backend, frontend, MCP servers, AI frameworks, models, agent architecture), and generates detailed tech spec with system architecture, technology stack, command structure, file system structure, data models, MCP integration, command implementation, error handling, performance, and security.
```

### .claude/commands/task-planning.md

```markdown
---
name: Task Planning
description: "Combine all contexts into actionable tasks with PRP guidance"
phase: task-planning
dependencies: [development]
outputs:
  - path: "features/{feature-name}/prp.md"
    description: "Plan Reference Protocol document with codebase-aware implementation guidance"
  - path: "features/{feature-name}/task-plan.md"
    description: "Task plan with task IDs, dependencies, and execution order"
  - path: "features/{feature-name}/STATUS.md"
    description: "Updated feature status tracking file"
  - path: "features/{feature-name}/execution/"
    description: "Execution folder with individual task files (deleted as tasks complete)"
inputs:
  - path: "context/prime-{timestamp}.md"
    description: "Most recent codebase export from Prime command"
    required: true
  - path: "discovery/discovery-{timestamp}.md"
    description: "Most recent discovery document"
    required: false
  - path: "MVP.md"
    description: "MVP definition at root"
    required: true
  - path: "PRD.md"
    description: "Product Requirements Document at root"
    required: true
  - path: "TECH-SPEC.md"
    description: "Technical Specification at root"
    required: true
---

# Task Planning Command

## Purpose

Combine all contexts (Prime, Discovery, PRD, Tech Spec) into actionable tasks with PRP guidance. This command loads all contexts, extracts codebase patterns, selects appropriate PRP template, generates PRP with codebase-aware context, breaks down tasks with dependencies, creates tasks in Archon MCP, and generates task plan document.
```

### .claude/commands/execution.md

```markdown
---
name: Execution
description: "Execute tasks step-by-step following task plan and PRP guidance"
phase: execution
dependencies: [task-planning]
outputs:
  - path: "features/{feature-name}/execution.md"
    description: "Execution log showing progress through tasks"
  - path: "features/{feature-name}/STATUS.md"
    description: "Updated status showing execution progress"
inputs:
  - path: "features/{feature-name}/task-plan.md"
    description: "Task plan with ordered tasks and dependencies"
    required: true
  - path: "features/{feature-name}/prp.md"
    description: "PRP document with implementation guidance"
    required: true
  - path: "features/{feature-name}/execution/"
    description: "Execution folder with individual task files"
    required: true
---

# Execution Command

## Purpose

Execute tasks step-by-step following the task plan and PRP guidance. This command loads the task plan and PRP, executes tasks sequentially using Archon MCP for tracking, handles errors with checkpoint/resume, and updates STATUS.md with progress.
```

### .claude/commands/review.md

```markdown
---
name: Review
description: "AI-powered code review with quality, security, and performance analysis"
phase: review
dependencies: [execution]
outputs:
  - path: "features/{feature-name}/review.md"
    description: "Code review report for feature"
  - path: "reviews/review-{timestamp}.md"
    description: "Timestamped review report in reviews directory"
  - path: "reviews/INDEX.md"
    description: "Updated index of all reviews"
  - path: "features/{feature-name}/STATUS.md"
    description: "Updated feature status tracking file"
inputs:
  - path: "context/prime-{timestamp}.md"
    description: "Baseline codebase export from Prime command"
    required: true
  - path: "features/{feature-name}/prd.md"
    description: "Product Requirements Document for compliance verification"
    required: true
  - path: "features/{feature-name}/tech-spec.md"
    description: "Technical Specification for compliance verification"
    required: true
  - path: "features/{feature-name}/execution.md"
    description: "Execution log with completed tasks"
    required: true
---

# Review Command

## Purpose

Perform AI-powered code review by identifying code changes, analyzing quality (best practices, security, performance), verifying compliance with PRD and tech spec, and generating a comprehensive review report with severity levels, fix recommendations, and code examples.
```

### .claude/commands/test.md

```markdown
---
name: Test
description: "Automated testing with error detection and AI-suggested fixes"
phase: test
dependencies: [execution]
outputs:
  - path: "features/{feature-name}/test-results.md"
    description: "Test results report for feature"
  - path: "testing/test-results-{timestamp}.md"
    description: "Timestamped test results in testing directory"
  - path: "testing/INDEX.md"
    description: "Updated index of all test results"
  - path: "features/{feature-name}/STATUS.md"
    description: "Updated feature status tracking file"
inputs:
  - path: "features/{feature-name}/prd.md"
    description: "Product Requirements Document for acceptance criteria verification"
    required: true
  - path: "features/{feature-name}/prp.md"
    description: "Plan Reference Protocol for test patterns and validation commands"
    required: true
  - path: "features/{feature-name}/execution.md"
    description: "Execution log with completed tasks"
    required: true
---

# Test Command

## Purpose

Automate testing with error detection and AI-suggested fixes. This command runs test suites (unit, integration, E2E), detects errors, uses AI to suggest fixes, generates coverage reports, verifies acceptance criteria, and stores test results.
```

### .claude/commands/template.md

```markdown
---
name: Command Name
description: "Brief description of what this command does"
phase: prime|discovery|planning|development|task-planning|execution|review|test
dependencies: []
outputs:
  - path: "relative/path/to/output.md"
    description: "Description of output"
inputs:
  - path: "relative/path/to/input.md"
    description: "Description of input"
    required: true|false
---

# Command Name

## Purpose

[Detailed description of command purpose]

This command [what it does]. It is used during the [phase] phase to [specific purpose].
```

### .claude/commands/update-index.md

```markdown
---
name: update-index
description: Update INDEX.md file with new file entry or regenerate from directory contents
phase: utility
inputs:
  - directory: Directory path containing INDEX.md (e.g., "context", "discovery", "features")
  - filename: Name of file to add (optional if regenerating)
  - description: Description of file (optional, auto-extracted if not provided)
  - timestamp: ISO 8601 timestamp (optional, defaults to current time)
  - is_directory: True if adding a subdirectory (for features/)
  - regenerate: If true, regenerate entire INDEX.md from directory contents
outputs:
  - Updated INDEX.md file with new entry
dependencies:
  - Directory must exist
  - INDEX.md may or may not exist (will create if missing)
---

# Update INDEX Command

## Purpose

Update or create INDEX.md files with file entries to provide navigation and tracking across the AI Coding Workflow System.
```

### .claude/commands/update-status.md

```markdown
---
name: update-status
description: Update STATUS.md file with phase progress, artifacts, and next steps
phase: utility
inputs:
  - feature_path: Path to feature directory (e.g., "features/ai-coding-workflow-system")
  - action: Action to perform - create, update-phase, add-artifact, update-next-steps, update-checkpoint
  - phase: Phase name to update (Prime, Discovery, Planning, Development, Task Planning, Execution, Review, Test)
  - completed: Whether phase is completed (true/false)
  - set_current: Whether to set as current phase (true/false)
  - artifact_name: Name of artifact file to add
  - artifact_description: Description of artifact (optional)
  - next_steps: Description of next steps
  - task_id: ID or description of last completed task (for checkpoint)
outputs:
  - Updated STATUS.md file
dependencies:
  - Feature directory must exist
  - STATUS.md may or may not exist (will create if missing)
---

# Update STATUS Command

## Purpose

Update or create STATUS.md files to track feature development progress through all phases of the workflow.
```

### .claude/commands/workflow.md

```markdown
---
name: Workflow
description: "Unified workflow command for complete development lifecycle"
phase: workflow
dependencies: [prime, discovery, planning, development, task-planning, execution, review, test]
outputs:
  - path: "features/{feature-name}/STATUS.md"
    description: "Updated feature status tracking file after each phase"
inputs:
  - path: "features/{feature-name}/STATUS.md"
    description: "Feature status tracking file for resume support"
    required: false
---

# Workflow Command

## Purpose

Execute the complete development lifecycle by running all phases sequentially. This command orchestrates Prime, Discovery, Planning, Development, Task Planning, Execution, Review, and Test phases with progress tracking, error handling, and resume support.
```

### .claude/templates/STATUS.md

```markdown
# Feature: {feature-name}

## Current Phase
Planning

## Progress

### Completed Phases
- [ ] Prime
- [ ] Discovery
- [ ] Planning
- [ ] Development
- [ ] Task Planning
- [ ] Execution
- [ ] Review
- [ ] Test

## Artifacts

### Generated Artifacts
_No artifacts generated yet._

### Pending Artifacts
- `prd.md` - To be created in Planning phase
- `tech-spec.md` - To be created in Development phase
- `prp.md` - To be created in Task Planning phase
- `task-plan.md` - To be created in Task Planning phase
- `execution.md` - To be created in Execution phase
- `review.md` - To be created in Review phase
- `test-results.md` - To be created in Test phase
... [truncated: showing first 500 and last 500 lines] ...

```markdown
# Context Index

## Overview
This directory contains codebase context exports from the Prime command. Each export is a complete snapshot of the codebase at a specific point in time, including file tree structure and file contents.

## Files

### prime-2026-01-24T18-21-11Z.md
- **Created**: 2026-01-24T18:21:11Z
- **Description**: Complete codebase export from Prime command
- **File Count**: 27 files
- **Total Lines**: ~3,500 lines
- **Link**: [View Export](./prime-2026-01-24T18-21-11Z.md)

### prime-2026-01-24T09-32-50Z.md
- **Created**: 2026-01-24T09:32:50Z
- **Description**: Complete codebase export from Prime command
- **File Count**: 47 files
- **Total Lines**: ~4,200 lines
- **Link**: [View Export](./prime-2026-01-24T09-32-50Z.md)

## Navigation
- [Back to Root](../)
- [Discovery](../discovery/)
- [Features](../features/)
```

### discovery/INDEX.md

```markdown
# Discovery Index

## Overview
This directory contains discovery phase outputs. Discovery documents explore ideas, inspiration, and needs for AI agents and AI/ATR applications, identifying opportunities and prioritizing features.

## Files

### discovery-2026-01-24T18-33-22Z.md
- **Created**: 2026-01-24T18:33:22Z
- **Description**: Discovery for AI Coding Workflow System enhancements
- **Ideas**: 8 AI agent opportunities identified
- **Top Priority**: Workflow Automation Agent, Code Generation, Automated Review
- **Recommended MVP**: Enhanced Workflow System with Code Generation
- **Link**: [View Discovery](./discovery-2026-01-24T18-33-22Z.md)

## Navigation
- [Back to Root](../)
- [Context](../context/)
- [Features](../features/)
```

### execution/INDEX.md

```markdown
# Execution Directory

This directory contains task execution documents linked to Archon MCP tasks. Each file represents a numbered task in the AI Coding Workflow System implementation.

## Purpose
- Track implementation tasks with detailed steps
- Link Archon tasks to documentation
- Provide implementation guidance
- Track completion status

## Tasks

| # | Task | Status | Description |
|---|------|--------|-------------|
| 01 | [Create Directory Structure](01-create-directory-structure.md) | Done | Create project directory structure |
| 02 | [Create INDEX.md Generator](02-create-index-generator.md) | Done | Implement INDEX.md generation utility |
| 03 | [Create STATUS.md Format](03-create-status-format.md) | Done | Implement STATUS.md tracking format |
| 04 | [Create Command Template](04-create-command-template.md) | Done | Create reusable command template |
| 05 | [Implement Prime Command](05-implement-prime-command.md) | Done | Export codebase context |
| 06 | [Implement Discovery Command](06-implement-discovery-command.md) | Done | Explore ideas with RAG/web research |
| 07 | [Implement Planning Command](07-implement-planning-command.md) | Done | Generate PRD from discovery |
| 08 | [Implement Development Command](08-implement-development-command.md) | Done | Generate TECH-SPEC from PRD |
| 09 | [Create PRP Base Template](09-create-prp-base-template.md) | Done | Base template for task plans |
| 10 | [Create PRP Specialized Templates](10-create-prp-specialized-templates.md) | Done | Specialized PRP templates |
| 11 | [Implement Pattern Extraction](11-implement-pattern-extraction.md) | Done | Extract codebase patterns |
| 12 | [Implement Task Planning Command](12-implement-task-planning-command.md) | Done | Generate PRP and create tasks |
| 13 | [Implement Execution Command](13-implement-execution-command.md) | Done | Execute tasks from PRP |
| 14 | [Implement Review Command](14-implement-review-command.md) | Done | Code review and analysis |
| 15 | [Implement Test Command](15-implement-test-command.md) | Done | Run tests and generate reports |
| 16 | [Implement Workflow Command](16-implement-workflow-command.md) | Done | Unified workflow with resume |
| 17 | [Implement Error Handling](17-implement-error-handling.md) | Done | Comprehensive error handling |
| 18 | [Integrate Archon MCP](18-integrate-archon-mcp.md) | Done | Archon MCP integration |
| 19 | [Integrate Web MCP Servers](19-integrate-web-mcp-servers.md) | Done | Web MCP integration |
| 20 | [End-to-End Testing](20-end-to-end-testing.md) | Done | Full system testing |
| 21 | [Create Main INDEX.md](21-create-main-index.md) | Done | Root navigation index |
| 22 | [Create README.md](22-create-readme.md) | Done | Project documentation |
| 23 | [Performance Optimization](23-performance-optimization.md) | Done | System optimization |
| 24 | [System Validation](24-system-validation-final-testing.md) | Done | Final validation testing |
| 25 | [Documentation Review](25-documentation-review-updates.md) | Done | Documentation audit |
| 26 | [Security Audit](26-security-audit-hardening.md) | Done | Security hardening |
| 27 | [UAT Preparation](27-user-acceptance-testing-preparation.md) | Done | User testing prep |
| 28 | [Deployment Handoff](28-system-deployment-handoff.md) | Done | Final deployment |

## Links
- [../INDEX.md](../INDEX.md) - Root index
- [../.claude/commands/](../.claude/commands/) - Command files
- [../features/](../features/) - Feature implementations
```

### features/INDEX.md

```markdown
# Features Index

## Overview
This directory contains all feature-specific artifacts organized by feature name. Each feature has its own subdirectory with PRD, tech spec, PRP, task plans, execution logs, reviews, and test results.

## Features

### smart-reference-library
- **Status**: Task Planning Completed
- **Description**: Token-efficient reference library with /learn and /learn-health commands
- **Phase**: Ready for Execution
- **Artifacts**:
  - [PRP](./smart-reference-library/prp.md)
  - [Task Plan](./smart-reference-library/task-plan.md)
  - [STATUS](./smart-reference-library/STATUS.md)
- **Archon Project ID**: `acf45b67-51aa-475d-b4cc-7c1055b4a032`

## Navigation
- [Back to Root](../)
- [Context](../context/)
- [Discovery](../discovery/)
```

### features/smart-reference-library/STATUS.md

```markdown
# STATUS: Smart Reference Library

**Feature**: Smart Reference Library
**Created**: 2026-01-24
**Current Phase**: Task Planning - Completed

## Phase Progress

| Phase | Status | Completed |
|-------|--------|-----------|
| Discovery | Completed | 2026-01-24 |
| MVP | Completed | 2026-01-24 |
| Planning (PRD) | Completed | 2026-01-24 |
| Development (TECH-SPEC) | Completed | 2026-01-24 |
| Task Planning | Completed | 2026-01-24 |
| Execution | Not Started | - |
| Review | Not Started | - |
| Test | Not Started | - |

## Current Phase: Execution

**Next Task**: Run SQL migration for archon_references table

## Artifacts

| Artifact | Path | Status |
|----------|------|--------|
| MVP | `MVP.md` | Complete |
| PRD | `PRD.md` | Complete |
| TECH-SPEC | `TECH-SPEC.md` | Complete |
| SQL Migration | `Archon MCP/migration/012_add_smart_reference_library.sql` | Complete |
| PRP | `features/smart-reference-library/prp.md` | Complete |
| Task Plan | `features/smart-reference-library/task-plan.md` | Complete |
| /learn command | `.claude/commands/learn.md` | Pending |
| /learn-health command | `.claude/commands/learn-health.md` | Pending |

## Archon Project

**Project ID**: `acf45b67-51aa-475d-b4cc-7c1055b4a032`
**Tasks Created**: 7

## Notes

- Uses dedicated `archon_references` table (not project docs JSONB)
- Direct SQL via Supabase (not Archon MCP document tools)
- RAG search for topic research, LLM for digest
- User approval required before storage
```

### features/smart-reference-library/prp.md

```markdown
# PRP: Smart Reference Library

**Version**: 1.0 | **Last Updated**: 2026-01-24 | **Related**: MVP.md, PRD.md, TECH-SPEC.md

## Goal

### Feature Goal
Build a token-efficient reference library with `/learn` and `/learn-health` commands that stores digested coding insights in a dedicated Supabase table, enabling selective context loading based on current task needs.

### Deliverable
- SQL migration: `012_add_smart_reference_library.sql` (created)
- Command: `.claude/commands/learn.md`
- Command: `.claude/commands/learn-health.md`
- Updated: `templates/prp/prp-base.md` with Reference Library section
- Updated: `CLAUDE.md` with Reference Library documentation

### Success Criteria
- `/learn {topic}` searches RAG/web, digests findings, stores approved insights
- `/learn-health` displays category stats, health percentage, suggestions
- PRP templates can specify required reference categories
- References stored in dedicated `archon_references` table (not project docs)

## All Needed Context

### Documentation URLs
- Supabase SQL reference: https://supabase.com/docs/guides/database
- Archon RAG API: See `mcps/user-archon/tools/*.json`

### Codebase Patterns
- Commands use YAML frontmatter + markdown body
- Commands define inputs, outputs, execution steps
- Existing commands: `.claude/commands/*.md`

### File References
- Command template: `.claude/commands/template.md`
- Existing commands: `prime.md`, `discovery.md`, `planning.md`, `development.md`
- PRP base template: `templates/prp/prp-base.md`

### Naming Conventions
- Commands: lowercase with hyphens (e.g., `learn-health.md`)
- Supabase tables: `archon_` prefix (e.g., `archon_references`)
- Indexes: `idx_archon_references_{column}`

### Architecture Patterns
- Direct SQL via Supabase (not Archon MCP documents)
- RAG search for topic research
- LLM digest for insight extraction
- User approval before storage

## Implementation Blueprint

### Data Models

**archon_references table** (already defined in migration):
```sql
- id: UUID PRIMARY KEY
- title: TEXT NOT NULL
- category: TEXT NOT NULL (python, mcp, react, etc.)
- tags: TEXT[] (additional tags)
- content: JSONB (summary, insights, code_examples, sources)
- source_url: TEXT
- author: TEXT
- created_at, updated_at: TIMESTAMPTZ
```

**Content JSONB structure**:
```json
{
  "summary": "string",
  "insights": ["string"],
  "code_examples": [{"title": "", "language": "", "code": ""}],
  "sources": ["url"],
  "learned_at": "timestamp"
}
```

### Implementation Tasks

| Order | Task | Dependencies | Estimate |
|-------|------|--------------|----------|
| 1 | Run SQL migration | None | 5 min |
| 2 | Create /learn command | Migration done | 1 hour |
| 3 | Create /learn-health command | Migration done | 45 min |
| 4 | Update PRP templates | Commands done | 30 min |
| 5 | Update CLAUDE.md | Commands done | 30 min |
| 6 | Test /learn command | All above | 30 min |
| 7 | Test /learn-health command | All above | 30 min |

### File Structure

```
.claude/commands/
â”œâ”€â”€ learn.md              # New
â”œâ”€â”€ learn-health.md       # New
â””â”€â”€ ... (existing)

templates/prp/
â”œâ”€â”€ prp-base.md           # Update (add Reference Library section)
â””â”€â”€ ... (existing)

features/smart-reference-library/
â”œâ”€â”€ prp.md                # This file
â”œâ”€â”€ task-plan.md          # Task tracking
â””â”€â”€ STATUS.md             # Progress tracking

Archon MCP/migration/
â””â”€â”€ 012_add_smart_reference_library.sql  # Created
```

### Integration Points

**Supabase Direct SQL**:
- INSERT for storing references
- SELECT for querying by category/tags
- GROUP BY for stats calculation

**Archon RAG**:
- `rag_search_knowledge_base(query, match_count)` for topic research
- `rag_read_full_page(page_id)` for full content

**Web Search** (fallback):
- WebSearch tool if RAG returns no results

## Validation Loop

### Syntax Validation
- YAML frontmatter valid in command files
- SQL migration runs without errors
- Markdown formatting correct

### Unit Tests
- SQL: Insert/query references manually in Supabase
- Commands: Verify YAML parsing works

### Integration Tests
- `/learn python async`: Full flow from search to storage
- `/learn-health`: Stats calculation with test data

### End-to-End Tests
1. Run migration in Supabase
2. Execute `/learn mcp server patterns`
3. Approve digest
4. Verify row in `archon_references`
5. Run `/learn-health`
6. Verify stats show new reference

## Anti-Patterns

### General Anti-Patterns
- Skipping user approval before storage
- Storing raw content instead of digested insights
- Preloading all references in CLAUDE.md
- Using Archon project docs instead of dedicated table

### Feature-Specific Anti-Patterns
- Long RAG queries (keep to 2-5 keywords)
- Storing non-technical content
- Missing category/tags on references
- Not handling Supabase connection errors
```

### features/smart-reference-library/task-plan.md

```markdown
# Task Plan: Smart Reference Library

**Generated**: 2026-01-24T11:24:00Z
**PRP Version**: 1.0
**Total Tasks**: 7
**Archon Project ID**: `acf45b67-51aa-475d-b4cc-7c1055b4a032`

## Task List

| Task ID | Task Title | Dependencies | Priority | Estimate | Status |
|---------|------------|--------------|----------|----------|--------|
| `da02cd4b-208c-48ca-9089-88edb1ee47ef` | Run SQL migration for archon_references table | None | 100 | 5 min | todo |
| `4e570391-cbeb-4439-90c3-ead0254137f2` | Create /learn command file | Task 1 | 90 | 1 hour | todo |
| `ed1fea70-2c91-4a98-9d2b-2655f49f58b8` | Create /learn-health command file | Task 1 | 80 | 45 min | todo |
| `a259b76e-7201-4f80-9f61-894dbfdaaedc` | Update PRP templates with Reference Library section | Tasks 2,3 | 70 | 30 min | todo |
| `28e0409f-b91b-4bee-be20-23176ab8ea8b` | Update CLAUDE.md with Reference Library documentation | Tasks 2,3 | 60 | 30 min | todo |
| `3fa7bbe6-2ebd-4e7a-bf70-cdca8cea43b5` | Test /learn command end-to-end | Tasks 1-5 | 50 | 30 min | todo |
| `40648c16-1af0-4d2e-9e59-83df45e0421a` | Test /learn-health command | Tasks 1-5 | 40 | 30 min | todo |

## Execution Order

1. **Task da02cd4b**: Run SQL migration for archon_references table
2. **Task 4e570391**: Create /learn command file
3. **Task ed1fea70**: Create /learn-health command file
4. **Task a259b76e**: Update PRP templates with Reference Library section
5. **Task 28e0409f**: Update CLAUDE.md with Reference Library documentation
6. **Task 3fa7bbe6**: Test /learn command end-to-end
7. **Task 40648c16**: Test /learn-health command

## Next Steps

1. Run migration `012_add_smart_reference_library.sql` in Supabase SQL Editor
2. Mark Task 1 as `doing` then `done` in Archon
3. Proceed to Task 2: Create /learn command
4. Track progress in Archon MCP

## Commands

```bash
# Mark task as doing
manage_task("update", task_id="da02cd4b-208c-48ca-9089-88edb1ee47ef", status="doing")

# Mark task as done
manage_task("update", task_id="da02cd4b-208c-48ca-9089-88edb1ee47ef", status="done")

# Get next todo task
find_tasks(filter_by="status", filter_value="todo")
```
```

### templates/INDEX.md

```markdown
# Templates Index

## Overview
This directory contains template files for the AI Coding Workflow System, including PRP (Plan Reference Protocol) templates.

## Templates

### PRP Templates
- [PRP Base Template](./prp/prp-base.md)
- [PRP AI Agent Template](./prp/prp-ai-agent.md)
- [PRP MCP Integration Template](./prp/prp-mcp-integration.md)
- [PRP API Endpoint Template](./prp/prp-api-endpoint.md)
- [PRP Frontend Component Template](./prp/prp-frontend-component.md)

## Navigation
- [Back to Root](../)
- [Features](../features/)
```

### reviews/INDEX.md

```markdown
# Reviews Index

## Overview

This directory contains code review reports generated by the Review command. Reviews analyze code quality, security, performance, and compliance with PRD and tech spec.

## Files

_No review reports yet._

## Navigation

- [Back to Root](../)
- [Features](../features/)
- [Testing](../testing/)
```

### testing/INDEX.md

```markdown
# Testing Index

## Overview

This directory contains test execution results generated by the Test command. Test results include test outcomes, coverage analysis, and AI-suggested fixes.

## Files

_No test results yet._

## Navigation

- [Back to Root](../)
- [Features](../features/)
- [Reviews](../reviews/)
```

## Index

### Statistics
- **Total Files**: 97 files
- **Total Lines**: ~15,000 lines (estimated)
- **Languages**:
  - Markdown: 97 files
  - JSON: 1 file
- **Dependencies**:
  - Claude Code CLI
  - Archon MCP server
  - Web MCP servers (optional)
  - Supabase (for Smart Reference Library feature)

### File Type Breakdown
- Command files: 12 (.claude/commands/)
- Template files: 6 (templates/)
- Core documentation: 5 (root level)
- Index files: 7 (various directories)
- Feature artifacts: 3 (features/smart-reference-library/)
- Task execution files: 28 (execution/)
- Context exports: 2 (context/)
- Discovery documents: 1 (discovery/)

### Key Components

1. **Command System**: 12 markdown-based workflow commands
2. **Template System**: PRP templates for various feature types
3. **Feature Tracking**: STATUS.md and task-plan.md for progress
4. **Documentation**: PRD, TECH-SPEC, MVP, README, CLAUDE.md
5. **Integration**: Archon MCP for task management and knowledge base
6. **Smart Reference Library**: Token-efficient reference system (in development)

### Project Status
- **Version**: 1.0
- **Last Updated**: 2026-01-24
- **Current Status**: In Development
- **Active Feature**: Smart Reference Library (Task Planning completed, ready for Execution)
```

### discovery\\discovery-2026-01-24T18-33-22Z.md
`$(@{Path=discovery\\discovery-2026-01-24T18-33-22Z.md; Language=markdown; Lines=System.Object[]}.Language)
# Discovery: 2026-01-24T18:33:22Z

## Codebase Overview

### Project Structure
This is an **AI Coding Workflow System** - a markdown-based command system for orchestrating AI-assisted development workflows through MCP integration. The codebase provides a complete development lifecycle framework from context gathering to implementation, review, and testing.

**Key Directories:**
- `.claude/commands/` - 12 workflow command files defining each phase
- `templates/prp/` - 5 PRP templates for different feature types
- `context/` - Prime exports (codebase snapshots)
- `discovery/` - Discovery documents (this phase)
- `features/` - Feature artifacts (PRD, tech-spec, PRP, task-plan)
- `reviews/` - Code review reports
- `testing/` - Test results

### Technology Stack
- **Core**: Markdown-based command system (YAML frontmatter + Markdown body)
- **Task Management**: Archon MCP server (primary, per ARCHON-FIRST RULE)
- **Knowledge Base**: Archon RAG (Pydantic AI docs, Supabase docs indexed)
- **AI Integration**: Claude Code CLI
- **MCP Protocol**: Tool calls, resources, prompts

### Patterns and Conventions
- **Command Structure**: YAML frontmatter (name, description, phase, dependencies, inputs, outputs) + Markdown body (Purpose, Execution Steps, Output Format, Error Handling, Notes)
- **PRP Templates**: Goal, All Needed Context, Implementation Blueprint, Validation Loop, Anti-Patterns
- **Status Tracking**: STATUS.md per feature with phase checkboxes, artifacts, checkpoints
- **Naming**: kebab-case for feature names, ISO 8601 timestamps

## Ideas for AI Agents

### High Priority

1. **Workflow Automation Agent**
   - Automate the PIV loop (Prime â†’ Discovery â†’ Planning â†’ etc.)
   - Natural language command interpretation
   - Intelligent phase skipping based on context
   - **Impact**: High - Reduces manual orchestration overhead
   - **Feasibility**: High - Structure already exists in commands

2. **Code Generation Agent**
   - Generate implementation code from PRP blueprints
   - Follow codebase patterns automatically
   - Validate against tech-spec and acceptance criteria
   - **Impact**: High - Accelerates development phase
   - **Feasibility**: High - PRP provides structured guidance

3. **Context-Aware Review Agent**
   - Automated code review against PRD/tech-spec
   - Security, performance, and compliance analysis
   - Actionable fix recommendations with code examples
   - **Impact**: High - Quality assurance automation
   - **Feasibility**: Medium - Requires sophisticated analysis

### Medium Priority

4. **RAG Knowledge Curator**
   - Automatically index new documentation sources
   - Keep knowledge base current with framework updates
   - Suggest relevant sources based on project type
   - **Impact**: Medium - Improves research quality
   - **Feasibility**: High - Archon MCP already has RAG tools

5. **Test Generation Agent**
   - Generate tests from acceptance criteria
   - Create test fixtures from data models
   - Suggest edge cases and coverage improvements
   - **Impact**: Medium - Improves test coverage
   - **Feasibility**: Medium - Requires understanding of test patterns

6. **Documentation Sync Agent**
   - Keep PRD, tech-spec, and implementation in sync
   - Detect drift between docs and code
   - Auto-update STATUS.md and INDEX.md files
   - **Impact**: Medium - Reduces documentation burden
   - **Feasibility**: High - File patterns are well-defined

### Low Priority

7. **Multi-Feature Coordinator**
   - Orchestrate multiple features in parallel
   - Detect and resolve conflicts
   - Prioritize based on dependencies
   - **Impact**: Medium - Scales to larger projects
   - **Feasibility**: Low - Complex orchestration logic

8. **Template Evolution Agent**
   - Learn from successful implementations
   - Improve PRP templates based on outcomes
   - Suggest new template variations
   - **Impact**: Low - Meta-improvement
   - **Feasibility**: Low - Requires learning mechanism

## Inspiration Sources

### Documentation

| Source | URL | Key Insights |
|--------|-----|--------------|
| Google Cloud Agentic AI Patterns | cloud.google.com/architecture/choose-design-pattern-agentic-ai-system | Design pattern selection, single vs multi-agent systems |
| Microsoft AI Agent Orchestration | learn.microsoft.com/en-us/azure/architecture/ai-ml/guide/ai-agent-design-patterns | Multi-agent architectures, specialization patterns |
| OpenAI Building Agents Guide | openai.com/business/guides | When to build agents, core characteristics |
| Anthropic Building Effective Agents | resources.anthropic.com/building-effective-ai-agents | Sequential/parallel/evaluator patterns |
| MCP Best Practices | mcp-best-practice.github.io/mcp-best-practice | Transport patterns, gateway architecture |

### Examples

| Source | URL | Key Insights |
|--------|-----|--------------|
| Pydantic AI Framework | ai.pydantic.dev | Python agent framework, type-safe tools, MCP integration |
| OpenAI Agents Python | openai.github.io/openai-agents-python | MCP tool integration, agent patterns |

### Best Practices

1. **Single Responsibility**: One MCP server per domain with clear boundaries
2. **Bounded Toolsets**: Focused tools rather than "kitchen-sink" servers
3. **Strict Schemas**: Typed inputs/outputs with explicit constraints
4. **Stateless Execution**: Scalable, predictable behavior
5. **Human-in-the-Loop**: Approval paths for high-impact actions
6. **Context Management**: Efficient handling of model context windows

## Needs Analysis

### Current Gaps

1. **No Actual Code Generation**: Commands define structure but don't generate implementation code
2. **Manual Phase Execution**: Each command runs independently, requiring manual orchestration
3. **Limited Error Recovery**: Checkpoint system exists but recovery is manual
4. **No Continuous Integration**: No automated testing pipeline
5. **Static Templates**: PRP templates are static, not learning from outcomes

### Improvement Opportunities

1. **Unified Workflow Command Enhancement**: The `/workflow` command exists but could be smarter about phase dependencies and error recovery
2. **Better MCP Integration**: Currently uses Archon MCP for tasks/RAG, could expand to browser automation, more knowledge sources
3. **Code Pattern Extraction**: Prime export captures code but doesn't extract reusable patterns automatically
4. **Validation Automation**: Validation Loop in PRP is documented but not automatically executed

### Emerging Opportunities

1. **Multi-Agent Orchestration**: Use multiple specialized agents (researcher, coder, reviewer, tester)
2. **Streaming Outputs**: Real-time progress feedback during long operations
3. **Memory Persistence**: Cross-session context for ongoing projects
4. **Tool Discovery**: Dynamic tool discovery from MCP servers at runtime

## Opportunities

| Opportunity | Impact | Feasibility | Priority | Effort Estimate |
|-------------|--------|-------------|----------|-----------------|
| Workflow Automation Agent | High | High | High | 2-3 days |
| Code Generation from PRP | High | High | High | 3-5 days |
| Automated Code Review | High | Medium | High | 2-4 days |
| RAG Knowledge Curator | Medium | High | Medium | 1-2 days |
| Test Generation Agent | Medium | Medium | Medium | 2-3 days |
| Documentation Sync | Medium | High | Medium | 1 day |
| Multi-Feature Coordinator | Medium | Low | Low | 1 week+ |
| Template Evolution | Low | Low | Low | 1 week+ |

## Next Steps

### Recommended MVP Focus

Based on analysis, the **highest-value MVP** would be:

**Enhanced Workflow System with Code Generation**

1. **Improve `/workflow` command** to be fully autonomous with better error recovery
2. **Add code generation capability** during `/execution` phase using PRP blueprints
3. **Automate validation** using commands from PRP Validation Loop section

This builds on existing infrastructure while adding the most impactful missing capability (actual code generation).

### Immediate Actions

1. Run `/planning workflow-enhancement` to create PRD for workflow improvements
2. Focus on single-agent architecture first (simpler, faster to implement)
3. Leverage existing PRP templates and command structure
4. Use Archon MCP for task tracking throughout

### Architecture Recommendation

- **Pattern**: Single agent with multiple tools (per Google Cloud guidance)
- **MCP Integration**: Continue using Archon as primary, add browser MCP for testing
- **Error Handling**: Implement checkpoint/resume with automatic retry
- **Human-in-the-Loop**: Confirm before destructive operations

## Timestamp
2026-01-24T18:33:22Z
```

### discovery\\INDEX.md
`$(@{Path=discovery\\INDEX.md; Language=markdown; Lines=System.Object[]}.Language)
# Discovery Index

## Overview
This directory contains discovery phase outputs. Discovery documents explore ideas, inspiration, and needs for AI agents and AI/ATR applications, identifying opportunities and prioritizing features.

## Files

### discovery-2026-01-24T18-33-22Z.md
- **Created**: 2026-01-24T18:33:22Z
- **Description**: Discovery for AI Coding Workflow System enhancements
- **Ideas**: 8 AI agent opportunities identified
- **Top Priority**: Workflow Automation Agent, Code Generation, Automated Review
- **Recommended MVP**: Enhanced Workflow System with Code Generation
- **Link**: [View Discovery](./discovery-2026-01-24T18-33-22Z.md)

## Navigation
- [Back to Root](../)
- [Context](../context/)
- [Features](../features/)
```

### execution\\01-create-directory-structure.md
`$(@{Path=execution\\01-create-directory-structure.md; Language=markdown; Lines=System.Object[]}.Language)
---
archon_task_id: 650fbde8-847a-499a-b1c7-205ead5b14e1
project_id: 49e7f3a1-d9c5-439f-aa5f-2cdf4fec5b61
status: done
task_order: 127
assignee: User
created_at: 2026-01-23T16:32:49.181511+00:00
updated_at: 2026-01-23T16:37:57.980383+00:00
---

# 01: Create Directory Structure

**Status:** Done

## Description
Create context/, discovery/, features/, templates/prp/, reviews/, testing/ directories with INDEX.md files.

## Implementation Steps

### Create Directories
- [ ] Create context/ directory
- [ ] Create discovery/ directory
- [ ] Create features/ directory
- [ ] Create templates/ directory
- [ ] Create templates/prp/ directory
- [ ] Create reviews/ directory
- [ ] Create testing/ directory
- [ ] Create execution/ directory

### Create INDEX.md Files
- [ ] context/INDEX.md
- [ ] discovery/INDEX.md
- [ ] features/INDEX.md
- [ ] templates/INDEX.md
- [ ] templates/prp/INDEX.md
- [ ] reviews/INDEX.md
- [ ] testing/INDEX.md
- [ ] execution/INDEX.md

### INDEX.md Content
- [ ] Directory purpose description
- [ ] File listing (empty initially)
- [ ] Navigation links

### Git Integration
- [ ] Add directories to .gitignore if needed
- [ ] Ensure INDEX.md files are tracked
- [ ] Document structure in README

### Validation
- [ ] Verify all directories created
- [ ] Check INDEX.md files exist
- [ ] Test navigation links

## References
- PRD.md - Directory structure specification
- .gitignore - Git configuration
```

### execution\\02-create-index-generator.md
`$(@{Path=execution\\02-create-index-generator.md; Language=markdown; Lines=System.Object[]}.Language)
---
archon_task_id: 003f73e6-422a-4e51-bfbd-84876c859f23
project_id: 49e7f3a1-d9c5-439f-aa5f-2cdf4fec5b61
status: done
task_order: 125
assignee: User
created_at: 2026-01-23T16:32:50.395773+00:00
updated_at: 2026-01-23T16:39:14.872145+00:00
---

# 02: Create INDEX.md Generator

**Status:** Done

## Description
Implement INDEX.md generation utility with template format, auto-update on file creation, navigation links.

## Implementation Steps

### INDEX.md Template Design
- [ ] Define standard INDEX.md structure:
  - Directory purpose
  - File listing
  - Navigation links
  - Quick reference
- [ ] Create template for consistency

### Directory Structure Scan
- [ ] Use Glob to scan directory contents
- [ ] Filter by file type
- [ ] Sort files alphabetically
- [ ] Generate markdown listing

### Auto-Update Mechanism
- [ ] Integrate with file creation commands
- [ ] Update INDEX.md when files added
- [ ] Maintain existing content
- [ ] Preserve custom sections

### Root INDEX.md
- [ ] Create root INDEX.md
- [ ] Add project overview
- [ ] Link to all subdirectory INDEX.md files

### Subdirectory INDEX.md Files
- [ ] Create INDEX.md in:
  - context/
  - discovery/
  - features/
  - templates/
  - templates/prp/
  - reviews/
  - testing/
  - execution/

### Navigation Links
- [ ] Add breadcrumb navigation
- [ ] Link to parent directories
- [ ] Link to sibling directories
- [ ] Link to child directories

### /update-index Command
- [ ] Create .claude/commands/update-index.md
- [ ] Generate or update INDEX.md for specified directory
- [ ] Support recursive updates

## References
- PRD.md - Directory structure requirements
- .claude/commands/update-index.md - Update command
```

### execution\\03-create-status-format.md
`$(@{Path=execution\\03-create-status-format.md; Language=markdown; Lines=System.Object[]}.Language)
---
archon_task_id: edf78628-b7ba-4130-8a57-6cc720383745
project_id: 49e7f3a1-d9c5-439f-aa5f-2cdf4fec5b61
status: done
task_order: 123
assignee: User
created_at: 2026-01-23T16:32:51.755777+00:00
updated_at: 2026-01-23T16:40:33.510065+00:00
---

# 03: Create STATUS.md Format

**Status:** Done

## Description
Implement STATUS.md format with phase tracking, checkboxes, artifact listing, next steps.

## Implementation Steps

### Format Design
- [ ] Define STATUS.md structure
- [ ] Create template for reuse
- [ ] Document STATUS.md conventions

### Phase Tracking Section
- [ ] List all workflow phases:
  - Prime
  - Discovery
  - Planning
  - Development
  - Task Planning
  - Execution
  - Review
  - Testing
- [ ] Add completion checkboxes
- [ ] Include timestamps

### Feature Tracking Section
- [ ] Table/list of features
- [ ] Current phase per feature
- [ ] Completion percentage
- [ ] Links to feature directories

### Artifacts Section
- [ ] List generated documents
- [ ] Categorize by type:
  - PRD documents
  - TECH-SPEC documents
  - PRP documents
  - Discovery documents
  - Review reports
  - Test reports

### Next Steps Section
- [ ] Current work items
- [ ] Blocking issues
- [ ] Upcoming tasks

### Root STATUS.md
- [ ] Create root STATUS.md
- [ ] Initialize with project status

### Feature STATUS.md
- [ ] Create STATUS.md template for features/
- [ ] Include feature-specific tracking

## References
- PRD.md - Workflow phases
- features/ directory - Feature locations
```

### execution\\04-create-command-template.md
`$(@{Path=execution\\04-create-command-template.md; Language=markdown; Lines=System.Object[]}.Language)
---
archon_task_id: 410e2f15-0bc1-43ac-967f-8d016bfb8659
project_id: 49e7f3a1-d9c5-439f-aa5f-2cdf4fec5b61
status: done
task_order: 121
assignee: User
created_at: 2026-01-23T16:32:53.505844+00:00
updated_at: 2026-01-23T16:41:09.804525+00:00
---

# 04: Create Command Template Structure

**Status:** Done

## Description
Create command template with YAML frontmatter, markdown sections, save to .claude/commands/template.md.

## Implementation Steps

### YAML Frontmatter Design
- [ ] Define required fields:
  - name: Command name
  - description: Short description
  - parameters: Command parameters
  - version: Template version
- [ ] Define optional fields:
  - author: Creator
  - tags: For categorization
  - dependencies: Other commands/MCPs required

### Markdown Structure
- [ ] Title section (#)
- [ ] Description section
- [ ] Parameters section
- [ ] Prerequisites section
- [ ] Implementation Steps section
- [ ] Validation section
- [ ] References section

### Template Creation
- [ ] Create .claude/commands/ directory
- [ ] Create template.md
- [ ] Add usage examples
- [ ] Include best practices

### Documentation
- [ ] Comment each section
- [ ] Provide examples for each field
- [ ] Include parameter type definitions

## References
- PRD.md - Command system requirements
- .claude/commands/ directory - Command files
```

### execution\\05-implement-prime-command.md
`$(@{Path=execution\\05-implement-prime-command.md; Language=markdown; Lines=System.Object[]}.Language)
---
archon_task_id: f040f883-989e-453e-96f0-0d11da1eb62f
project_id: 49e7f3a1-d9c5-439f-aa5f-2cdf4fec5b61
status: done
task_order: 119
assignee: User
created_at: 2026-01-23T16:32:55.449094+00:00
updated_at: 2026-01-23T16:42:10.285648+00:00
---

# 05: Implement Prime Command

**Status:** Done

## Description
Create .claude/commands/prime.md - traverse codebase, export tree/contents, save to context/prime-{timestamp}.md.

## Implementation Steps

### Command Structure
- [ ] Create prime.md with YAML frontmatter
- [ ] Define command options
- [ ] Document export format

### Codebase Traversal
- [ ] Use Glob to discover all files
- [ ] Filter out common exclusions:
  - node_modules/
  - .git/
  - build/
  - dist/
  - *.log
  - .env files
- [ ] Organize by directory structure

### Content Export
- [ ] Generate file tree structure
- [ ] Read file contents with metadata:
  - File path
  - Line count
  - Language/extension
  - Last modified
- [ ] Format as structured markdown

### Output File Creation
- [ ] Create context/ directory if needed
- [ ] Save to context/prime-{timestamp}.md
- [ ] Include generation timestamp

### Format Specification
- [ ] Use consistent heading hierarchy
- [ ] Include table of contents
- [ ] Add file statistics summary
- [ ] Structure by directory

### Validation
- [ ] Verify all important files included
- [ ] Check file size limits (skip huge files)
- [ ] Ensure markdown is valid

## References
- .claude/commands/template.md - Command template
- context/ directory - Output location
```

### execution\\06-implement-discovery-command.md
`$(@{Path=execution\\06-implement-discovery-command.md; Language=markdown; Lines=System.Object[]}.Language)
---
archon_task_id: f87c2b05-fecb-4292-9e89-bf6603ef1774
project_id: 49e7f3a1-d9c5-439f-aa5f-2cdf4fec5b61
status: done
task_order: 117
assignee: User
created_at: 2026-01-23T16:32:57.794576+00:00
updated_at: 2026-01-23T16:52:00.028798+00:00
---

# 06: Implement Discovery Command

**Status:** Done

## Description
Create .claude/commands/discovery.md - load prime, query AI via RAG, explore web, generate discovery doc.

## Implementation Steps

### Command Structure
- [ ] Create discovery.md with YAML frontmatter
- [ ] Define idea parameter (optional)
- [ ] Document discovery flow

### Prime Loading
- [ ] Find latest context/prime-*.md
- [ ] Load codebase context
- [ ] Parse structure and patterns

### RAG Knowledge Search
- [ ] Query rag_search_knowledge_base for:
  - AI agent patterns
  - MCP integration examples
  - Similar implementations
- [ ] Query rag_search_code_examples for:
  - Relevant code patterns
  - Architecture examples
- [ ] Use short, focused queries (2-5 keywords)

### Web Research (if needed)
- [ ] Use web_search_prime_search for:
  - Latest AI/agent trends
  - Best practices
  - Inspiration sources
- [ ] Use web_reader_read/zread_read for:
  - In-depth documentation
  - Architecture patterns
  - Case studies

### Discovery Document Generation
- [ ] Create discovery/{timestamp}-{topic}.md
- [ ] Include sections:
  - Concept Overview
  - Key Insights
  - Recommendations
  - Potential Challenges
  - Next Steps

### Documentation Standards
- [ ] Keep discovery focused and concise
- [ ] Use direct language
- [ ] Focus on actionable insights

## References
- .claude/commands/template.md - Command template
- context/prime-*.md - Codebase context
- CLAUDE.md - RAG Workflow section
```

### execution\\07-implement-planning-command.md
`$(@{Path=execution\\07-implement-planning-command.md; Language=markdown; Lines=System.Object[]}.Language)
---
archon_task_id: 53d4d1c6-4326-4f1b-9c99-5949fab5d80c
project_id: 49e7f3a1-d9c5-439f-aa5f-2cdf4fec5b61
status: done
task_order: 115
assignee: User
created_at: 2026-01-23T16:33:00.396929+00:00
updated_at: 2026-01-23T16:53:38.295072+00:00
---

# 07: Implement Planning Command

**Status:** Done

## Description
Create .claude/commands/planning.md - load discovery, create feature directory, generate PRD.

## Implementation Steps

### Command Structure
- [ ] Create planning.md with YAML frontmatter
- [ ] Define feature-name parameter
- [ ] Document planning flow

### Discovery Loading
- [ ] Find latest discovery document
- [ ] Load from discovery/ directory
- [ ] Parse insights and recommendations
- [ ] Extract feature concept

### Feature Directory Creation
- [ ] Create features/{feature-name}/ directory
- [ ] Create subdirectories:
  - src/ (implementation files)
  - tests/ (test files)
  - docs/ (feature documentation)
- [ ] Create INDEX.md in feature directory

### PRD Generation
- [ ] Analyze discovery insights
- [ ] Define feature scope
- [ ] Create features/{feature-name}/prd.md with:
  - Overview
  - Goals
  - Requirements (functional/non-functional)
  - Success Criteria
  - Dependencies

### Documentation Standards
- [ ] Keep PRD under 600 lines (YAGNI)
- [ ] Use concise language (KISS)
- [ ] Focus on essential requirements only

### STATUS.md Update
- [ ] Create/update STATUS.md
- [ ] Set phase to "planning"
- [ ] Add feature to tracking

### Archon Integration
- [ ] Create or update project for feature
- [ ] Create initial planning tasks

## References
- .claude/commands/template.md - Command template
- discovery/*.md - Discovery documents
- CLAUDE.md - Documentation standards
```

### execution\\08-implement-development-command.md
`$(@{Path=execution\\08-implement-development-command.md; Language=markdown; Lines=System.Object[]}.Language)
---
archon_task_id: 17ab1472-2e0d-4746-bf49-b7c6c4aadf38
project_id: 49e7f3a1-d9c5-439f-aa5f-2cdf4fec5b61
status: done
task_order: 113
assignee: User
created_at: 2026-01-23T16:33:03.193708+00:00
updated_at: 2026-01-23T16:53:38.810557+00:00
---

# 08: Implement Development Command

**Status:** Done

## Description
Create .claude/commands/development.md - load PRD, analyze requirements, recommend tech stack, generate tech-spec.

## Implementation Steps

### Command Structure
- [ ] Create development.md with YAML frontmatter
- [ ] Define feature parameter
- [ ] Document development flow

### PRD Loading
- [ ] Load features/{feature}/prd.md
- [ ] Parse requirements section
- [ ] Extract functional requirements
- [ ] Identify constraints and dependencies

### Requirements Analysis
- [ ] Analyze feature scope
- [ ] Identify technical challenges
- [ ] Determine complexity level
- [ ] Assess integration points

### Tech Stack Recommendation
- [ ] Analyze existing codebase tech
- [ ] Recommend compatible technologies
- [ ] Consider team expertise
- [ ] Evaluate long-term maintainability
- [ ] Apply YAGNI principle to selections

### TECH-SPEC Generation
- [ ] Create features/{feature}/tech-spec.md
- [ ] Include sections:
  - Overview
  - Technology Stack
  - Architecture
  - Data Models (if applicable)
  - API Design (if applicable)
  - Implementation Notes
  - Testing Strategy

### Archon Integration
- [ ] Search for similar implementations in RAG
- [ ] Find code examples for recommended tech
- [ ] Document references used

### Documentation Standards
- [ ] Keep TECH-SPEC under 600 lines (YAGNI)
- [ ] Use concise language (KISS)
- [ ] Focus on essential details only

## References
- .claude/commands/template.md - Command template
- CLAUDE.md - Documentation standards
- features/{feature}/prd.md - Requirements to analyze
```

### execution\\09-create-prp-base-template.md
`$(@{Path=execution\\09-create-prp-base-template.md; Language=markdown; Lines=System.Object[]}.Language)
---
archon_task_id: 0e9aabdd-804e-4aaf-87ae-49c135b7d9f9
project_id: 49e7f3a1-d9c5-439f-aa5f-2cdf4fec5b61
status: done
task_order: 111
assignee: User
created_at: 2026-01-23T16:33:06.299475+00:00
updated_at: 2026-01-23T16:55:38.265269+00:00
---

# 09: Create PRP Base Template

**Status:** Done

## Description
Create templates/prp/prp-base.md with Goal, Context, Implementation Blueprint, Validation Loop, Anti-Patterns.

## Implementation Steps

### Template Structure
- [ ] Create templates/prp/ directory
- [ ] Create prp-base.md file

### Goal Section
- [ ] Define feature objective
- [ ] List success criteria
- [ ] Define acceptance criteria

### All Needed Context Section
- [ ] PRD references
- [ ] TECH-SPEC references
- [ ] Codebase patterns
- [ ] File path references
- [ ] External documentation links

### Implementation Blueprint Section
- [ ] Ordered task list (01, 02, 03...)
- [ ] Task dependencies
- [ ] Each task includes:
  - Title
  - Description with acceptance criteria
  - File paths to modify/create
  - Estimated complexity
  - Dependencies on other tasks

### Validation Loop Section
- [ ] Syntax validation commands
- [ ] Unit test requirements
- [ ] Integration test scenarios
- [ ] Manual testing checklist

### Known Gotchas Section
- [ ] Common pitfalls
- [ ] Codebase-specific patterns to follow
- [ ] Things NOT to do
- [ ] YAGNI/KISS reminders

### Anti-Patterns Section
- [ ] Over-engineering examples
- [ ] Premature abstraction warnings
- [ ] Unnecessary complexity flags

### YAML Frontmatter
- [ ] Add template metadata
- [ ] Include version info
- [ ] Track last updated

## References
- PRD.md - Project requirements context
- TECH-SPEC.md - Technical specifications context
- CLAUDE.md - Development principles
```

### execution\\10-create-prp-specialized-templates.md
`$(@{Path=execution\\10-create-prp-specialized-templates.md; Language=markdown; Lines=System.Object[]}.Language)
---
archon_task_id: e7f6c606-a26e-42ff-8204-348fc23f7fd5
project_id: 49e7f3a1-d9c5-439f-aa5f-2cdf4fec5b61
status: done
task_order: 109
assignee: User
created_at: 2026-01-23T16:33:09.931401+00:00
updated_at: 2026-01-23T16:55:39.283781+00:00
---

# 10: Create PRP Specialized Templates

**Status:** Done

## Description
Create specialized PRP templates: ai-agent, mcp-integration, api-endpoint, frontend-component.

## Implementation Steps

### ai-agent.md Template
- [ ] Extend prp-base.md
- [ ] Add agent-specific sections:
  - Agent capabilities definition
  - Tool usage patterns
  - State management
  - Error handling for agents
- [ ] Include common agent gotchas
- [ ] Add validation for agent behavior

### mcp-integration.md Template
- [ ] Extend prp-base.md
- [ ] Add MCP-specific sections:
  - MCP server connection
  - Tool integration patterns
  - Error handling for MCP calls
  - Fallback strategies
- [ ] Include MCP best practices
- [ ] Add health check validation

### api-endpoint.md Template
- [ ] Extend prp-base.md
- [ ] Add API-specific sections:
  - Endpoint definition
  - Request/response schemas
  - Authentication/authorization
  - Error response format
- [ ] Include API security checklist
- [ ] Add integration test requirements

### frontend-component.md Template
- [ ] Extend prp-base.md
- [ ] Add frontend-specific sections:
  - Component props/state
  - UI/UX requirements
  - Accessibility considerations
  - Responsive design
- [ ] Include frontend best practices
- [ ] Add visual regression testing

### Template Documentation
- [ ] Document when to use each template
- [ ] Add template selection guide
- [ ] Include examples

## References
- templates/prp/prp-base.md - Base PRP template
- PRD.md - Project requirements for context
```

### execution\\11-implement-pattern-extraction.md
`$(@{Path=execution\\11-implement-pattern-extraction.md; Language=markdown; Lines=System.Object[]}.Language)
---
archon_task_id: 3cd6d9d8-4f0f-4c9d-800a-ba2a06016a58
project_id: 49e7f3a1-d9c5-439f-aa5f-2cdf4fec5b61
status: done
task_order: 107
assignee: User
created_at: 2026-01-23T16:33:14.109689+00:00
updated_at: 2026-01-23T16:55:39.941841+00:00
---

# 11: Implement Pattern Extraction

**Status:** Done

## Description
Create pattern extraction utility - analyze Prime export, extract coding conventions, file structure, naming patterns.

## Implementation Steps

### Prime Analysis
- [ ] Load context/prime-{timestamp}.md
- [ ] Parse file structure
- [ ] Identify code patterns

### Convention Extraction
- [ ] Analyze naming conventions:
  - File naming patterns
  - Variable naming styles
  - Function/class naming
- [ ] Extract code style patterns:
  - Indentation and formatting
  - Comment styles
  - Import organization

### Structure Patterns
- [ ] Identify directory organization patterns
- [ ] Extract file grouping conventions
- [ ] Document module structure rules

### Template Generation
- [ ] Create pattern reference document
- [ ] Store in templates/patterns.md
- [ ] Include examples from codebase

### Integration
- [ ] Reference in PRP templates
- [ ] Use in development command
- [ ] Include in code review criteria

## References
- context/prime-*.md - Prime export files
- templates/prp/prp-base.md - PRP template
```

### execution\\12-implement-task-planning-command.md
`$(@{Path=execution\\12-implement-task-planning-command.md; Language=markdown; Lines=System.Object[]}.Language)
---
archon_task_id: 7baadefd-9436-46ea-9604-12376665eac2
project_id: 49e7f3a1-d9c5-439f-aa5f-2cdf4fec5b61
status: done
task_order: 105
assignee: User
created_at: 2026-01-23T16:33:18.377478+00:00
updated_at: 2026-01-23T16:55:40.675683+00:00
---

# 12: Implement Task Planning Command

**Status:** Done

## Description
Create .claude/commands/task-planning.md - load contexts, select PRP template, generate PRP, create Archon tasks.

## Implementation Steps

### Command Structure
- [ ] Create task-planning.md with YAML frontmatter
- [ ] Define feature parameter
- [ ] Document task planning flow

### Context Loading
- [ ] Load PRD from features/{feature}/prd.md
- [ ] Load TECH-SPEC from features/{feature}/tech-spec.md
- [ ] Gather codebase patterns
- [ ] Collect relevant references

### PRP Template Selection
- [ ] Analyze feature type
- [ ] Select appropriate PRP template:
  - prp-base.md (default)
  - ai-agent.md
  - mcp-integration.md
  - api-endpoint.md
  - frontend-component.md

### PRP Generation
- [ ] Extract requirements from PRD
- [ ] Map technical details from TECH-SPEC
- [ ] Create Implementation Blueprint with ordered tasks
- [ ] Add Validation Loop section
- [ ] Include Known Gotchas

### PRP Storage
- [ ] Create features/{feature}/prp.md
- [ ] Save generated PRP

### Archon Task Creation
- [ ] Create project in Archon if needed
- [ ] Parse Implementation Blueprint tasks
- [ ] Create tasks via manage_task with proper:
  - title
  - description
  - task_order (priority)
  - dependencies (via addBlockedBy)
- [ ] Link tasks to PRP in descriptions

### Validation
- [ ] Verify all tasks created
- [ ] Check dependency chains
- [ ] Confirm PRP completeness

## References
- .claude/commands/template.md - Command template
- templates/prp/*.md - PRP templates
- features/{feature}/prd.md - Feature requirements
- features/{feature}/tech-spec.md - Technical specifications
```

### execution\\13-implement-execution-command.md
`$(@{Path=execution\\13-implement-execution-command.md; Language=markdown; Lines=System.Object[]}.Language)
---
archon_task_id: 8e6d7db1-318c-4fdf-aa7d-c85a61f9e0e0
project_id: 49e7f3a1-d9c5-439f-aa5f-2cdf4fec5b61
status: done
task_order: 103
assignee: User
created_at: 2026-01-23T16:33:22.610421+00:00
updated_at: 2026-01-23T16:55:41.292991+00:00
---

# 13: Implement Execution Command

**Status:** Done

## Description
Create .claude/commands/execution.md - load task-plan, execute tasks sequentially, track progress, handle errors.

## Implementation Steps

### Command Structure
- [ ] Create execution.md with YAML frontmatter
- [ ] Define feature parameter
- [ ] Document execution flow

### PRP Loading
- [ ] Load features/{feature}/prp.md
- [ ] Parse Implementation Blueprint
- [ ] Extract task dependencies

### Archon Task Sync
- [ ] Find existing tasks for feature
- [ ] Create missing tasks from PRP
- [ ] Update task descriptions if needed

### Task Execution Loop
- [ ] Get next pending task
- [ ] Update status to "doing"
- [ ] Execute implementation steps
- [ ] Update status to "review"

### Progress Tracking
- [ ] Update STATUS.md after each task
- [ ] Track artifacts created
- [ ] Log completion percentage

### Error Handling
- [ ] Handle task failures gracefully
- [ ] Provide recovery suggestions
- [ ] Allow manual intervention
- [ ] Support resuming from failures

### Validation
- [ ] Run PRP Validation Loop commands
- [ ] Verify syntax correctness
- [ ] Run unit tests
- [ ] Run integration tests

## References
- .claude/commands/template.md - Command template
- templates/prp/prp-base.md - PRP structure
- features/{feature}/prp.md - Feature task plan
- STATUS.md - Progress tracking
```

### execution\\14-implement-review-command.md
`$(@{Path=execution\\14-implement-review-command.md; Language=markdown; Lines=System.Object[]}.Language)
---
archon_task_id: e257f7e0-021f-4ff9-b0f2-6942fefcdf2f
project_id: 49e7f3a1-d9c5-439f-aa5f-2cdf4fec5b61
status: done
task_order: 101
assignee: User
created_at: 2026-01-23T16:33:27.043969+00:00
updated_at: 2026-01-23T16:55:42.024135+00:00
---

# 14: Implement Review Command

**Status:** Done

## Description
Create .claude/commands/review.md - analyze code changes, generate review report, verify compliance.

## Implementation Steps

### Command Structure
- [ ] Create review.md with YAML frontmatter
- [ ] Define feature parameter
- [ ] Document review process

### Change Detection
- [ ] Get git diff for feature branch
- [ ] Identify modified files
- [ ] Parse change statistics

### Code Analysis
- [ ] Review code quality
- [ ] Check for security vulnerabilities
- [ ] Verify adherence to patterns
- [ ] Assess performance implications

### Compliance Verification
- [ ] Check against PRP requirements
- [ ] Validate TECH-SPEC compliance
- [ ] Verify YAGNI/KISS principles followed

### Report Generation
- [ ] Create review report in reviews/ directory
- [ ] Include quality score
- [ ] List issues found with severity
- [ ] Provide improvement suggestions

### Archon Integration
- [ ] Find review tasks for feature
- [ ] Update task status to review/done

## References
- .claude/commands/template.md - Command template
- features/{feature}/ - Feature code to review
- features/{feature}/prp.md - Requirements to verify
- reviews/ directory - Review reports
```

### execution\\15-implement-test-command.md
`$(@{Path=execution\\15-implement-test-command.md; Language=markdown; Lines=System.Object[]}.Language)
---
archon_task_id: 22bb15c6-2ff9-4eef-b65f-a7cd9b22d87f
project_id: 49e7f3a1-d9c5-439f-aa5f-2cdf4fec5b61
status: done
task_order: 99
assignee: User
created_at: 2026-01-23T16:33:31.711601+00:00
updated_at: 2026-01-23T16:55:42.706488+00:00
---

# 15: Implement Test Command

**Status:** Done

## Description
Create .claude/commands/test.md - run test suites, detect errors, AI-suggested fixes, generate test report.

## Implementation Steps

### Command Structure
- [ ] Create test.md with YAML frontmatter
- [ ] Define feature parameter
- [ ] Document test execution flow

### Test Discovery
- [ ] Search for test files in features/{feature}/testing/
- [ ] Identify test frameworks being used
- [ ] Parse test configuration

### Test Execution
- [ ] Run test suites
- [ ] Capture test output
- [ ] Collect error information

### Error Analysis
- [ ] Parse test failures
- [ ] Identify root causes
- [ ] Generate AI-suggested fixes

### Report Generation
- [ ] Create test report in testing/ directory
- [ ] Include pass/fail statistics
- [ ] List errors with suggested fixes
- [ ] Add coverage information if available

### Archon Integration
- [ ] Find testing-related tasks
- [ ] Update task status based on results

## References
- .claude/commands/template.md - Command template
- features/{feature}/testing/ - Test files
- testing/ directory - Test reports
```

### execution\\16-implement-workflow-command.md
`$(@{Path=execution\\16-implement-workflow-command.md; Language=markdown; Lines=System.Object[]}.Language)
---
archon_task_id: de83d047-05df-486f-8286-174acfcd4769
project_id: 49e7f3a1-d9c5-439f-aa5f-2cdf4fec5b61
status: done
task_order: 97
assignee: User
created_at: 2026-01-23T16:33:36.665985+00:00
updated_at: 2026-01-23T16:55:43.523642+00:00
---

# 16: Implement Workflow Command

**Status:** Done

## Description
Create .claude/commands/workflow.md - unified command executing all phases, support --from-{phase} resume.

## Implementation Steps

### Command Structure
- [ ] Create workflow.md with YAML frontmatter
- [ ] Define command options and flags
- [ ] Document usage examples

### Phase Execution
- [ ] Implement phase sequence:
  1. /prime (if no context exists)
  2. /discovery
  3. /planning {feature}
  4. /development {feature}
  5. /task-planning {feature}
  6. /execution {feature}
  7. /review {feature}
  8. /test {feature}

### Resume Functionality
- [ ] Add --from-discovery flag
- [ ] Add --from-planning flag
- [ ] Add --from-development flag
- [ ] Implement state checking before resuming

### Progress Tracking
- [ ] Update STATUS.md after each phase
- [ ] Track artifacts created
- [ ] Log completion status

### Error Handling
- [ ] Handle phase failures gracefully
- [ ] Allow continuation after fixes
- [ ] Provide clear error messages

## References
- .claude/commands/template.md - Command template
- All other command files for phase implementations
- PRD.md - Workflow overview
```

### execution\\17-implement-error-handling.md
`$(@{Path=execution\\17-implement-error-handling.md; Language=markdown; Lines=System.Object[]}.Language)
---
archon_task_id: d45fdba0-3bba-495c-8251-33a6d5b7fed1
project_id: 49e7f3a1-d9c5-439f-aa5f-2cdf4fec5b61
status: done
task_order: 95
assignee: User
created_at: 2026-01-23T16:33:42.195353+00:00
updated_at: 2026-01-23T16:55:44.133266+00:00
---

# 17: Implement Error Handling System

**Status:** Done

## Description
Implement comprehensive error handling - graceful degradation, checkpoint system, error logging, recovery.

## Implementation Steps

### Graceful Degradation
- [ ] Detect MCP server unavailability
- [ ] Fall back to alternative approaches
- [ ] Provide helpful error messages
- [ ] Continue with available functionality

### Checkpoint System
- [ ] Implement progress state saving
- [ ] Add resume capability to workflows
- [ ] Store intermediate artifacts
- [ ] Enable recovery from failures

### Error Logging
- [ ] Log all errors with context
- [ ] Include timestamps and stack traces
- [ ] Store logs in dedicated location
- [ ] Implement log rotation

### Recovery Patterns
- [ ] Define retry strategies for transient errors
- [ ] Implement rollback mechanisms
- [ ] Add state restoration procedures
- [ ] Document recovery workflows

### Documentation
- [ ] Document error handling patterns
- [ ] Add troubleshooting guide
- [ ] Include error codes and solutions

## References
- CLAUDE.md - Error Handling section
- .claude/commands/workflow.md - Resume functionality
```

### execution\\18-integrate-archon-mcp.md
`$(@{Path=execution\\18-integrate-archon-mcp.md; Language=markdown; Lines=System.Object[]}.Language)
---
archon_task_id: d1c2ceea-3dce-4d70-93ee-911b2f7941c5
project_id: 49e7f3a1-d9c5-439f-aa5f-2cdf4fec5b61
status: done
task_order: 93
assignee: User
created_at: 2026-01-23T16:33:47.947393+00:00
updated_at: 2026-01-23T16:55:44.8244+00:00
---

# 18: Integrate Archon MCP

**Status:** Done

## Description
Integrate Archon MCP tools - find_tasks, manage_task, rag_search_knowledge_base, health_check.

## Implementation Steps

### Task Management Integration
- [ ] Add find_tasks to task planning workflow
- [ ] Add manage_task to execution workflow
- [ ] Implement task status updates in commands
- [ ] Add task dependency tracking

### Knowledge Base Integration
- [ ] Add rag_search_knowledge_base to planning
- [ ] Add rag_search_code_examples to development
- [ ] Implement source filtering with source_id
- [ ] Add RAG result caching

### Health Check Integration
- [ ] Add health_check to command initialization
- [ ] Implement fallback handling for unavailable services
- [ ] Add health status reporting

### Documentation Updates
- [ ] Update CLAUDE.md with Archon MCP workflows
- [ ] Document task-driven development cycle
- [ ] Add RAG search patterns and examples

## References
- CLAUDE.md - Archon Integration & Workflow section
- Archon MCP documentation
- .claude/commands/task-planning.md
- .claude/commands/execution.md
```

### execution\\19-integrate-web-mcp-servers.md
`$(@{Path=execution\\19-integrate-web-mcp-servers.md; Language=markdown; Lines=System.Object[]}.Language)
---
archon_task_id: b82ae38b-7d24-4121-b9ea-6c996c8369cc
project_id: 49e7f3a1-d9c5-439f-aa5f-2cdf4fec5b61
status: done
task_order: 91
assignee: User
created_at: 2026-01-23T16:33:54.268618+00:00
updated_at: 2026-01-23T16:55:45.572955+00:00
---

# 19: Integrate Web MCP Servers

**Status:** Done

## Description
Integrate web MCP servers - web_search_prime_search, web_reader_read, zread_read with fallback.

## Implementation Steps

### Tool Integration
- [ ] Add web_search_prime_search to relevant commands
- [ ] Add web_reader_read to relevant commands
- [ ] Add zread_read to relevant commands

### Usage Patterns
- [ ] Use in Discovery phase for research
- [ ] Use in Planning phase for documentation
- [ ] Implement token optimization strategies

### Fallback Handling
- [ ] Detect MCP server unavailability
- [ ] Fall back to Claude built-in web search
- [ ] Log fallback events for monitoring

### Documentation
- [ ] Document web MCP usage in CLAUDE.md
- [ ] Update command files with web MCP examples
- [ ] Add troubleshooting for web MCP issues

## References
- CLAUDE.md - RAG Workflow section
- MCP server documentation
- .claude/commands/discovery.md
- .claude/commands/planning.md
```

### execution\\20-end-to-end-testing.md
`$(@{Path=execution\\20-end-to-end-testing.md; Language=markdown; Lines=System.Object[]}.Language)
---
archon_task_id: 12be7446-b4b4-42e4-9f71-2466260e2b2e
project_id: 49e7f3a1-d9c5-439f-aa5f-2cdf4fec5b61
status: done
task_order: 89
assignee: User
created_at: 2026-01-23T16:34:00.823889+00:00
updated_at: 2026-01-23T16:55:46.35974+00:00
---

# 20: End-to-End Testing

**Status:** Done

## Description
End-to-end testing - test all commands, error handling, resume functionality.

## Implementation Steps

### Command Testing
- [ ] Test /prime command
- [ ] Test /discovery command
- [ ] Test /planning command
- [ ] Test /development command
- [ ] Test /task-planning command
- [ ] Test /execution command
- [ ] Test /review command
- [ ] Test /test command
- [ ] Test /workflow command

### Error Handling Testing
- [ ] Test MCP server unavailable scenarios
- [ ] Test file operation failures
- [ ] Test invalid input handling
- [ ] Test recovery mechanisms

### Resume Functionality
- [ ] Test --from-discovery resume
- [ ] Test --from-planning resume
- [ ] Test --from-development resume
- [ ] Test state preservation

### Integration Testing
- [ ] Test Archon MCP integration
- [ ] Test Web MCP integration
- [ ] Test full workflow execution

## References
- .claude/commands/ - All command files
- CLAUDE.md - Error handling section
- testing/ directory
```

### execution\\21-create-main-index.md
`$(@{Path=execution\\21-create-main-index.md; Language=markdown; Lines=System.Object[]}.Language)
---
archon_task_id: cc5b7caf-0a90-4329-bef5-e94e6e940891
project_id: 49e7f3a1-d9c5-439f-aa5f-2cdf4fec5b61
status: done
task_order: 87
assignee: User
created_at: 2026-01-23T16:34:07.540697+00:00
updated_at: 2026-01-23T16:55:47.008077+00:00
---

# 21: Create Main INDEX.md

**Status:** Done

## Description
Create root INDEX.md with overview and navigation to all directories.

## Implementation Steps

### Structure
- [ ] Project overview section
- [ ] Directory navigation links
- [ ] Quick reference table

### Content
- [ ] context/ directory description
- [ ] discovery/ directory description
- [ ] features/ directory description
- [ ] templates/ directory description
- [ ] reviews/ directory description
- [ ] testing/ directory description
- [ ] execution/ directory description

### Formatting
- [ ] Use consistent heading levels
- [ ] Add clear descriptions
- [ ] Include relevant links

## References
- PRD.md - Directory structure
- Each directory's own INDEX.md
```

### execution\\22-create-readme.md
`$(@{Path=execution\\22-create-readme.md; Language=markdown; Lines=System.Object[]}.Language)
---
archon_task_id: 0c9fff65-fbc8-4c99-9c92-943d1e947d22
project_id: 49e7f3a1-d9c5-439f-aa5f-2cdf4fec5b61
status: done
task_order: 85
assignee: User
created_at: 2026-01-23T16:34:14.582526+00:00
updated_at: 2026-01-23T16:55:47.687022+00:00
---

# 22: Create README.md

**Status:** Done

## Description
Create README.md with system overview, quick start guide, command reference.

## Implementation Steps

### System Overview
- [ ] Write project description
- [ ] Explain AI Coding Workflow System
- [ ] List key features and benefits

### Quick Start Guide
- [ ] Installation instructions
- [ ] Initial setup steps
- [ ] First-time usage example

### Command Reference
- [ ] Document all /commands
- [ ] Provide usage examples
- [ ] Include command options

### Additional Sections
- [ ] Directory structure explanation
- [ ] Configuration guide
- [ ] Troubleshooting section
- [ ] Contributing guidelines

## References
- PRD.md - System overview
- CLAUDE.md - Command documentation
- .claude/commands/ - Command files
```

### execution\\23-performance-optimization.md
`$(@{Path=execution\\23-performance-optimization.md; Language=markdown; Lines=System.Object[]}.Language)
---
archon_task_id: 721b82f1-1aa5-40e6-b773-1a9289d4f003
project_id: 49e7f3a1-d9c5-439f-aa5f-2cdf4fec5b61
status: done
task_order: 83
assignee: User
created_at: 2026-01-23T16:34:21.874921+00:00
updated_at: 2026-01-23T16:55:48.345017+00:00
---

# 23: Performance Optimization

**Status:** Done

## Description
Performance optimization - file size limits, caching, parallel processing.

## Implementation Steps

### File Size Limits
- [ ] Implement file size validation
- [ ] Add chunking for large files
- [ ] Configure size limits appropriately

### Caching Strategy
- [ ] Implement RAG result caching
- [ ] Cache web search results
- [ ] Add cache invalidation logic

### Parallel Processing
- [ ] Parallelize independent operations
- [ ] Optimize MCP tool call batching
- [ ] Reduce sequential dependencies

### Performance Monitoring
- [ ] Add timing metrics
- [ ] Monitor resource usage
- [ ] Track bottlenecks

## References
- CLAUDE.md - RAG Workflow section
- MCP tool documentation
```

### execution\\24-system-validation-final-testing.md
`$(@{Path=execution\\24-system-validation-final-testing.md; Language=markdown; Lines=System.Object[]}.Language)
---
archon_task_id: 4acc31dc-61e2-4357-bade-0cb9944eafe5
project_id: 49e7f3a1-d9c5-439f-aa5f-2cdf4fec5b61
status: done
task_order: 81
assignee: User
created_at: 2026-01-23T16:34:29.689726+00:00
updated_at: 2026-01-23T16:55:49.014093+00:00
---

# 24: System Validation Final Testing

**Status:** Done

## Description
System validation and final testing - verify all requirements met.

## Implementation Steps

### Requirements Validation
- [ ] Verify all MVP requirements implemented
- [ ] Check PRD requirements completeness
- [ ] Validate TECH-SPEC specifications met

### Integration Testing
- [ ] End-to-end workflow tests
- [ ] Cross-component integration
- [ ] MCP server integration validation

### Quality Checks
- [ ] Code quality standards met
- [ ] Performance benchmarks achieved
- [ ] Security requirements satisfied

## References
- MVP.md - MVP requirements
- PRD.md - Product requirements
- TECH-SPEC.md - Technical specifications
```

### execution\\25-documentation-review-updates.md
`$(@{Path=execution\\25-documentation-review-updates.md; Language=markdown; Lines=System.Object[]}.Language)
---
archon_task_id: 53147c57-e66b-4f9a-985c-2297c86ebb3d
project_id: 49e7f3a1-d9c5-439f-aa5f-2cdf4fec5b61
status: done
task_order: 79
assignee: User
created_at: 2026-01-23T16:34:37.338777+00:00
updated_at: 2026-01-23T16:55:49.690558+00:00
---

# 25: Documentation Review Updates

**Status:** Done

## Description
Documentation review and updates - review all docs for accuracy, completeness.

## Implementation Steps

### Review Checklist
- [ ] PRD.md - accuracy and completeness
- [ ] TECH-SPEC.md - technical details current
- [ ] CLAUDE.md - instructions clear and accurate
- [ ] README.md - helpful for new users
- [ ] All command files - properly documented

### Updates Needed
- [ ] Fix inaccuracies
- [ ] Add missing information
- [ ] Update examples
- [ ] Clarify ambiguous sections

### Validation
- [ ] Test instructions against actual behavior
- [ ] Verify all links work
- [ ] Check code examples are valid

## References
- PRD.md
- TECH-SPEC.md
- CLAUDE.md
- README.md
```

### execution\\26-security-audit-hardening.md
`$(@{Path=execution\\26-security-audit-hardening.md; Language=markdown; Lines=System.Object[]}.Language)
---
archon_task_id: 8df16a2b-079f-4d5a-b57d-39adb5031b04
project_id: 49e7f3a1-d9c5-439f-aa5f-2cdf4fec5b61
status: done
task_order: 77
assignee: User
created_at: 2026-01-23T16:34:46.23041+00:00
updated_at: 2026-01-23T16:55:50.205358+00:00
---

# 26: Security Audit Hardening

**Status:** Done

## Description
Security audit and hardening - check for vulnerabilities, safe file operations.

## Implementation Steps

### Security Audit
- [ ] Review file operations for path traversal vulnerabilities
- [ ] Check command injection risks
- [ ] Audit user input handling

### Hardening Measures
- [ ] Implement path validation utilities
- [ ] Add input sanitization
- [ ] Configure file permissions correctly

### Verification
- [ ] Run security scan tools
- [ ] Test common attack vectors
- [ ] Document security measures

## References
- OWASP Top 10
- CLAUDE.md - Error handling section
```

### execution\\27-user-acceptance-testing-preparation.md
`$(@{Path=execution\\27-user-acceptance-testing-preparation.md; Language=markdown; Lines=System.Object[]}.Language)
---
archon_task_id: 9076c107-05f7-489a-ad6d-b9b99607ed7f
project_id: 49e7f3a1-d9c5-439f-aa5f-2cdf4fec5b61
status: done
task_order: 75
assignee: User
created_at: 2026-01-23T16:34:54.827304+00:00
updated_at: 2026-01-23T16:55:50.74001+00:00
---

# 27: User Acceptance Testing Preparation

**Status:** Done

## Description
User acceptance testing preparation - prepare for user testing and feedback.

## Implementation Steps

### Test Environment Setup
- [ ] Prepare staging environment
- [ ] Load test data
- [ ] Configure test accounts

### Test Planning
- [ ] Define UAT scenarios
- [ ] Create test scripts
- [ ] Schedule testing sessions

### Feedback Collection
- [ ] Set up feedback mechanisms
- [ ] Create issue tracking templates
- [ ] Prepare response procedures

## References
- PRD.md - User acceptance criteria
- testing/ directory
```

### execution\\28-system-deployment-handoff.md
`$(@{Path=execution\\28-system-deployment-handoff.md; Language=markdown; Lines=System.Object[]}.Language)
---
archon_task_id: fb5c1fd0-85b5-4164-8008-de5b64fead91
project_id: 49e7f3a1-d9c5-439f-aa5f-2cdf4fec5b61
status: done
task_order: 73
assignee: User
created_at: 2026-01-23T16:35:03.830698+00:00
updated_at: 2026-01-23T16:55:51.252932+00:00
---

# 28: System Deployment Handoff

**Status:** Done

## Description
System deployment and handoff - final deployment, documentation handoff.

## Implementation Steps

### Final Deployment
- [ ] Verify all components are deployed
- [ ] Run final integration tests
- [ ] Confirm production environment is ready

### Documentation Handoff
- [ ] Compile final documentation
- [ ] Create user guides
- [ ] Document deployment procedures

### Sign-off
- [ ] Stakeholder approval
- [ ] Deployment checklist complete
- [ ] Handoff documentation delivered

## References
- PRD.md
- TECH-SPEC.md
```

### execution\\INDEX.md
`$(@{Path=execution\\INDEX.md; Language=markdown; Lines=System.Object[]}.Language)
# Execution Directory

This directory contains task execution documents linked to Archon MCP tasks. Each file represents a numbered task in the AI Coding Workflow System implementation.

## Purpose
- Track implementation tasks with detailed steps
- Link Archon tasks to documentation
- Provide implementation guidance
- Track completion status

## Tasks

| # | Task | Status | Description |
|---|------|--------|-------------|
| 01 | [Create Directory Structure](01-create-directory-structure.md) | Done | Create project directory structure |
| 02 | [Create INDEX.md Generator](02-create-index-generator.md) | Done | Implement INDEX.md generation utility |
| 03 | [Create STATUS.md Format](03-create-status-format.md) | Done | Implement STATUS.md tracking format |
| 04 | [Create Command Template](04-create-command-template.md) | Done | Create reusable command template |
| 05 | [Implement Prime Command](05-implement-prime-command.md) | Done | Export codebase context |
| 06 | [Implement Discovery Command](06-implement-discovery-command.md) | Done | Explore ideas with RAG/web research |
| 07 | [Implement Planning Command](07-implement-planning-command.md) | Done | Generate PRD from discovery |
| 08 | [Implement Development Command](08-implement-development-command.md) | Done | Generate TECH-SPEC from PRD |
| 09 | [Create PRP Base Template](09-create-prp-base-template.md) | Done | Base template for task plans |
| 10 | [Create PRP Specialized Templates](10-create-prp-specialized-templates.md) | Done | Specialized PRP templates |
| 11 | [Implement Pattern Extraction](11-implement-pattern-extraction.md) | Done | Extract codebase patterns |
| 12 | [Implement Task Planning Command](12-implement-task-planning-command.md) | Done | Generate PRP and create tasks |
| 13 | [Implement Execution Command](13-implement-execution-command.md) | Done | Execute tasks from PRP |
| 14 | [Implement Review Command](14-implement-review-command.md) | Done | Code review and analysis |
| 15 | [Implement Test Command](15-implement-test-command.md) | Done | Run tests and generate reports |
| 16 | [Implement Workflow Command](16-implement-workflow-command.md) | Done | Unified workflow with resume |
| 17 | [Implement Error Handling](17-implement-error-handling.md) | Done | Comprehensive error handling |
| 18 | [Integrate Archon MCP](18-integrate-archon-mcp.md) | Done | Archon MCP integration |
| 19 | [Integrate Web MCP Servers](19-integrate-web-mcp-servers.md) | Done | Web MCP integration |
| 20 | [End-to-End Testing](20-end-to-end-testing.md) | Done | Full system testing |
| 21 | [Create Main INDEX.md](21-create-main-index.md) | Done | Root navigation index |
| 22 | [Create README.md](22-create-readme.md) | Done | Project documentation |
| 23 | [Performance Optimization](23-performance-optimization.md) | Done | System optimization |
| 24 | [System Validation](24-system-validation-final-testing.md) | Done | Final validation testing |
| 25 | [Documentation Review](25-documentation-review-updates.md) | Done | Documentation audit |
| 26 | [Security Audit](26-security-audit-hardening.md) | Done | Security hardening |
| 27 | [UAT Preparation](27-user-acceptance-testing-preparation.md) | Done | User testing prep |
| 28 | [Deployment Handoff](28-system-deployment-handoff.md) | Done | Final deployment |

## Links
- [../INDEX.md](../INDEX.md) - Root index
- [../.claude/commands/](../.claude/commands/) - Command files
- [../features/](../features/) - Feature implementations
```

### features\\INDEX.md
`$(@{Path=features\\INDEX.md; Language=markdown; Lines=System.Object[]}.Language)
# Features Index

## Overview
This directory contains all feature-specific artifacts organized by feature name. Each feature has its own subdirectory with PRD, tech spec, PRP, task plans, execution logs, reviews, and test results.

## Features

### smart-reference-library
- **Status**: Execution Completed
- **Description**: Token-efficient reference library with /learn and /learn-health commands
- **Phase**: Ready for Review & Test
- **Artifacts**:
  - [PRP](./smart-reference-library/prp.md)
  - [Task Plan](./smart-reference-library/task-plan.md)
  - [STATUS](./smart-reference-library/STATUS.md)
  - [Execution Index](./smart-reference-library/execution/INDEX.md)
- **Archon Project ID**: `acf45b67-51aa-475d-b4cc-7c1055b4a032`

## Navigation
- [Back to Root](../)
- [Context](../context/)
- [Discovery](../discovery/)
```

### features\\smart-reference-library\\execution\\INDEX.md
`$(@{Path=features\\smart-reference-library\\execution\\INDEX.md; Language=markdown; Lines=System.Object[]}.Language)
# Execution Index: Smart Reference Library

**Project ID**: `acf45b67-51aa-475d-b4cc-7c1055b4a032`
**Total Tasks**: 7
**Status**: Completed âœ…

## Summary

All 7 tasks completed successfully. Task files deleted upon completion.

## Completed Tasks

| # | Task | Status | Completed |
|---|------|--------|-----------|
| 1 | Run SQL migration for archon_references table | âœ… Done | 2026-01-24 |
| 2 | Create /learn command file | âœ… Done | 2026-01-24 |
| 3 | Create /learn-health command file | âœ… Done | 2026-01-24 |
| 4 | Update PRP templates with Reference Library section | âœ… Done | 2026-01-24 |
| 5 | Update CLAUDE.md with Reference Library documentation | âœ… Done | 2026-01-24 |
| 6 | Test /learn command end-to-end | âœ… Done | 2026-01-24 |
| 7 | Test /learn-health command | âœ… Done | 2026-01-24 |

## Deliverables

- âœ… `.claude/commands/learn.md` - Learn command for adding references
- âœ… `.claude/commands/learn-health.md` - Health check command
- âœ… `templates/prp/prp-base.md` - Updated with Reference Library section
- âœ… `CLAUDE.md` - Updated with Reference Library documentation
- âœ… `archon_references` table - Created with test data

## Next Steps

1. Run Review command: `/review smart-reference-library`
2. Run Test command: `/test smart-reference-library`
3. Or use `/workflow smart-reference-library --from-review`
```

### features\\smart-reference-library\\prp.md
`$(@{Path=features\\smart-reference-library\\prp.md; Language=markdown; Lines=System.Object[]}.Language)
# PRP: Smart Reference Library

**Version**: 1.0 | **Last Updated**: 2026-01-24 | **Related**: MVP.md, PRD.md, TECH-SPEC.md

## Goal

### Feature Goal
Build a token-efficient reference library with `/learn` and `/learn-health` commands that stores digested coding insights in a dedicated Supabase table, enabling selective context loading based on current task needs.

### Deliverable
- SQL migration: `012_add_smart_reference_library.sql` (created)
- Command: `.claude/commands/learn.md`
- Command: `.claude/commands/learn-health.md`
- Updated: `templates/prp/prp-base.md` with Reference Library section
- Updated: `CLAUDE.md` with Reference Library documentation

### Success Criteria
- `/learn {topic}` searches RAG/web, digests findings, stores approved insights
- `/learn-health` displays category stats, health percentage, suggestions
- PRP templates can specify required reference categories
- References stored in dedicated `archon_references` table (not project docs)

## All Needed Context

### Documentation URLs
- Supabase SQL reference: https://supabase.com/docs/guides/database
- Archon RAG API: See `mcps/user-archon/tools/*.json`

### Codebase Patterns
- Commands use YAML frontmatter + markdown body
- Commands define inputs, outputs, execution steps
- Existing commands: `.claude/commands/*.md`

### File References
- Command template: `.claude/commands/template.md`
- Existing commands: `prime.md`, `discovery.md`, `planning.md`, `development.md`
- PRP base template: `templates/prp/prp-base.md`

### Naming Conventions
- Commands: lowercase with hyphens (e.g., `learn-health.md`)
- Supabase tables: `archon_` prefix (e.g., `archon_references`)
- Indexes: `idx_archon_references_{column}`

### Architecture Patterns
- Direct SQL via Supabase (not Archon MCP documents)
- RAG search for topic research
- LLM digest for insight extraction
- User approval before storage

## Implementation Blueprint

### Data Models

**archon_references table** (already defined in migration):
```sql
- id: UUID PRIMARY KEY
- title: TEXT NOT NULL
- category: TEXT NOT NULL (python, mcp, react, etc.)
- tags: TEXT[] (additional tags)
- content: JSONB (summary, insights, code_examples, sources)
- source_url: TEXT
- author: TEXT
- created_at, updated_at: TIMESTAMPTZ
```

**Content JSONB structure**:
```json
{
  "summary": "string",
  "insights": ["string"],
  "code_examples": [{"title": "", "language": "", "code": ""}],
  "sources": ["url"],
  "learned_at": "timestamp"
}
```

### Implementation Tasks

| Order | Task | Dependencies | Estimate |
|-------|------|--------------|----------|
| 1 | Run SQL migration | None | 5 min |
| 2 | Create /learn command | Migration done | 1 hour |
| 3 | Create /learn-health command | Migration done | 45 min |
| 4 | Update PRP templates | Commands done | 30 min |
| 5 | Update CLAUDE.md | Commands done | 30 min |
| 6 | Test /learn command | All above | 30 min |
| 7 | Test /learn-health command | All above | 30 min |

### File Structure

```
.claude/commands/
â”œâ”€â”€ learn.md              # New
â”œâ”€â”€ learn-health.md       # New
â””â”€â”€ ... (existing)

templates/prp/
â”œâ”€â”€ prp-base.md           # Update (add Reference Library section)
â””â”€â”€ ... (existing)

features/smart-reference-library/
â”œâ”€â”€ prp.md                # This file
â”œâ”€â”€ task-plan.md          # Task tracking
â””â”€â”€ STATUS.md             # Progress tracking

Archon MCP/migration/
â””â”€â”€ 012_add_smart_reference_library.sql  # Created
```

### Integration Points

**Supabase Direct SQL**:
- INSERT for storing references
- SELECT for querying by category/tags
- GROUP BY for stats calculation

**Archon RAG**:
- `rag_search_knowledge_base(query, match_count)` for topic research
- `rag_read_full_page(page_id)` for full content

**Web Search** (fallback):
- WebSearch tool if RAG returns no results

## Validation Loop

### Syntax Validation
- YAML frontmatter valid in command files
- SQL migration runs without errors
- Markdown formatting correct

### Unit Tests
- SQL: Insert/query references manually in Supabase
- Commands: Verify YAML parsing works

### Integration Tests
- `/learn python async`: Full flow from search to storage
- `/learn-health`: Stats calculation with test data

### End-to-End Tests
1. Run migration in Supabase
2. Execute `/learn mcp server patterns`
3. Approve digest
4. Verify row in `archon_references`
5. Run `/learn-health`
6. Verify stats show new reference

## Anti-Patterns

### General Anti-Patterns
- Skipping user approval before storage
- Storing raw content instead of digested insights
- Preloading all references in CLAUDE.md
- Using Archon project docs instead of dedicated table

### Feature-Specific Anti-Patterns
- Long RAG queries (keep to 2-5 keywords)
- Storing non-technical content
- Missing category/tags on references
- Not handling Supabase connection errors
```

### features\\smart-reference-library\\STATUS.md
`$(@{Path=features\\smart-reference-library\\STATUS.md; Language=markdown; Lines=System.Object[]}.Language)
# STATUS: Smart Reference Library

**Feature**: Smart Reference Library
**Created**: 2026-01-24
**Current Phase**: Execution - Completed

## Phase Progress

| Phase | Status | Completed |
|-------|--------|-----------|
| Discovery | Completed | 2026-01-24 |
| MVP | Completed | 2026-01-24 |
| Planning (PRD) | Completed | 2026-01-24 |
| Development (TECH-SPEC) | Completed | 2026-01-24 |
| Task Planning | Completed | 2026-01-24 |
| Execution | Completed | 2026-01-24 |
| Review | Not Started | - |
| Test | Not Started | - |

## Artifacts

| Artifact | Path | Status |
|----------|------|--------|
| MVP | `MVP.md` | Complete |
| PRD | `PRD.md` | Complete |
| TECH-SPEC | `TECH-SPEC.md` | Complete |
| SQL Migration | `Archon MCP/migration/012_add_smart_reference_library.sql` | Complete |
| PRP | `features/smart-reference-library/prp.md` | Complete |
| Task Plan | `features/smart-reference-library/task-plan.md` | Complete |
| /learn command | `.claude/commands/learn.md` | Complete |
| /learn-health command | `.claude/commands/learn-health.md` | Complete |
| PRP Template Update | `templates/prp/prp-base.md` | Complete |
| CLAUDE.md Update | `CLAUDE.md` | Complete |

## Archon Project

**Project ID**: `acf45b67-51aa-475d-b4cc-7c1055b4a032`
**Tasks Created**: 7
**Tasks Completed**: 7

## Execution Summary

### Completed Tasks

| Task ID | Task | Status |
|---------|------|--------|
| da02cd4b | Run SQL migration for archon_references table | âœ… Done |
| 4e570391 | Create /learn command file | âœ… Done |
| ed1fea70 | Create /learn-health command file | âœ… Done |
| a259b76e | Update PRP templates with Reference Library section | âœ… Done |
| 28e0409f | Update CLAUDE.md with Reference Library documentation | âœ… Done |
| 3fa7bbe6 | Test /learn command end-to-end | âœ… Done |
| 40648c16 | Test /learn-health command | âœ… Done |

### Database Status

- **Table**: `archon_references` created âœ…
- **Indexes**: 5 indexes created âœ…
- **RLS Policies**: 3 policies applied âœ…
- **Test Reference**: 1 Python async reference inserted âœ…

### Commands Ready

- `/learn {topic}` - Search, digest, and store coding insights
- `/learn-health` - Check library health and statistics

## Next Steps

1. Run Review command: `/review smart-reference-library`
2. Run Test command: `/test smart-reference-library`
3. Or use `/workflow smart-reference-library --from-review`

## Notes

- Uses dedicated `archon_references` table (not project docs JSONB)
- Direct SQL via Supabase (not Archon MCP document tools)
- RAG search for topic research, LLM for digest
- User approval required before storage
- Token-efficient selective loading by category
- Current library health: 11% (1/9 categories)
```

### features\\smart-reference-library\\task-plan.md
`$(@{Path=features\\smart-reference-library\\task-plan.md; Language=markdown; Lines=System.Object[]}.Language)
# Task Plan: Smart Reference Library

**Generated**: 2026-01-24T11:24:00Z
**PRP Version**: 1.0
**Total Tasks**: 7
**Archon Project ID**: `acf45b67-51aa-475d-b4cc-7c1055b4a032`

## Task List

| Task ID | Task Title | Dependencies | Priority | Estimate | Status |
|---------|------------|--------------|----------|----------|--------|
| `da02cd4b-208c-48ca-9089-88edb1ee47ef` | Run SQL migration for archon_references table | None | 100 | 5 min | todo |
| `4e570391-cbeb-4439-90c3-ead0254137f2` | Create /learn command file | Task 1 | 90 | 1 hour | todo |
| `ed1fea70-2c91-4a98-9d2b-2655f49f58b8` | Create /learn-health command file | Task 1 | 80 | 45 min | todo |
| `a259b76e-7201-4f80-9f61-894dbfdaaedc` | Update PRP templates with Reference Library section | Tasks 2,3 | 70 | 30 min | todo |
| `28e0409f-b91b-4bee-be20-23176ab8ea8b` | Update CLAUDE.md with Reference Library documentation | Tasks 2,3 | 60 | 30 min | todo |
| `3fa7bbe6-2ebd-4e7a-bf70-cdca8cea43b5` | Test /learn command end-to-end | Tasks 1-5 | 50 | 30 min | todo |
| `40648c16-1af0-4d2e-9e59-83df45e0421a` | Test /learn-health command | Tasks 1-5 | 40 | 30 min | todo |

## Execution Order

1. **Task da02cd4b**: Run SQL migration for archon_references table
2. **Task 4e570391**: Create /learn command file
3. **Task ed1fea70**: Create /learn-health command file
4. **Task a259b76e**: Update PRP templates with Reference Library section
5. **Task 28e0409f**: Update CLAUDE.md with Reference Library documentation
6. **Task 3fa7bbe6**: Test /learn command end-to-end
7. **Task 40648c16**: Test /learn-health command

## Next Steps

1. Run migration `012_add_smart_reference_library.sql` in Supabase SQL Editor
2. Mark Task 1 as `doing` then `done` in Archon
3. Proceed to Task 2: Create /learn command
4. Track progress in Archon MCP

## Commands

```bash
# Mark task as doing
manage_task("update", task_id="da02cd4b-208c-48ca-9089-88edb1ee47ef", status="doing")

# Mark task as done
manage_task("update", task_id="da02cd4b-208c-48ca-9089-88edb1ee47ef", status="done")

# Get next todo task
find_tasks(filter_by="status", filter_value="todo")
```
```

### INDEX.md
`$(@{Path=INDEX.md; Language=markdown; Lines=System.Object[]}.Language)
# AI Coding Workflow System - INDEX

## Overview

This is a markdown-based command system for orchestrating AI-assisted development workflows through MCP integration. It manages the complete lifecycle from codebase context to implementation, review, and testing.

## Directory Navigation

- **[context/](./context/)** - Prime exports (codebase context)
- **[discovery/](./discovery/)** - Discovery documents (ideas and opportunities)
- **[features/](./features/)** - Feature artifacts (PRD, tech spec, PRP, task plans)
- **[templates/](./templates/)** - Template files (PRP templates)
- **[reviews/](./reviews/)** - Code review reports
- **[testing/](./testing/)** - Test results
- **[execution/](./execution/)** - Task breakdown files
- **[.claude/commands/](./.claude/commands/)** - Workflow commands

## Core Commands

| Command | Description | Phase |
|---------|-------------|-------|
| `/prime` | Export codebase for context gathering | Prime |
| `/discovery` | Explore ideas and opportunities | Discovery |
| `/planning {feature}` | Generate PRD from discovery | Planning |
| `/development {feature}` | Generate tech spec from PRD | Development |
| `/task-planning {feature}` | Generate PRP and create tasks | Task Planning |
| `/execution {feature}` | Execute tasks sequentially | Execution |
| `/review {feature}` | Run code review | Review |
| `/test {feature}` | Run tests with AI-suggested fixes | Test |
| `/workflow {feature}` | Execute full workflow with resume support | All phases |
| `/learn {topic}` | Search, digest, and store coding insights | Independent |
| `/learn-health` | Check reference library health and statistics | Independent |
| `/check` | Comprehensive codebase health check and cleanup | Utility |
| `/update-index` | Update directory INDEX.md files | Utility |
| `/update-status` | Update feature STATUS.md tracking | Utility |

## Core Documents (Root Level)

- **[MVP.md](./MVP.md)** - Minimum Viable Product definition
- **[PRD.md](./PRD.md)** - Product Requirements Document
- **[TECH-SPEC.md](./TECH-SPEC.md)** - Technical Specification
- **[CLAUDE.md](./CLAUDE.md)** - Developer guidelines

## Quick Start

1. Run `/prime` to export codebase context
2. Run `/discovery` to explore opportunities
3. Run `/planning {feature-name}` to create PRD
4. Run `/development {feature-name}` to create tech spec
5. Run `/task-planning {feature-name}` to create implementation plan
6. Run `/execution {feature-name}` to implement tasks
7. Run `/review {feature-name}` to review code
8. Run `/test {feature-name}` to run tests

Or run `/workflow {feature-name}` to execute all phases automatically.

## Status

**Version**: 1.0
**Last Updated**: 2026-01-24
**Status**: Stable (Smart Reference Library Completed)

## Completed Features

- **Smart Reference Library** - Token-efficient reference storage with /learn and /learn-health commands (Execution Complete, Awaiting Review/Test)
```

### LICENSE
`$(@{Path=LICENSE; Language=; Lines=System.Object[]}.Language)
MIT License

Copyright (c) 2026 Ryan Joseph Brosas

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
```

### MVP.md
`$(@{Path=MVP.md; Language=markdown; Lines=System.Object[]}.Language)
# MVP: Smart Reference Library

**Version**: 1.1 | **Created**: 2026-01-24

## What We're Building

A token-efficient reference library with `/learn` command and brain health tracking - loading only what's relevant to the current task.

## Core Problem

All context gets loaded regardless of relevance. If building a Python feature, we don't need React patterns cluttering the LLM context.

## In Scope (Must Have)

### 1. Reference Directory Structure
```
references/
â”œâ”€â”€ BRAIN.md          # Health dashboard
â”œâ”€â”€ INDEX.md          # Available references
â”œâ”€â”€ python/
â”œâ”€â”€ mcp/
â”œâ”€â”€ react/
â”œâ”€â”€ ai-agents/
â”œâ”€â”€ typescript/
â”œâ”€â”€ testing/
â””â”€â”€ patterns/
```

### 2. `/learn` Command
- `/learn {topic}` - Search RAG + web for topic
- Present findings for approval
- Save approved content to appropriate category
- Update BRAIN.md stats

### 3. `/learn-health` Command
- Check reference library health on demand
- Show stats per category
- Flag empty/stale categories
- Suggest what to learn next
- Quick overview without running full learn

### 4. Brain Health Tracking (`BRAIN.md`)
- Visual progress per category
- Empty categories flagged
- Last activity timestamp
- Growth tracking
- Suggestions for what to learn next

### 5. Skills Integration
- Skills can reference specific `references/` files
- References provide patterns, skills provide workflows
- Skills use selective loading same as PRP
- Example: `create-skill` skill references `references/patterns/skill-creation.md`

### 6. Selective Loading
- PRP and Skills specify only needed references
- CLAUDE.md doesn't preload everything
- Only relevant refs load into context
- Example: Python MCP task â†’ load only `python/` + `mcp/`

## Out of Scope

- Business/non-technical content
- Automatic reference detection
- Reference versioning
- Cross-reference linking

## How It Integrates

- `/learn` builds the library (independent of PIV loop)
- PRP references specific files needed for task
- Only referenced files load into LLM context
- Brain health shows library growth

## Estimated Effort

2-3 days
```

### PRD.md
`$(@{Path=PRD.md; Language=markdown; Lines=System.Object[]}.Language)
# PRD: Smart Reference Library

**Version**: 1.0 | **Last Updated**: 2026-01-24

## Overview

A token-efficient reference library system with `/learn` and `/learn-health` commands. Organizes best practices by category, loads only what's relevant to current task.

### Goals

1. Build growing knowledge library via `/learn` command
2. Track library health via `/learn-health` command
3. Enable selective loading - only relevant refs load into context
4. Integrate with PRP and Skills for reference linking

### Success Metrics

- Library grows over time (tracked in BRAIN.md)
- Context stays lean (only relevant refs load)
- Empty categories get flagged and addressed

## User Stories

### US-1: Learn New Topics
**As** a Developer, **I want** to run `/learn {topic}` **so that** I can search RAG/web and save useful patterns to my reference library.

**Acceptance Criteria**:
- Search Archon RAG and web for topic
- Present findings for approval
- Save approved content to appropriate category folder
- Update BRAIN.md stats after save

### US-2: Check Library Health
**As** a Developer, **I want** to run `/learn-health` **so that** I can see which categories need attention.

**Acceptance Criteria**:
- Show stats per category (ref count, last updated)
- Flag empty or stale categories
- Suggest topics to learn next
- Display overall health percentage

### US-3: Selective Loading
**As** a Developer, **I want** PRP and Skills to reference only needed files **so that** LLM context stays lean.

**Acceptance Criteria**:
- PRP specifies which reference files to load
- Skills can reference specific reference files
- CLAUDE.md does not preload all references
- Only referenced files load into context

### US-4: Brain Dashboard
**As** a Developer, **I want** a BRAIN.md dashboard **so that** I can see library status at a glance.

**Acceptance Criteria**:
- Visual progress bars per category
- Last activity timestamp
- Growth tracking (refs added this week)
- Suggestions for what to learn

## Features

### Feature 1: Reference Storage (Archon Documents)
Store digested insights as Archon documents with category tags.

**Categories (via tags)**:
- python
- mcp
- react
- ai-agents
- typescript
- testing
- patterns

**Storage**: Archon/Supabase (not local markdown files)

**Priority**: High

### Feature 2: `/learn` Command
Command to search, digest, and save insights.

**Flow**:
1. User runs `/learn {topic}`
2. Search Archon RAG + web
3. **Digest into concise, actionable insights**
4. Present for approval
5. Store via `manage_document` with category tags

**Priority**: High

### Feature 3: `/learn-health` Command
Command to check library health on demand.

**Output**:
- Stats per category
- Empty/stale flags
- Suggestions
- Overall health score

**Priority**: High

### Feature 4: BRAIN Dashboard
Generated from Archon document stats.

**Contents**:
- Health percentage (calculated from category coverage)
- Per-category counts (queried from Archon)
- Last learned timestamp
- Growth metrics
- Suggestions for empty categories

**Note**: Stats queried live from Archon, not stored in markdown

**Priority**: Medium

### Feature 5: Skills Integration
Skills can reference specific reference files.

**How it works**:
- Skills specify needed references
- References provide patterns
- Skills provide workflows
- Selective loading applies

**Priority**: Medium

## Technical Requirements

### Architecture: Hybrid (Archon + Markdown)

**Storage**: Archon/Supabase documents
**Output**: Generated markdown (BRAIN.md) for quick reference

### New Files

| File | Purpose |
|------|---------|
| `.claude/commands/learn.md` | Learn command definition |
| `.claude/commands/learn-health.md` | Health check command |

### Integrations

- **Archon MCP**: 
  - `rag_search_knowledge_base` - Search for topics
  - `manage_document` - Store digested insights
  - `find_documents` - Query references by category
- **Web Search**: External best practices
- **Archon Documents**: Store references (not local markdown files)

### Data Models

**Reference Document** (stored in Archon):
- `title`: Insight title
- `document_type`: "reference"
- `tags`: Category tags (python, mcp, react, etc.)
- `content`: Digested insight (concise, actionable)
- `source_url`: Original source (RAG/web)
- `created_at`: Timestamp

**BRAIN Stats** (queried from Archon):
- Count documents by tag/category
- Last updated per category
- Total reference count
- Health percentage calculated

### `/learn` Flow

1. User runs `/learn {topic}`
2. Search Archon RAG + web for topic
3. **Digest findings into concise insights**
4. Present for approval
5. Store approved insights via `manage_document`
6. Tags determine category

### Selective Loading Flow

1. PRP/Skill specifies needed categories (e.g., "python", "mcp")
2. Query: `find_documents(document_type="reference", query="python")`
3. Only relevant insights load into context

## Dependencies

### Required
- Archon MCP (RAG search)
- Existing command structure

### Optional
- Web MCP (enhanced web search)

## Out of Scope

- Business/non-technical content
- Automatic reference detection from code
- Reference versioning
- Cross-reference linking
```

### README.md
`$(@{Path=README.md; Language=markdown; Lines=System.Object[]}.Language)
# AI Coding System Template

A comprehensive markdown-based command system for orchestrating AI-assisted development workflows through MCP (Model Context Protocol) integration. This template provides a complete framework for managing the software development lifecycle from discovery to deployment.

## Overview

This system manages the complete development lifecycle through intelligent markdown artifacts and **powerful MCP (Model Context Protocol) server integration**. It transforms the way AI assistants work with codebases by providing structured context gathering, automated documentation generation, and task-driven development workflows.

**Key Capabilities:**
- **Token-efficient context loading** - Only load relevant codebase artifacts AND references
- **Automated documentation generation** - PRD, Tech Specs, PRPs from AI analysis
- **Task-driven development** - Archon MCP integration for progress tracking
- **Smart Reference Library** - Store and retrieve digested coding insights from RAG/web
- **RAG-powered research** - Search knowledge base and web for best practices
- **Web MCP integration** - Enhanced discovery and planning with web research
- **Comprehensive testing** - AI-suggested fixes and coverage reports
- **Resume capability** - Pick up from any phase after interruptions

## What Makes This System Powerful

### MCP-Powered Architecture

This system leverages multiple MCP servers to create a **unified development intelligence platform**:

| MCP Server | Purpose | Key Capabilities |
|------------|---------|------------------|
| **Archon MCP** | Task & Knowledge Management | Project tracking, task management, RAG knowledge base, document storage |
| **Supabase MCP** | Database Operations | Reference library storage, queries, type generation |
| **Web MCP Servers** | External Research | Web search, content extraction, URL reading |

### The Intelligent Reference Library

At the heart of this system is a **token-efficient knowledge management system**:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     HOW IT WORKS                                    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                     â”‚
â”‚  1. LEARN PHASE                                                    â”‚
â”‚     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚     â”‚ /learn  â”‚â”€â”€â”€â–¶â”‚ RAG KB   â”‚â”€â”€â”€â–¶â”‚ Web MCP  â”‚â”€â”€â”€â–¶â”‚ Digest   â”‚   â”‚
â”‚     â”‚ {topic} â”‚    â”‚ Search   â”‚    â”‚ Search   â”‚    â”‚ Insights â”‚   â”‚
â”‚     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                      â”‚             â”‚
â”‚                                                      â–¼             â”‚
â”‚                                            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚                                            â”‚   Supabase      â”‚    â”‚
â”‚                                            â”‚   Store JSONB   â”‚    â”‚
â”‚                                            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚                                                                     â”‚
â”‚  2. SELECTIVE LOADING (The Magic!)                                  â”‚
â”‚     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”‚
â”‚     â”‚ PRP specifies  â”‚â”€â”€â”€â–¶â”‚ Query: WHERE category IN    â”‚        â”‚
â”‚     â”‚ categories     â”‚    â”‚ (python, mcp)               â”‚        â”‚
â”‚     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â”‚
â”‚                               â”‚                                     â”‚
â”‚                               â–¼                                     â”‚
â”‚                     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                        â”‚
â”‚                     â”‚ ONLY load relevant  â”‚                        â”‚
â”‚                     â”‚ references into     â”‚                        â”‚
â”‚                     â”‚ AI context!         â”‚                        â”‚
â”‚                     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                        â”‚
â”‚                                                                     â”‚
â”‚  3. EXECUTE WITH CONTEXT                                           â”‚
â”‚     AI has ONLY the knowledge it needs â†’ Better code, less tokens   â”‚
â”‚                                                                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Why This Matters

**Problem**: Loading entire documentation bases wastes tokens and dilutes context.

**Solution**: Store **digested insights** (not raw dumps) and **selectively load** only what's relevant.

**Benefits**:
- 80-90% reduction in reference token usage
- Higher quality AI responses (focused context)
- Faster response times
- Reusable knowledge across all features

## Features

### Core Workflow Commands
- **`/prime`** - Export complete codebase context for AI analysis
- **`/discovery`** - Explore ideas, inspiration, and opportunities with RAG/web research
- **`/planning {feature}`** - Generate PRD from discovery insights
- **`/development {feature}`** - Generate technical specifications with stack recommendations
- **`/task-planning {feature}`** - Create implementation plans with PRP and Archon tasks
- **`/execution {feature}`** - Execute tasks sequentially with progress tracking
- **`/review {feature}`** - AI-powered code review with quality, security, and performance analysis
- **`/test {feature}`** - Run tests with AI-suggested fixes
- **`/workflow {feature}`** - Execute complete pipeline with resume support

### Smart Reference Library
- **`/learn {topic}`** - Search RAG/web, digest insights, store for reuse
- **`/learn-health`** - Check library coverage and get suggestions

### Utility Commands
- **`/check`** - Comprehensive codebase health check, cleanup, and documentation updates
- **`/update-index`** - Update directory INDEX.md files
- **`/update-status`** - Update feature STATUS.md tracking

## Quick Start

### Prerequisites

| Component | Purpose | Required |
|-----------|---------|----------|
| **Claude Code CLI** | Primary AI assistant interface | âœ… Yes |
| **Archon MCP Server** | Task management and RAG knowledge base | â­ Recommended |
| **Supabase** | Database for Smart Reference Library | â­ Recommended |
| **Web MCP Servers** | Enhanced web research for discovery/planning | Optional |

### MCP Server Setup

#### 1. Archon MCP Server (Recommended)

Archon MCP provides task management, project tracking, and RAG knowledge base.

**Installation**:
```bash
# Clone Archon MCP
git clone https://github.com/your-repo/archon-mcp
cd archon-mcp

# Install dependencies
npm install

# Configure environment
cp .env.example .env
# Edit .env with your settings

# Start server
npm start
```

**Configure Claude Code**:
```json
// ~/.claude/config.json or .claude/settings.local.json
{
  "mcpServers": {
    "archon": {
      "command": "node",
      "args": ["/path/to/archon-mcp/dist/index.js"],
      "env": {
        "ARCHON_API_URL": "http://localhost:3000",
        "ARCHON_API_KEY": "your-api-key"
      }
    }
  }
}
```

**Verify Connection**:
```bash
# Claude Code will automatically connect
# Ask: "Check Archon MCP health"
# Should return: {"status": "healthy", ...}
```

#### 2. Supabase MCP Server (Reference Library)

Supabase MCP provides database operations for the Smart Reference Library.

**Prerequisites**:
- Create Supabase project at https://supabase.com
- Run migration to create `archon_references` table

**Migration SQL**:
```sql
-- Run in Supabase SQL Editor
CREATE TABLE IF NOT EXISTS archon_references (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  title TEXT NOT NULL,
  category TEXT NOT NULL,
  tags TEXT[] DEFAULT '{}',
  content JSONB NOT NULL,
  source_url TEXT,
  author TEXT DEFAULT 'AI Coding System',
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX idx_archon_references_category ON archon_references(category);
CREATE INDEX idx_archon_references_tags ON archon_references USING GIN(tags);
```

**Configure Claude Code**:
```json
{
  "mcpServers": {
    "supabase": {
      "command": "npx",
      "args": [
        "-y",
        "@supabase/mcp-server-supabase",
        "--project-url",
        "https://your-project.supabase.co",
        "--access-token",
        "your-service-role-key"
      ]
    }
  }
}
```

#### 3. Web MCP Servers (Optional)

Enhanced web research for discovery and planning phases.

**Available Servers**:
- `web-search-prime` - Enhanced web search
- `web-reader` - Extract content from URLs
- `zread` - Advanced GitHub repository reading

**Configure Claude Code**:
```json
{
  "mcpServers": {
    "web-search-prime": {
      "command": "npx",
      "args": ["-y", "web-search-prime-mcp-server"]
    },
    "web-reader": {
      "command": "npx",
      "args": ["-y", "web-reader-mcp-server"]
    },
    "zread": {
      "command": "npx",
      "args": ["-y", "zread-mcp-server"]
    }
  }
}
```

**Verify All MCP Servers**:
```bash
# In Claude Code, ask:
"Check all MCP server health"

# Should return status for each configured server
```

### Installation

1. **Clone this repository:**
   ```bash
   git clone https://github.com/ryanjosebrosas/AI-Coding-System-Template.git
   cd AI-Coding-System-Template
   ```

2. **Configure MCP Servers** (see above)

3. **Run initial setup:**
   ```bash
   # Export codebase context
   /prime

   # Explore opportunities
   /discovery
   ```

4. **Build your reference library:**
   ```bash
   # Learn essential topics
   /learn python async patterns
   /learn react hooks
   /learn mcp server development

   # Check library health
   /learn-health
   ```

### Basic Usage

```bash
# 1. Start a new feature
/planning my-feature

# 2. Generate technical spec
/development my-feature

# 3. Create implementation plan
/task-planning my-feature

# 4. Execute implementation
/execution my-feature

# 5. Review code
/review my-feature

# 6. Run tests
/test my-feature
```

### Unified Workflow

Execute all phases automatically:

```bash
# Full pipeline
/workflow my-feature

# Resume from specific phase
/workflow my-feature --from-development
```

### Building Your Reference Library

```bash
# Learn a new topic
/learn python async patterns

# Check library health
/learn-health
```

## Directory Structure

```
project-root/
â”œâ”€â”€ .claude/
â”‚   â”œâ”€â”€ commands/          # Workflow command definitions
â”‚   â”‚   â”œâ”€â”€ prime.md
â”‚   â”‚   â”œâ”€â”€ discovery.md
â”‚   â”‚   â”œâ”€â”€ planning.md
â”‚   â”‚   â”œâ”€â”€ development.md
â”‚   â”‚   â”œâ”€â”€ task-planning.md
â”‚   â”‚   â”œâ”€â”€ execution.md
â”‚   â”‚   â”œâ”€â”€ review.md
â”‚   â”‚   â”œâ”€â”€ test.md
â”‚   â”‚   â”œâ”€â”€ workflow.md
â”‚   â”‚   â”œâ”€â”€ learn.md         # Reference library commands
â”‚   â”‚   â”œâ”€â”€ learn-health.md
â”‚   â”‚   â””â”€â”€ ...
â”‚   â””â”€â”€ templates/         # STATUS.md template
â”œâ”€â”€ context/               # Codebase exports from /prime
â”œâ”€â”€ discovery/             # Ideas and opportunities from /discovery
â”œâ”€â”€ features/              # Feature-specific artifacts
â”‚   â”œâ”€â”€ {feature-name}/
â”‚   â”‚   â”œâ”€â”€ prd.md        # Product Requirements
â”‚   â”‚   â”œâ”€â”€ tech-spec.md  # Technical Specification
â”‚   â”‚   â”œâ”€â”€ prp.md        # Plan Reference Protocol
â”‚   â”‚   â”œâ”€â”€ task-plan.md  # Task breakdown
â”‚   â”‚   â”œâ”€â”€ execution/    # Task files (deleted as completed)
â”‚   â”‚   â””â”€â”€ STATUS.md     # Progress tracking
â”‚   â””â”€â”€ INDEX.md          # Features index
â”œâ”€â”€ templates/
â”‚   â””â”€â”€ prp/               # PRP templates for different feature types
â”‚       â”œâ”€â”€ prp-base.md
â”‚       â”œâ”€â”€ prp-ai-agent.md
â”‚       â”œâ”€â”€ prp-mcp-integration.md
â”‚       â”œâ”€â”€ prp-api-endpoint.md
â”‚       â””â”€â”€ prp-frontend-component.md
â”œâ”€â”€ reviews/               # Code review reports
â”œâ”€â”€ testing/               # Test results
â”œâ”€â”€ execution/             # System implementation tasks
â”œâ”€â”€ PRD.md                 # Root Product Requirements Document
â”œâ”€â”€ TECH-SPEC.md           # Root Technical Specification
â”œâ”€â”€ MVP.md                 # Minimum Viable Product definition
â”œâ”€â”€ CLAUDE.md              # Developer guidelines
â”œâ”€â”€ INDEX.md               # System navigation index
â””â”€â”€ README.md              # This file
```

## Architecture

### Complete System Architecture

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        AI CODING SYSTEM - COMPLETE ARCHITECTURE                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚                        MCP SERVER LAYER                                  â”‚   â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤   â”‚
â”‚  â”‚   Archon MCP     â”‚   Supabase MCP   â”‚   Web MCP        â”‚   Future MCPs  â”‚   â”‚
â”‚  â”‚                  â”‚                  â”‚   Servers        â”‚                â”‚   â”‚
â”‚  â”‚ â€¢ Task Mgmt      â”‚ â€¢ Reference Lib  â”‚ â€¢ Web Search     â”‚ â€¢ Custom tools â”‚   â”‚
â”‚  â”‚ â€¢ Projects       â”‚ â€¢ Queries        â”‚ â€¢ Content Read   â”‚                â”‚   â”‚
â”‚  â”‚ â€¢ RAG Knowledge  â”‚ â€¢ Type Gen       â”‚ â€¢ GitHub Read    â”‚                â”‚   â”‚
â”‚  â”‚ â€¢ Documents      â”‚                  â”‚                  â”‚                â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                    â”‚                                             â”‚
â”‚                                    â–¼                                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚                        COMMAND LAYER                                     â”‚   â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤   â”‚
â”‚  â”‚  Workflow: /prime, /discovery, /planning, /development, /task-planning â”‚   â”‚
â”‚  â”‚            /execution, /review, /test, /workflow                        â”‚   â”‚
â”‚  â”‚  Library:  /learn, /learn-health                                         â”‚   â”‚
â”‚  â”‚  Utility:  /check, /update-index, /update-status                         â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                    â”‚                                             â”‚
â”‚                                    â–¼                                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚                        ARTIFACT LAYER                                     â”‚   â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤   â”‚
â”‚  â”‚  Context/    Discovery/  Features/     Templates/   Reviews/   Testing/  â”‚   â”‚
â”‚  â”‚  exports     ideas       PRDs, Specs,  PRPs         reports    results   â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                    â”‚                                             â”‚
â”‚                                    â–¼                                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚                        DATA LAYER                                        â”‚   â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤   â”‚
â”‚  â”‚  Supabase:                                                              â”‚   â”‚
â”‚  â”‚  â€¢ archon_projects      - Feature tracking                               â”‚   â”‚
â”‚  â”‚  â€¢ archon_tasks         - Task management                                â”‚   â”‚
â”‚  â”‚  â€¢ archon_references    - Smart Reference Library (JSONB)                â”‚   â”‚
â”‚  â”‚  â€¢ archon_documents     - Doc storage                                    â”‚   â”‚
â”‚  â”‚  â€¢ archon_versions      - Version history                                â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Workflow Phases with MCP Integration

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Prime  â”‚â”€â”€â”€â–¶â”‚ Discoveryâ”‚â”€â”€â”€â–¶â”‚ Planningâ”‚â”€â”€â”€â–¶â”‚Development  â”‚â”€â”€â”€â–¶â”‚Task Plan â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
     â”‚              â”‚               â”‚                â”‚                â”‚
     â–¼              â–¼               â–¼                â–¼                â–¼
  Context       Discovery        PRD           TECH-SPEC        PRP + Refs
 (Export)     (RAG+Web)      (Archon)       (Archon)       (Selective Load)
                                                                               â”‚
                                                                               â–¼
                                                                        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                                                                        â”‚Execution â”‚
                                                                        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                                                               â”‚
                                                                               â–¼
                                                                        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                                                                        â”‚ Tasks (Archon)   â”‚
                                                                        â”‚ â€¢ Status updates â”‚
                                                                        â”‚ â€¢ Progress track â”‚
                                                                        â”‚ â€¢ Context load   â”‚
                                                                        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                                                               â”‚
                                                                               â–¼
                                                                        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                                                                        â”‚ Review + Test    â”‚
                                                                        â”‚ AI analysis      â”‚
                                                                        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Smart Reference Library Deep Dive

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    REFERENCE LIBRARY - COMPLETE WORKFLOW                       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                                 â”‚
â”‚  PHASE 1: LEARN (Building the Library)                                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚                                                                          â”‚  â”‚
â”‚  â”‚  User: /learn python async patterns                                      â”‚  â”‚
â”‚  â”‚     â”‚                                                                   â”‚  â”‚
â”‚  â”‚     â”œâ”€â–¶ Archon RAG: Search knowledge base                               â”‚  â”‚
â”‚  â”‚     â”‚   â€¢ Query: "python async" (2-5 keywords!)                         â”‚  â”‚
â”‚  â”‚     â”‚   â€¢ Returns: Relevant documentation pages                         â”‚  â”‚
â”‚  â”‚     â”‚                                                                   â”‚  â”‚
â”‚  â”‚     â”œâ”€â–¶ Web MCP: Search external sources                                â”‚  â”‚
â”‚  â”‚     â”‚   â€¢ web_search_prime_search()                                     â”‚  â”‚
â”‚  â”‚     â”‚   â€¢ web_reader_read() for content extraction                      â”‚  â”‚
â”‚  â”‚     â”‚                                                                   â”‚  â”‚
â”‚  â”‚     â”œâ”€â–¶ Digest: AI processes into structured format                     â”‚  â”‚
â”‚  â”‚     â”‚   {                                                               â”‚  â”‚
â”‚  â”‚     â”‚     "summary": "1-2 sentence overview",                           â”‚  â”‚
â”‚  â”‚     â”‚     "insights": [                                                 â”‚  â”‚
â”‚  â”‚     â”‚       "Actionable insight 1",                                     â”‚  â”‚
â”‚  â”‚     â”‚       "Actionable insight 2"                                      â”‚  â”‚
â”‚  â”‚     â”‚     ],                                                            â”‚  â”‚
â”‚  â”‚     â”‚     "code_examples": [...]                                       â”‚  â”‚
â”‚  â”‚     â”‚   }                                                               â”‚  â”‚
â”‚  â”‚     â”‚                                                                   â”‚  â”‚
â”‚  â”‚     â””â”€â–¶ Store: Supabase INSERT into archon_references                   â”‚  â”‚
â”‚  â”‚         â€¢ category: 'python'                                           â”‚  â”‚
â”‚  â”‚         â€¢ tags: ['python', 'async', 'patterns']                        â”‚  â”‚
â”‚  â”‚         â€¢ content: JSONB digest                                        â”‚  â”‚
â”‚  â”‚         â€¢ source_url: original source                                  â”‚  â”‚
â”‚  â”‚                                                                          â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                                                                 â”‚
â”‚  PHASE 2: HEALTH CHECK (Monitoring)                                           â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚  User: /learn-health                                                      â”‚  â”‚
â”‚  â”‚     â”‚                                                                     â”‚  â”‚
â”‚  â”‚     â””â”€â–¶ Query: SELECT category, COUNT(*), ARRAY_AGG(tags)                â”‚  â”‚
â”‚  â”‚              FROM archon_references                                      â”‚  â”‚
â”‚  â”‚              GROUP BY category                                           â”‚  â”‚
â”‚  â”‚                                                                          â”‚  â”‚
â”‚  â”‚         Output:                                                           â”‚  â”‚
â”‚  â”‚         ðŸ“Š Reference Library Health                                       â”‚  â”‚
â”‚  â”‚         âœ“ python: 3 references (async, patterns, testing)               â”‚  â”‚
... [truncated: showing first 500 and last 500 lines] ...
```

### Example 4: Resume Capability

```bash
# Start full workflow
/workflow user-authentication

# System starts executing:
# â†’ Discovery complete âœ“
# â†’ Planning complete âœ“
# â†’ Development complete âœ“
# â†’ Task Planning complete âœ“
# â†’ Execution: Task 1 in progress...

# âš ï¸ POWER LOSS! Session interrupted.

# Resume from where we left off:
/workflow user-authentication --from-execution

# System checks:
# â†’ Discovery phase: Complete (prd.md exists)
# â†’ Planning phase: Complete (tech-spec.md exists)
# â†’ Development phase: Complete (tech-spec.md exists)
# â†’ Task Planning phase: Complete (prp.md exists)
# â†’ Execution phase: Incomplete (Task 1 in doing status)
#
# System action:
# â†’ Skips to Execution phase
# â†’ Continues from Task 1
# â†’ Completes remaining tasks

# No duplicate work! Smart resume!
```

### Example 5: MCP Tools in Action

```bash
# Direct MCP tool usage during development

# Task: Find async patterns for Python MCP server

# Option 1: Ask AI (recommended)
"How do I implement async tool execution in my MCP server?"

# AI uses Archon RAG:
# 1. rag_search_knowledge_base(query="python async")
# 2. Finds relevant documentation
# 3. rag_search_code_examples(query="asyncio gather")
# 4. Loads code examples
# 5. Provides answer with examples

# Option 2: Direct query (advanced)
# AI executes:
find_tasks(filter_by="status", filter_value="todo")
# â†’ Returns: Task 2: Implement async tool execution

manage_task("update", task_id="t-2", status="doing")
# â†’ Marks as in progress

rag_search_knowledge_base(query="python async patterns")
# â†’ Returns: 3 relevant pages with async patterns

rag_search_code_examples(query="asyncio tool execution")
# â†’ Returns: 2 code examples

# AI implements based on research
manage_task("update", task_id="t-2", status="review")
# â†’ Marks for review
```

## MCP Server Capabilities

### Archon MCP - Task & Knowledge Management

Archon MCP is the **central intelligence hub** for this system, providing:

| Tool | Purpose | Usage Example |
|------|---------|---------------|
| `manage_project()` | Create/update/delete projects | `manage_project("create", title="Auth Feature")` |
| `find_projects()` | List/search projects | `find_projects(query="auth")` |
| `manage_task()` | Create/update/delete tasks | `manage_task("create", project_id="p-1", title="Setup")` |
| `find_tasks()` | Query tasks by status/project | `find_tasks(filter_by="status", filter_value="todo")` |
| `rag_search_knowledge_base()` | Search documentation RAG | `rag_search_knowledge_base(query="async python")` |
| `rag_search_code_examples()` | Find code examples | `rag_search_code_examples(query="React hooks")` |
| `rag_get_available_sources()` | List knowledge sources | Get available documentation sources |
| `rag_read_full_page()` | Read full page content | Read complete documentation page |
| `manage_document()` | Store project documents | `manage_document("create", project_id="p-1", ...)` |
| `health_check()` | Verify server status | Check if MCP is available |

**Task Status Flow**: `todo` â†’ `doing` â†’ `review` â†’ `done`

**Key Features**:
- **RAG Knowledge Base**: Pre-loaded with technical documentation (PydanticAI, Supabase, etc.)
- **Project Hierarchy**: Organize features, track progress across multiple workstreams
- **Task Dependencies**: Block/unblock tasks for complex workflows
- **Version History**: Track changes to docs, features, PRDs

### Supabase MCP - Database Operations

Supabase MCP provides the **persistence layer** for the Smart Reference Library:

| Tool | Purpose | Usage Example |
|------|---------|---------------|
| `execute_sql()` | Run raw SQL queries | `SELECT * FROM archon_references` |
| `apply_migration()` | Apply schema migrations | Create new tables |
| `list_tables()` | Show database tables | View available tables |
| `generate_typescript_types()` | Generate TS types | Auto-generate type definitions |
| `get_project_url()` | Get Supabase API URL | Configure API connections |

**Key Tables**:
- `archon_projects` - Feature tracking
- `archon_tasks` - Task management with dependencies
- `archon_references` - Smart Reference Library (JSONB content)
- `archon_documents` - Document storage
- `archon_versions` - Version history

### Web MCP Servers - External Research

Web MCP servers enable **intelligent web research** during Discovery and Planning:

| Tool | Purpose | Usage Example |
|------|---------|---------------|
| `web_search_prime_search()` | Enhanced web search | Find AI agent patterns |
| `web_reader_read()` | Extract page content | Read documentation URLs |
| `get_repo_structure()` | Explore GitHub repos | Browse repository structure |
| `read_file()` | Read GitHub files | Get specific file content |
| `search_doc()` | Search repo docs | Find issues/docs in repos |

**Benefits over built-in web search**:
- **Token optimization** - Extract only relevant content
- **Structured output** - Markdown-ready formatting
- **GitHub integration** - Direct repository access
- **Caching** - Avoid re-fetching same content

## Reference Library System

### Standard Categories

| Category | Description | Example Topics |
|----------|-------------|----------------|
| `python` | Python patterns, libraries | async, FastAPI, Django, type hints |
| `mcp` | MCP server development | tools, server setup, best practices |
| `react` | React, Next.js, hooks | useState, useEffect, components |
| `typescript` | TypeScript/JavaScript | generics, utility types, patterns |
| `ai-agents` | AI agent patterns | prompting, RAG, tool use |
| `testing` | Testing frameworks | pytest, jest, vitest |
| `patterns` | General design patterns | DRY, KISS, SOLID |
| `supabase` | Supabase/database | RLS, queries, auth |
| `api` | API design | REST, GraphQL, OpenAPI |

### Tag System

Tags provide **fine-grained filtering** beyond categories:

```sql
-- Reference with category + tags
{
  "category": "python",
  "tags": ["python", "async", "await", "asyncio", "concurrency"]
}

-- Query with flexible tag matching
SELECT * FROM archon_references
WHERE category = 'python'
  OR 'async' = ANY(tags)  -- Match specific tag
  OR 'concurrency' = ANY(tags)
```

### Real-World Usage Examples

**Example 1: Learning Python Async Patterns**
```bash
# Step 1: Learn from gist
/learn https://gist.github.com/.../python-async-guide

# Result: Reference stored
# - category: python
# - tags: ['python', 'async', 'asyncio', 'await', 'concurrency']
# - content: {summary, insights, code_examples}

# Step 2: Use during development
/task-planning python-mcp-server
# PRP includes:
# "Required Categories: python, mcp"
# "Optional Tags: async, testing"

# Result: ONLY python + mcp references loaded!
# Including the async patterns we just learned!
```

**Example 2: Building Knowledge Over Time**
```bash
# Learn incrementally
/learn python type hints          # â†’ python (1)
/learn python async patterns      # â†’ python (2)
/learn mcp server development     # â†’ mcp (1)
/learn react hooks                # â†’ react (1)

# Check health
/learn-health
# Output:
# ðŸ“Š Reference Library Health
# âœ“ python: 2 references
# âœ“ mcp: 1 reference
# âœ“ react: 1 reference
# âš  typescript: 0 references - SUGGEST: Learn TypeScript basics
# âš  testing: 0 references - SUGGEST: Learn pytest patterns

# Address gaps
/learn typescript utility types
/learn pytest fixtures
```

**Example 3: Selective Loading in Action**
```bash
# Scenario: Building an MCP server in Python

# PRP specifies:
### Reference Library
**Required Categories**: python, mcp
**Optional Tags**: async, testing

# System executes:
SELECT * FROM archon_references
WHERE category IN ('python', 'mcp')
  OR 'async' = ANY(tags)
  OR 'testing' = ANY(tags);

# Results (5 references loaded):
1. Python async patterns (learned from gist)
2. Python type hints (learned from docs)
3. MCP server development (learned from web)
4. Async context managers (python + async tag)
5. Pytest fixture patterns (python + testing tag)

# NOT loaded:
- React hooks (wrong category)
- TypeScript generics (wrong category)
- Supabase RLS policies (wrong category)

# Token savings:
# Total library: 20 references
# Loaded for task: 5 references
# Savings: 75% fewer tokens!
```

## Archon MCP Integration

This system deeply integrates with Archon MCP for:

### Task Management
- **Create tasks** with `manage_task("create", ...)` during `/task-planning`
- **Update status** as work progresses: `todo` â†’ `doing` â†’ `review` â†’ `done`
- **Track dependencies** with `addBlockedBy` and `addBlocks`
- **Query tasks** by status, project, or assignee

### Knowledge Base
- **Search documentation** with `rag_search_knowledge_base()`
- **Find code examples** with `rag_search_code_examples()`
- **List sources** to see available documentation
- **Read full pages** for complete context

### Project Organization
- **Create projects** for each feature
- **Link tasks** to projects
- **Store documents** (PRDs, specs) per project
- **Track versions** of documentation

### Required Archon Tools

The following Archon MCP tools are **required** for full functionality:

**Task Management**:
- `manage_task(action, project_id, title, ...)` - Create/update/delete tasks
- `find_tasks(task_id, query, filter_by, ...)` - Query tasks

**Project Management**:
- `manage_project(action, title, description, ...)` - Create/update projects
- `find_projects(project_id, query, ...)` - Query projects

**Knowledge Base (RAG)**:
- `rag_search_knowledge_base(query, source_id, ...)` - Search docs
- `rag_search_code_examples(query, source_id, ...)` - Find examples
- `rag_get_available_sources()` - List documentation sources
- `rag_read_full_page(page_id, url)` - Read complete pages

**Documents**:
- `manage_document(action, project_id, title, ...)` - Store docs
- `find_documents(project_id, document_id, query, ...)` - Query docs

**Health**:
- `health_check()` - Verify server availability

## Token Efficiency Strategy

This system is **architected for token efficiency** at every level:

### 1. Selective Context Loading

**Problem**: Loading entire codebases and documentation bases wastes tokens.

**Solution**: Load ONLY what's needed for the current task.

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  TRADITIONAL APPROACH (Token-Heavy)                         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Load ALL references â†’ 50,000+ tokens                       â”‚
â”‚  Load ALL codebase â†’ 100,000+ tokens                        â”‚
â”‚  Load ALL docs â†’ 75,000+ tokens                             â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                  â”‚
â”‚  Total: 225,000+ tokens per task!                           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  THIS SYSTEM (Token-Efficient)                              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Load ONLY relevant references â†’ 5,000 tokens               â”‚
â”‚  Load ONLY current feature files â†’ 10,000 tokens            â”‚
â”‚  Load ONLY required docs â†’ 3,000 tokens                     â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                  â”‚
â”‚  Total: 18,000 tokens per task (92% savings!)               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2. Digestion vs. Raw Storage

**Store insights, not articles**:

```sql
-- BAD: Store full article (10,000+ tokens)
content: "Full article text with all the fluff..."

-- GOOD: Store digested insights (500 tokens)
content: {
  "summary": "Python async/await patterns for concurrent I/O",
  "insights": [
    "Use asyncio.gather() to run multiple coroutines concurrently",
    "Always use async/await consistently - don't mix sync and async",
    "Use asyncio.create_task() for fire-and-forget operations"
  ],
  "code_examples": [
    {
      "title": "Concurrent HTTP requests",
      "language": "python",
      "code": "async def fetch_all(urls):\n    ..."
    }
  ]
}
```

**Result**: 95% token reduction, same actionable knowledge!

### 3. Lazy Loading Strategy

```
Task starts â†’ Check PRP for required categories
              â†“
              Query Supabase: WHERE category IN (required)
              â†“
              Load ONLY matching references (5-10 items)
              â†“
              Execute task with focused context
```

### 4. Caching Strategy

- **Archon RAG**: Cached knowledge base for fast doc searches
- **Web MCP**: Optional caching for frequently accessed URLs
- **Supabase**: Indexed queries on category/tags for fast lookups

### Token Savings Calculation

```
Scenario: Building an MCP server in Python

Traditional Approach:
â”œâ”€ All references (20 items Ã— 2,000 tokens)    = 40,000 tokens
â”œâ”€ All codebase files                         = 80,000 tokens
â”œâ”€ All documentation                          = 30,000 tokens
â””â”€ Total                                      = 150,000 tokens

This System:
â”œâ”€ Relevant refs only (5 items Ã— 500 tokens)  = 2,500 tokens
â”œâ”€ Current feature files                      = 10,000 tokens
â”œâ”€ Required docs only                         = 3,000 tokens
â””â”€ Total                                      = 15,500 tokens

SAVINGS: 134,500 tokens (90% reduction!)
```

### Best Practices for Token Efficiency

1. **Be specific with PRP categories**: Only request what you need
2. **Use tags for fine filtering**: `['async', 'testing']` vs loading all Python
3. **Keep insights concise**: 3-5 bullet points, not 20
4. **Code examples**: Only include directly relevant snippets
5. **Avoid redundant info**: Don't repeat the same pattern across references

## Contributing

Contributions are welcome! This is an open-source template for AI-assisted development.

Areas for contribution:
- Additional PRP templates for different feature types
- New workflow commands
- Enhanced MCP integrations
- Documentation improvements
- Bug fixes and optimizations

## License

MIT License - See LICENSE file for details

## Acknowledgments

Built with:
- **[Claude Code CLI](https://claude.ai/claude-code)** - Primary AI assistant interface
- **[Archon MCP](https://github.com/your-repo/archon)** - Task management, knowledge base, RAG
- **[Supabase](https://supabase.com)** - Database for Smart Reference Library
- **Web MCP Servers** - Enhanced web research (web-search-prime, web-reader, zread)

Inspired by:
- PEP 20 (The Zen of Python)
- The Hitchhiker's Guide to Python
- Khan Academy Development Docs
- The Pragmatic Programmer

## System Status

| Component | Status | Notes |
|-----------|--------|-------|
| Core Commands | âœ… Stable | /prime, /discovery, /planning, /development, etc. |
| Archon Integration | âœ… Active | Task management, RAG knowledge base |
| Reference Library | âœ… Active | Supabase-backed, selective loading |
| Web MCP Integration | âœ… Active | Enhanced research capabilities |
| Documentation | âœ… Complete | Comprehensive README and CLAUDE.md |

## FAQ

**Q: Do I need all MCP servers to use this system?**

A: No! The system works with Claude Code alone. MCP servers provide **enhanced capabilities**:
- **Archon MCP**: Task tracking, RAG knowledge base (recommended)
- **Supabase MCP**: Smart Reference Library (recommended)
- **Web MCP**: Better web research (optional)

**Q: How much does this cost in tokens?**

A: The system is designed for token efficiency:
- Traditional approach: 150,000+ tokens per task
- This system: ~15,000 tokens per task (90% savings)
- Selective reference loading is the key

**Q: Can I use this without Supabase?**

A: Yes! The Smart Reference Library is optional. Without it:
- `/learn` command won't store references
- PRPs won't load external references
- System still works with codebase context only

**Q: How do I add new PRP templates?**

A: Create new template files in `templates/prp/`:
```bash
# Example: templates/prp/prp-api-endpoint.md
---
### Reference Library
**Required Categories**: api, {language}

### Implementation Blueprint
1. Define API endpoint
2. Implement request validation
3. Implement business logic
4. Add error handling
5. Write tests
---
```

**Q: Can I customize the workflow phases?**

A: Yes! Edit workflow command files in `.claude/commands/`:
- `workflow.md` - Full pipeline
- Individual phase commands - `/planning`, `/development`, etc.

**Q: How do I migrate my existing project?**

A: Three steps:
1. Clone this repo into your project root
2. Run `/prime` to export your codebase
3. Run `/discovery` to explore opportunities

---

**GitHub Repository**: https://github.com/ryanjosebrosas/AI-Coding-System-Template

**Template Version**: 1.1
**Last Updated**: 2026-01-25
**MCP Integration**: Archon + Supabase + Web MCP servers
```

### reviews\\INDEX.md
`$(@{Path=reviews\\INDEX.md; Language=markdown; Lines=System.Object[]}.Language)
# Reviews Index

## Overview
This directory contains code review reports generated by the Review command. Reviews analyze code quality, security, performance, and compliance with PRD and tech spec.

## Files

## Navigation
- [Back to Root](../)
- [Features](../features/)
- [Testing](../testing/)
```

### TECH-SPEC.md
`$(@{Path=TECH-SPEC.md; Language=markdown; Lines=System.Object[]}.Language)
# Technical Specification: Smart Reference Library

**Version**: 1.0 | **Last Updated**: 2026-01-24

## System Architecture

### Overview

The Smart Reference Library uses Archon/Supabase as the storage backend. References are stored as Archon documents with category tags, enabling structured queries and selective loading.

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      User Commands                          â”‚
â”‚              /learn {topic}    /learn-health                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                      â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  Command Layer                              â”‚
â”‚   .claude/commands/learn.md  .claude/commands/learn-health.mdâ”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                      â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  Research Layer                             â”‚
â”‚     rag_search_knowledge_base()    WebSearch (fallback)     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                      â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  Digest Layer (LLM)                         â”‚
â”‚     Raw findings â†’ Concise, actionable insights             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                      â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  Storage Layer (Archon)                     â”‚
â”‚     manage_document()  find_documents()  find_projects()    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Design Principles

1. **Token Efficiency**: Only load relevant references via selective queries
2. **Digested Insights**: Store processed knowledge, not raw dumps
3. **Structured Storage**: Leverage Archon/Supabase for querying and stats
4. **Category Tagging**: Enable filtering by technology/domain

## Technology Stack

| Component | Technology | Purpose |
|-----------|------------|---------|
| Storage | Supabase (direct SQL) | `archon_references` table |
| Search | Archon RAG | Knowledge base search for topics |
| Web Research | WebSearch tool | External best practices |
| Commands | Markdown + YAML | Command definitions |
| Digest | LLM (Claude) | Process raw â†’ insights |
| DB Access | Supabase JS/REST API | Direct table queries |

### MCP Servers

**Required**:
- `user-archon`: RAG search only (not for storage)

**Optional**:
- `web-search`: Enhanced web research (fallback to built-in)

### Database

**Table**: `archon_references` (dedicated, not project docs)
**Migration**: `012_add_smart_reference_library.sql`

## Data Models

### Dedicated Database Table

References are stored in a dedicated `archon_references` table (not in project docs JSONB).

**Migration**: `012_add_smart_reference_library.sql`

```sql
CREATE TABLE archon_references (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  title TEXT NOT NULL,
  category TEXT NOT NULL,  -- python, mcp, react, etc.
  tags TEXT[] DEFAULT '{}',
  content JSONB NOT NULL,  -- {summary, insights, code_examples, sources}
  source_url TEXT,
  author TEXT DEFAULT 'AI Coding System',
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Indexes
CREATE INDEX idx_archon_references_category ON archon_references(category);
CREATE INDEX idx_archon_references_tags ON archon_references USING GIN(tags);
```

### Reference Record

Each reference stored as a row:

```json
{
  "id": "uuid",
  "title": "Python Async Best Practices",
  "category": "python",
  "tags": ["async", "concurrency", "patterns"],
  "content": {
    "summary": "Key patterns for async Python development",
    "insights": [
      "Use asyncio.gather() for concurrent tasks",
      "Avoid mixing sync/async - use async all the way down",
      "Use asyncio.create_task() for fire-and-forget"
    ],
    "code_examples": [
      {
        "title": "Concurrent HTTP requests",
        "language": "python",
        "code": "async def fetch_all(urls): ..."
      }
    ],
    "sources": ["https://docs.python.org/3/library/asyncio.html"],
    "learned_at": "2026-01-24T19:00:00Z"
  },
  "source_url": "https://docs.python.org/3/library/asyncio.html",
  "author": "AI Coding System"
}
```

### Direct SQL Queries

Since we're using a dedicated table (not Archon MCP documents), queries are direct SQL:

```sql
-- Insert reference
INSERT INTO archon_references (title, category, tags, content, source_url)
VALUES ('Python Async', 'python', ARRAY['async'], '{"summary": "..."}', 'https://...');

-- Query by category
SELECT * FROM archon_references WHERE category = 'python';

-- Query by tag
SELECT * FROM archon_references WHERE 'async' = ANY(tags);

-- Get stats per category
SELECT category, COUNT(*) as count, MAX(updated_at) as last_updated
FROM archon_references GROUP BY category;
```

### Category Tags

Standard category tags for filtering:

| Tag | Description |
|-----|-------------|
| `python` | Python patterns, libraries, best practices |
| `typescript` | TypeScript/JavaScript patterns |
| `react` | React components, hooks, patterns |
| `mcp` | MCP server development |
| `ai-agents` | AI agent patterns, prompting |
| `testing` | Testing patterns, frameworks |
| `patterns` | General design patterns |
| `supabase` | Supabase/database patterns |
| `api` | API design, REST, GraphQL |

### BRAIN Stats Model

Stats calculated from Archon queries:

```json
{
  "total_references": 15,
  "categories": {
    "python": { "count": 5, "last_updated": "2026-01-24" },
    "mcp": { "count": 3, "last_updated": "2026-01-23" },
    "react": { "count": 0, "last_updated": null },
    "testing": { "count": 2, "last_updated": "2026-01-22" }
  },
  "health_percentage": 60,
  "empty_categories": ["react", "ai-agents"],
  "suggestions": ["Learn React hooks", "Learn AI agent patterns"]
}
```

## Command Structure

### `/learn` Command

**File**: `.claude/commands/learn.md`

```yaml
---
name: Learn
description: "Search, digest, and save knowledge to reference library"
phase: independent
dependencies: []
inputs:
  - name: topic
    description: "Topic to learn (e.g., 'python async', 'react hooks')"
    required: true
outputs:
  - path: "Archon document"
    description: "Digested insight stored in Archon"
---
```

**Execution Flow**:

1. **Parse Topic**: Extract keywords and infer category
2. **Search RAG**: `rag_search_knowledge_base(query="{topic}", match_count=5)`
3. **Search Web** (optional): WebSearch for external resources
4. **Digest Findings**: LLM processes raw results into:
   - Summary (1-2 sentences)
   - Key insights (3-5 bullet points)
   - Code examples (if applicable)
   - Sources
5. **Present for Approval**: Show digest to user
6. **Store on Approval** (direct SQL via Supabase):
   ```sql
   INSERT INTO archon_references (title, category, tags, content, source_url)
   VALUES (
     'Python Async Best Practices',
     'python',
     ARRAY['async', 'concurrency'],
     '{"summary": "...", "insights": [...], "code_examples": [...], "sources": [...]}',
     'https://docs.python.org/...'
   );
   ```
7. **Confirm**: Show success message

### `/learn-health` Command

**File**: `.claude/commands/learn-health.md`

```yaml
---
name: Learn Health
description: "Check reference library health and stats"
phase: independent
dependencies: []
outputs:
  - description: "Health report displayed to user"
---
```

**Execution Flow**:

1. **Query Stats** (direct SQL via Supabase):
   ```sql
   SELECT category, COUNT(*) as count, MAX(updated_at) as last_updated
   FROM archon_references
   GROUP BY category;
   ```
2. **Calculate Health**:
   - Count refs per category
   - Find empty categories (compare against standard list)
   - Calculate health percentage
3. **Generate Suggestions**: Based on empty/stale categories
4. **Display Report**:
   ```
   ## Brain Health: 60%
   
   | Category | Refs | Last Updated |
   |----------|------|--------------|
   | python   | 5    | 2026-01-24   |
   | mcp      | 3    | 2026-01-23   |
   | react    | 0    | -            |
   
   **Empty**: react, ai-agents
   **Suggestions**: Learn React hooks, Learn AI agent patterns
   ```

## Integration Points

### PRP Integration

PRPs specify needed references via tags:

```markdown
## All Needed Context

### Reference Library
Load references with tags: ["python", "mcp"]
```

**Loading Flow**:
1. PRP parser extracts required categories/tags
2. Query (direct SQL):
   ```sql
   SELECT * FROM archon_references 
   WHERE category = 'python' OR 'mcp' = ANY(tags);
   ```
3. Load matching references into context
4. Agent has relevant insights available

### Skills Integration

Skills can specify reference dependencies:

```markdown
## Prerequisites

### Reference Library
Required: ["mcp", "patterns"]
```

**Loading Flow**: Same as PRP - selective query by tags.

### CLAUDE.md Integration

CLAUDE.md does NOT preload references. Instead:

```markdown
## Reference Library

References are stored in Archon under project "Smart Reference Library".
Use `/learn {topic}` to add new references.
Use `/learn-health` to check library status.

PRP and Skills specify which references to load via tags.
```

## Implementation Plan

### Phase 1: Setup (Required First)

1. **Run SQL Migration**
   - Execute `012_add_smart_reference_library.sql` in Supabase SQL Editor
   - Creates `archon_references` table with indexes and RLS

2. **Create Command Files**
   - `.claude/commands/learn.md`
   - `.claude/commands/learn-health.md`

### Phase 2: `/learn` Command

1. **Parse topic and infer category**
   - Keywords â†’ category mapping
   - Example: "python async" â†’ tags: ["python", "async"]

2. **Search and gather sources**
   - RAG search first
   - Web search if needed

3. **Digest into insights**
   - Prompt LLM to summarize
   - Extract actionable patterns
   - Include code examples

4. **Approval flow**
   - Present digest
   - Wait for user confirmation
   - Store on approval

### Phase 3: `/learn-health` Command

1. **Query all documents**
   - `find_documents(project_id="{id}")`

2. **Aggregate by tags**
   - Count per category
   - Track last updated

3. **Calculate health**
   - Categories covered / total categories
   - Flag empty categories

4. **Generate report**
   - Table format
   - Suggestions for empty categories

### Phase 4: Integration

1. **Update PRP templates**
   - Add reference loading section

2. **Document in CLAUDE.md**
   - Reference library usage

## Error Handling

| Error | Handling |
|-------|----------|
| Supabase unavailable | Inform user, suggest retry later |
| Table not found | Prompt to run migration SQL |
| No results from RAG | Fall back to web search |
| No results from web | Inform user, suggest different topic |
| Insert fails | Show error, offer retry |
| Health query fails | Show partial results if available |

## Performance Considerations

1. **Query Optimization**
   - Use `per_page` limit for document queries
   - Query by specific tags rather than all documents

2. **Token Efficiency**
   - Digests are concise (not full articles)
   - Selective loading only what's needed
   - Category-based filtering

3. **Caching**
   - Project ID can be cached (rarely changes)
   - Stats can be calculated on-demand (no caching needed)

## Security

1. **Content Filtering**
   - Only technical/coding content
   - No business secrets or sensitive data
   - User approval before storage

2. **Source Attribution**
   - Track source URLs
   - Maintain provenance

## Validation Checklist

### `/learn` Command
- [ ] Topic parsed correctly
- [ ] RAG search executed
- [ ] Findings digested into insights
- [ ] Approval flow works
- [ ] Document stored in Archon
- [ ] Correct tags applied

### `/learn-health` Command
- [ ] Documents queried successfully
- [ ] Stats calculated correctly
- [ ] Empty categories identified
- [ ] Health percentage accurate
- [ ] Suggestions generated

### Integration
- [ ] PRP can specify reference tags
- [ ] Selective loading works
- [ ] CLAUDE.md updated
```

### templates\\INDEX.md
`$(@{Path=templates\\INDEX.md; Language=markdown; Lines=System.Object[]}.Language)
# Templates Index

## Overview
This directory contains template files for the AI Coding Workflow System, including PRP (Plan Reference Protocol) templates.

## Templates

### PRP Templates
- [PRP Base Template](./prp/prp-base.md)
- [PRP AI Agent Template](./prp/prp-ai-agent.md)
- [PRP MCP Integration Template](./prp/prp-mcp-integration.md)
- [PRP API Endpoint Template](./prp/prp-api-endpoint.md)
- [PRP Frontend Component Template](./prp/prp-frontend-component.md)

## Navigation
- [Back to Root](../)
- [Features](../features/)
```

### templates\\prp\\prp-ai-agent.md
`$(@{Path=templates\\prp\\prp-ai-agent.md; Language=markdown; Lines=System.Object[]}.Language)
# PRP: {feature-name} - AI Agent

**Template**: prp-ai-agent.md | **Extends**: prp-base.md

## Goal

{Base template Goal section}

## All Needed Context

{Base template All Needed Context section}

### AI Agent Specific Context
- Agent framework documentation (Claude API, LangChain, etc.)
- Model capabilities and limitations
- Tool integration patterns
- Prompt engineering best practices
- Agent architecture patterns from codebase

## Implementation Blueprint

{Base template Implementation Blueprint section}

### Agent Architecture
- Agent type: {Claude agent, LangChain agent, custom agent}
- Framework: {Claude API, LangChain, custom framework}
- Model: {Claude Sonnet, GPT-4, etc.}
- Prompt engineering: {System prompts, user prompts, tool descriptions}

### Agent Tools
- Available tools: {List of tools agent can use}
- Tool integration: {How tools are integrated}
- Tool calling patterns: {How agent calls tools}
- Tool error handling: {How to handle tool failures}

### Agent Memory
- Memory type: {Conversation history, vector store, etc.}
- Context window: {Token limits, context management}
- Memory persistence: {How memory is stored and retrieved}

### Agent Workflow
- Execution flow: {Step-by-step agent execution}
- Decision making: {How agent makes decisions}
- Error handling: {How agent handles errors}
- State management: {How agent maintains state}

## Validation Loop

{Base template Validation Loop section}

### Agent Testing
- Prompt testing: {How to test prompts}
- Tool testing: {How to test tool integration}
- End-to-end testing: {How to test complete agent workflow}
- Performance testing: {How to test agent performance}

### Output Validation
- Response quality: {How to validate agent responses}
- Tool call validation: {How to validate tool calls}
- Error handling validation: {How to validate error handling}

## Anti-Patterns

{Base template Anti-Patterns section}

### AI Agent Specific Anti-Patterns
- Overly complex prompts: Keep prompts focused and clear
- Ignoring context limits: Manage context window carefully
- Not handling tool errors: Always handle tool failures gracefully
- Hardcoding responses: Use dynamic generation
- Not testing prompts: Test prompts thoroughly before deployment
- No memory management: Always implement memory persistence
- Ignoring token limits: Respect model token limitations
```

### templates\\prp\\prp-api-endpoint.md
`$(@{Path=templates\\prp\\prp-api-endpoint.md; Language=markdown; Lines=System.Object[]}.Language)
# PRP: {feature-name} - API Endpoint

**Template**: prp-api-endpoint.md | **Extends**: prp-base.md

## Goal

{Base template Goal section}

## All Needed Context

{Base template All Needed Context section}

### API Specific Context
- API framework documentation (Express, FastAPI, etc.)
- API design patterns from codebase
- Authentication patterns from codebase
- Validation patterns from codebase
- Error handling patterns from codebase

## Implementation Blueprint

{Base template Implementation Blueprint section}

### API Design
- Endpoint: {HTTP method and path}
- Request format: {Request body, query parameters, headers}
- Response format: {Response body, status codes, headers}
- Error format: {Error response format}
- Versioning: {API versioning strategy}

### API Authentication
- Authentication method: {JWT, API key, OAuth, etc.}
- Authorization: {Role-based, permission-based, etc.}
- Security: {HTTPS, CORS, rate limiting, etc.}
- Token validation: {How to validate tokens}
- Token refresh: {How to handle token refresh}

### API Validation
- Request validation: {Input validation, schema validation}
- Response validation: {Output validation, schema validation}
- Error handling: {Error response format, error codes}
- Sanitization: {Input sanitization, XSS prevention}
- Content validation: {Content-Type validation}

### API Documentation
- Documentation format: {OpenAPI, Swagger, Markdown}
- Endpoint documentation: {Request/response examples}
- Error documentation: {Error codes and messages}
- Versioning documentation: {How API versioning is documented}
- Example requests: {Example requests for testing}

### Rate Limiting & Throttling
- Rate limiting strategy: {How rate limiting is implemented}
- Rate limit values: {Rate limit configuration}
- Throttling behavior: {What happens when rate limit exceeded}
- Rate limit headers: {Headers for rate limit information}

### API Monitoring & Logging
- Request logging: {What is logged for each request}
- Error logging: {How errors are logged}
- Performance metrics: {Metrics collected for monitoring}
- Alerting: {Alert conditions and notification}

## Validation Loop

{Base template Validation Loop section}

### API Testing
- Unit testing: {Test controllers, services, models}
- Integration testing: {Test API endpoints end-to-end}
- Performance testing: {Test API performance, load testing}
- Security testing: {Test authentication, authorization, input validation}
- Error testing: {Test error handling and error responses}

### API Contract Testing
- Schema validation: {Test against defined schemas}
- Example validation: {Test with example requests}
- Error scenario testing: {Test all error scenarios}
- Edge case testing: {Test edge cases and boundary conditions}

## Anti-Patterns

{Base template Anti-Patterns section}

### API Specific Anti-Patterns
- Not validating input: Always validate all input
- Exposing sensitive data: Never expose sensitive data in responses
- Not handling errors: Always return proper error responses
- Ignoring security: Always implement authentication and authorization
- Not documenting APIs: Always document API endpoints
- Hardcoding responses: Use dynamic generation based on input
- Ignoring rate limits: Respect rate limiting and implement properly
- Not monitoring performance: Always monitor API performance
- Inconsistent error responses: Use consistent error format across all endpoints
```

### templates\\prp\\prp-base.md
`$(@{Path=templates\\prp\\prp-base.md; Language=markdown; Lines=System.Object[]}.Language)
# PRP: {feature-name}

**Version**: 1.0 | **Last Updated**: {timestamp} | **Related**: PRD.md, TECH-SPEC.md

## Goal

### Feature Goal
{Clear description of what this feature accomplishes. Should be specific and measurable.}

### Deliverable
{What will be delivered - specific artifacts, files, functionality. List exact deliverables.}

### Success Criteria
{How to verify success - acceptance criteria, tests, validation. Must be measurable and testable.}

## All Needed Context

### Documentation URLs
{External documentation references - API docs, framework docs, best practices. Include links and why each is needed.}

### Codebase Patterns
{Relevant patterns from codebase - file structure, naming conventions, architecture patterns. Extract from Prime export if available.}

### File References
{Specific files to reference - similar implementations, utilities, helpers. Include file paths and purpose.}

### Naming Conventions
{File naming, function naming, class naming, variable naming conventions. Follow existing patterns from codebase.}

### Architecture Patterns
{Service structure, API patterns, data flow, component organization. Reference existing architecture.}

### Reference Library
{Optional: Specify which reference categories to load for token-efficient context.

**Loading Instructions**: During implementation, query archon_references table by category/tags:
```sql
-- Example: Load python and mcp references
SELECT * FROM archon_references
WHERE category = 'python' OR 'mcp' = ANY(tags);
```

**Required Categories**: {list categories needed - e.g., python, mcp, react}
**Optional Tags**: {list specific tags - e.g., async, hooks, testing}

**Standard Categories**:
- python: Python patterns, libraries, best practices
- mcp: MCP server development
- react: React, Next.js, hooks
- typescript: TypeScript/JavaScript patterns
- ai-agents: AI agent patterns, prompting
- testing: Testing patterns, frameworks
- patterns: General design patterns
- supabase: Supabase/database patterns
- api: API design, REST, GraphQL

If no references are needed, leave this section empty or omit it.}

## Implementation Blueprint

### Data Models
{Data structures, schemas, interfaces, types. Include:
- Data models with fields and types
- Relationships between models
- Validation schemas
- Type definitions}

### Implementation Tasks
{Step-by-step tasks with dependencies. Include:
- Task ID
- Task description
- Dependencies
- Estimated effort}

### Dependencies
{Task dependencies, external dependencies, prerequisites. List:
- Internal dependencies (other tasks, files)
- External dependencies (packages, libraries, services)
- System dependencies (database, API, etc.)}

### File Structure
{Directory layout, file organization, where to create files. Include:
- New directories to create
- New files to create
- Files to modify
- File organization rationale}

### Integration Points
{How this feature integrates with existing codebase, APIs, services. Include:
- Existing APIs to call
- Existing services to integrate with
- Data flow between components
- Event listeners or subscriptions}

## Validation Loop

### Syntax Validation
{Commands to validate syntax - linters, formatters, type checkers. Include:
- Lint commands
- Format commands
- Type check commands
- Pre-commit hooks}

### Unit Tests
{How to write and run unit tests, test structure, test patterns. Include:
- Test framework
- Test file locations
- Test naming conventions
- Coverage requirements}

### Integration Tests
{How to write and run integration tests, test setup, test patterns. Include:
- Test setup and teardown
- Mock/stub requirements
- Test data fixtures
- Test execution commands}

### End-to-End Tests
{How to test complete workflow from user perspective. Include:
- User scenarios to test
- Test data requirements
- Expected outcomes}

## Anti-Patterns

### General Anti-Patterns
- Skipping tests: Always write tests for new code
- Hardcoding values: Use configuration and environment variables
- Ignoring errors: Handle all error cases gracefully
- Not documenting: Document complex logic and decisions
- Over-engineering: Keep solutions simple (YAGNI)
- Premature optimization: Optimize only when needed (YAGNI)
- Violating conventions: Follow existing codebase patterns

### Feature-Specific Anti-Patterns
{Feature-specific anti-patterns to avoid. Include:
- Common mistakes for this feature type
- Domain-specific pitfalls
- Integration issues to watch for
- Performance considerations}

## Notes

- This PRP contains everything needed to implement successfully without prior knowledge
- Extract codebase patterns from Prime export (context/prime-{timestamp}.md)
- Follow naming conventions from existing codebase
- Test thoroughly before marking as complete
- Update STATUS.md as you progress through tasks
```

### templates\\prp\\prp-frontend-component.md
`$(@{Path=templates\\prp\\prp-frontend-component.md; Language=markdown; Lines=System.Object[]}.Language)
# PRP: {feature-name} - Frontend Component

**Template**: prp-frontend-component.md | **Extends**: prp-base.md

## Goal

{Base template Goal section}

## All Needed Context

{Base template All Needed Context section}

### Frontend Specific Context
- Frontend framework documentation (React, Vue, Svelte, etc.)
- Component patterns from codebase
- Styling patterns from codebase
- State management patterns from codebase
- Testing patterns from codebase

## Implementation Blueprint

{Base template Implementation Blueprint section}

### Component Architecture
- Component type: {Functional component, class component, etc.}
- Props: {Component props and types}
- State: {Component state, state management}
- Lifecycle: {Component lifecycle hooks}
- Hooks: {Custom hooks, composition patterns}
- Refs: {When and how to use refs}

### Component Styling
- Styling approach: {CSS modules, styled-components, Tailwind, etc.}
- Responsive design: {Breakpoints, mobile-first, etc.}
- Theming: {Theme support, dark mode, etc.}
- CSS architecture: {Global styles, component styles, utility classes}
- Animation: {Component animations and transitions}

### Component Integration
- API integration: {How component fetches data}
- State management: {How component manages state}
- Routing: {How component integrates with routing}
- Event handling: {Event propagation and handling}
- Context integration: {How component consumes context}

### Component Performance
- Optimization: {Memoization, lazy loading, etc.}
- Code splitting: {How component is code split}
- Bundle size: {How to minimize bundle size}
- Rendering optimization: {How to optimize rendering performance}
- Image optimization: {How to optimize images}

### Accessibility
- ARIA attributes: {Required ARIA attributes}
- Keyboard navigation: {Keyboard interaction support}
- Screen reader support: {How to support screen readers}
- Focus management: {How to manage focus}
- Color contrast: {How to ensure accessible colors}

## Validation Loop

{Base template Validation Loop section}

### Component Testing
- Unit testing: {Test component rendering, props, state}
- Integration testing: {Test component integration}
- Visual testing: {Test component appearance}
- Accessibility testing: {Test component accessibility}
- Performance testing: {Test component performance}

### User Testing
- User scenarios: {Key user flows to test}
- Edge cases: {Edge cases to test}
- Error states: {How to test error handling}
- Loading states: {How to test loading states}

## Anti-Patterns

{Base template Anti-Patterns section}

### Frontend Specific Anti-Patterns
- Not handling loading states: Always show loading states
- Not handling errors: Always handle and display errors
- Ignoring accessibility: Always implement accessibility features
- Not optimizing performance: Always optimize component performance
- Not testing components: Always test components thoroughly
- Prop drilling: Use composition instead of prop drilling
- Giant components: Break down large components into smaller ones
- State duplication: Avoid duplicating state across components
- Inline styles: Use appropriate styling approach
- Ignoring responsive design: Always implement responsive layouts
```

### templates\\prp\\prp-mcp-integration.md
`$(@{Path=templates\\prp\\prp-mcp-integration.md; Language=markdown; Lines=System.Object[]}.Language)
# PRP: {feature-name} - MCP Integration

**Template**: prp-mcp-integration.md | **Extends**: prp-base.md

## Goal

{Base template Goal section}

## All Needed Context

{Base template All Needed Context section}

### MCP Specific Context
- MCP server documentation
- MCP protocol specification
- Tool definitions and schemas
- Resource definitions and schemas
- MCP integration patterns from codebase

## Implementation Blueprint

{Base template Implementation Blueprint section}

### MCP Server Configuration
- Server type: {HTTP, stdio, SSE}
- Authentication: {API keys, tokens, etc.}
- Connection: {How to connect to MCP server}
- Configuration file: {Where MCP server is configured}

### MCP Tools
- Available tools: {List of tools from MCP server}
- Tool definitions: {Tool schemas and parameters}
- Tool usage patterns: {How to call tools}
- Tool error handling: {How to handle tool errors}
- Tool result validation: {How to validate tool responses}

### MCP Resources
- Available resources: {List of resources from MCP server}
- Resource access: {How to access resources}
- Resource caching: {How to cache resources}
- Resource error handling: {How to handle resource errors}

### MCP Prompts
- Prompt templates: {Available prompt templates}
- Prompt management: {How to manage prompts}
- Prompt usage: {How to use prompts}
- Prompt variables: {How to pass variables to prompts}

### MCP Integration Patterns
- Client initialization: {How to initialize MCP client}
- Connection lifecycle: {How to manage connection lifecycle}
- Error handling: {How to handle MCP errors}
- Retry logic: {How to handle retries and backoff}

## Validation Loop

{Base template Validation Loop section}

### MCP Testing
- Server connection testing: {How to test MCP server connection}
- Tool testing: {How to test MCP tools}
- Resource testing: {How to test MCP resources}
- Integration testing: {How to test MCP integration}
- Performance testing: {How to test MCP performance}

### Error Handling Validation
- Connection errors: {How to validate connection error handling}
- Tool errors: {How to validate tool error handling}
- Resource errors: {How to validate resource error handling}
- Rate limit handling: {How to validate rate limit handling}

## Anti-Patterns

{Base template Anti-Patterns section}

### MCP Specific Anti-Patterns
- Not handling server unavailability: Always implement fallbacks
- Not validating tool responses: Validate all tool responses
- Ignoring rate limits: Respect MCP server rate limits
- Not caching resources: Cache resources when appropriate
- Hardcoding tool calls: Use dynamic tool discovery
- Ignoring connection lifecycle: Properly manage connection state
- Not handling errors: Always implement comprehensive error handling
- Not testing integration: Test MCP integration thoroughly
```

### testing\\INDEX.md
`$(@{Path=testing\\INDEX.md; Language=markdown; Lines=System.Object[]}.Language)
# Testing Index

## Overview
This directory contains test execution results generated by the Test command. Test results include test outcomes, coverage analysis, and AI-suggested fixes.

## Files

## Navigation
- [Back to Root](../)
- [Features](../features/)
- [Reviews](../reviews/)
```

## Index
- Total Files: 74
- Total Lines: 14246
- Languages: =1, gitignore=1, json=2, markdown=70
